Linux 概述
1、资源可见性
	秉承UNIX的优良传统，Linux默认具有全局资源视图。
	在Linux 和Unix中“一切皆文件”。在这里，认为资源是任何可以用来帮助软件执行的东西【包括硬件及其抽象（CPU和RAM、文件）、文件系统、硬盘驱动器、固态驱动器（SSD）、进程、与网络相关的东西（如设备或路由表），以及代表用户的凭据。】
	注意：并非Linux中的所有资源都是文件或通过文件接口表示。有一些系统，可以更进一步。
	Linux资源的具体示例如下：
	①	查看Linux版本信息：
	# cat /proc/version 
	Linux version 5.14.0-352.el9.x86_64 (mockbuild@x86-05.stream.rdu2.redhat.com) (gcc (GCC) 11.4.1 20230605 (Red Hat 11.4.1-2), GNU ld version 2.35.2-42.el9) #1 SMP PREEMPT_DYNAMIC Wed Aug 9 00:25:27 UTC 2023cat /proc/version
	②	查看正在使用的CPU的特定硬件信息：
	# cat /proc/cpuinfo | grep "model name"
	model name      : Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
	③	打印进程状态（有关当前进程的详细信息）并将输出限制为仅显示当前六行。
	# cat /proc/$$/status | head -n6
		Name:   bash
		Umask:  0022
		State:  S (sleeping)
		Tgid:   1034
		Ngid:   0
		Pid:    1034
	》补充：$$
		这是一个特殊变量，涉及当前进程。在shell上下文中，$$是在其中输入命令的shell的进程ID。
	在Linux中可以有多个具有相同PID的进程【不同的上下文【命名空间】中可以有多个具有相同PID的进程，如在容器化设置。
	每个进程可能认为它很特殊，具有PID 1，在更传统的设置中，它是为用户空间进程树的根保留的。
	给定资源可以有全局视图（两个用户在完全相同的位置查看文件）以及本地或虚拟化视图。Linux中的所有内容并非默认都是全局的。
	多个用户或进程并行运行的错觉的一部分是对资源的（有限的）可见性。在Linux中提供（某些受支持的）资源的本地视图是通过命名空间。
	第二个独立的维度是隔离。考虑进程隔离的一种方法是限制内存消耗，以便一个进程不会导致其他进程没有内存可用。如为应用程序提供1GB的RAM供使用。如果它使用更多，就会因为内存不足而被杀死。这提供了一定程度的保护。在Linux中，使用称为cgroups的内核功能来提供这种隔离。
	另一方面，完全隔离的环境使应用程序看起来完全独立。如虚拟机可用于提供完全隔离。
	任何Linux发行版的核心都具有内核【kernel】，提供其他所有内容所构建的API。文件、网络和可观察性这三个核心主题随处可见。
	从形式上来说，POSIX（便携式操作系统接口）是一个IEEE标准，用于定义UNIX操作系统的服务接口。动机是提供不同实现之间的可移植性。如果读到“符合POSIX标准”之类的内容，考虑一组在官方采购环境中特别相关的正式规范，而在日常使用中则不太相关。
	Linux 的构建是为了兼容 POSIX 以及 UNIX 系统 V 接口定义 (SVID)，这赋予了它老式 AT&T UNIX 系统的风格，而不是 Berkeley Software Distribution (BSD)风格系统。


hells and Scripting
1、基础
	①	终端【terminals】
	终端是提供文本用户界面的程序。即终端支持从键盘读取字符并显示在屏幕上。除了基本的面向字符的输入和输出之外，终端还支持所谓的转义序列或转义代码，用于光标和屏幕处理，并可能支持颜色。如【Ctrl H】产生退格，从而删除光标左侧的字符。
	环境变量【TERM】标识正在使用的终端仿真器，其配置可通过 infocmp 获得。
	终端的示例不仅包括 xterm、rxvt 和 Gnome terminator，还包括利用 GPU 的新一代终端，例如 Alacritty、kitty 和 warp。
	②	Shells
	shell是一个在终端内运行并充当命令解释器的程序。shell 通过流【streams】提供输入和输出处理，支持变量，有一些可以使用的内置命令，处理命令执行和状态，并且通常支持交互式使用和脚本化使用。
	shell在sh中定义，经常遇到的POSIX shell，它在脚本和可移植性的上下文中变得更加重要。最初有 Bourne shell sh，现在它通常被 bash sh取代【Bourne Again Shell】。
	可以使用 file -h /bin/sh来查看，或使用 echo $0，或 echo $SHELL 。
	# file -h /bin/sh
	/bin/sh: symbolic link to bash
	# echo $0
	-bash
	# echo $SHELL
	/bin/bash
	sh 以及其他变体还有更多实现，例如 Korn shell、ksh 和 C shell、csh。
		Ⅰ	流【Streams】
		shell 为每个进程准备了三个用于输入和输出的默认文件描述符（FD）：
			》stdin（FD 0）
			》stdout（FD 1）
			》stderr（FD 2）
		这些 FD 默认情况下分别连接到屏幕和键盘。 换句话说，除非指定其他内容，否则在 shell 中输入的命令将从键盘获取输入 (stdin)，并将其输出 (stdout) 传送到屏幕。
		如果不想使用 shell 提供的默认值（如，不希望在屏幕上输出stderr，希望将其保存到文件中），可以重定向流。
		可以使用 $FD> 和 <$FD 重定向进程的输出流，其中，$FD 是文件描述符——如，2> 表示重定向 stderr 流。注意，1> 和 > 是相同的，因为 stdout 是默认值。如果想重定向 stdout 和 stderr ，使用 &> ，当想摆脱流时，可使用 /dev/null 。如：
		①	通过重定向 stdout 和 stderr 到 /dev/null来丢弃输出：
			curl https://example.com &> /dev/null
		②	重定向输出和状态到不同的文件：
			curl https://example.com > /tmp/content.txt 2> /tmp/curl-status
		③	交互式输入并保存到文件；使用Ctrl D停止捕获并存储内容：
			cat > /tmp/interactive-input.txt
		④	使用从 stdin 读取的 tr 命令将所有单词小写
			tr < /tmp/curl-status [A-Z] [a-z]
		shell 通常可以理解一些特殊字符：
		①	&
			放置在命令末尾，在后台执行命令
		②	\
			用于在下一行继续命令，以提高长命令的可读性
		③	|
			将一个进程的标准输出与下一个进程的标准输入连接起来，允许传递数据，而不必将其存储在文件中所谓临时位置。
		Ⅱ	变量【Variables】
		在shell中经常遇到的一个术语是变量。每当不想或无法对值进行硬编码时，都可以使用变量来存储和更改值。使用案例如下：
			①	当想要处理Linux公开的配置项时【如，shell 查找 $PATH 变量中捕获的可执行文件位置】。这是一种可读取/写入变量的接口。
			②	当想要以交互式项用户查询某个值时，如在脚本上下文中。
			③	当想要通过定义一次长值来缩短输入时。
		区分两种变量
			①	环境变量
				Shell范围的设置；用 env 列出它们
			②	Shell 变量
				在当前执行的上下文中有效；在bash中用 set 列出它们。Shell变量不会被子进程继承。在bash中可使用 export 来创建环境变量。要访问一个变量的值，在其前面放一个$，当想删除一个变量时，使用 unset。
		示例：
			[root@dns-server ~]# set MY_VAR=42								定义一个shell 变量，并为其赋值
			[root@dns-server ~]# set | grep MY_VAR
			_=MY_VAR=42														_= 表示其没有导出【exported】
			[root@dns-server ~]# export MY_GLOBAL_VAR="fun with vars"		定义一个环境变量
			[root@dns-server ~]# set | grep "MY_*"							
			MY_GLOBAL_VAR='fun with vars'
			_='MY_GLOBAL_VAR=fun with vars'
			[root@dns-server ~]# env | grep "MY_*"							列出环境变量
			MY_GLOBAL_VAR=fun with vars
			[root@dns-server ~]# bash										创建一个新的shell会话——当前shell会话的子进程，不会继承其 MY_VAR shell变量
			[root@dns-server ~]# echo $MY_GLOBAL_VAR
			fun with vars
			[root@dns-server ~]# set | grep "MY_*"
			MY_GLOBAL_VAR='fun with vars'
			[root@dns-server ~]# exit
			exit
			[root@dns-server ~]# unset $MY_VAR								移除 shell 变量 MY_VAR
			[root@dns-server ~]# set | grep 'MY_*'
			MY_GLOBAL_VAR='fun with vars'
		对于任何变量，都可以使用 echo $XXX 查看相应的值，其中 XXX 是变量名称。常用shell 和 环境变量如下：
			变量			类型				描述
			EDITOR			ENV					默认情况下用于编辑文件的程序路径
			HOME			POSIX				当前用户的家目录路径
			HOSTNAME		bash shell			当前主机的主机名
			IFS				POSIX				用于分隔字段的字符列表；当shell在扩展时分割单词时使用
			PATH			POSIX				包含 shell 查找可执行程序（二进制文件或脚本）的目录列表
			PS1				ENV					shell 提示符
			PWD				ENV					当前工作目录的完整路径
			OLDPWD			bash shell			最后一个cd命令之前的目录的完整路径
			RANDOM			bash shell			0~32767之间的随机整数
			SHELL			ENV					包含当前使用的shell
			TERM			ENV					使用的终端模拟器
			UID				ENV					当前用户的UID（整数值）
			USER			ENV					当前用户
			_				bash shell			在前台执行的上一个命令的最后一个参数
			?				bash shell			退出状态码
			$				bash shell			当前进程的ID（整数值）
			0				bash shell			当前进程的进程名
		bash特定变量的完整列表【https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html】。
		Ⅲ	退出状态
		shell 使用所谓的退出状态向调用者传达命令执行的完成情况。 一般来说，Linux 命令在终止时会返回一个状态。 这可以是正常终止或异常终止。0 退出状态表示命令已成功运行，没有任何错误，而 1 到 255 之间的非零值表示失败。
		使用 $? 查看退出状态。
		注意，管道中的退出状态管理，因为某些shell仅提供最后一个状态。可以使用$PIPESTATUS来解决此限制。
		Ⅳ 	内置命令
		shell带有许多内置命令【如，yes、echo、cat或read】（根据Linux发行版，其中一些命令可能不是内置命令，而是位于 /usr/bin 中）。可以使用help 命令来列出内置命令。注意，其他一切都是shell 外部程序。
		查找可执行文件，如：
			# which is
			# type is
		Ⅴ	任务控制
		大多数 shell 支持的一项功能称为作业控制。 默认情况下，当输入命令时，它会控制屏幕和键盘，通常称之为在前台运行。要在后台启动进程，在末尾添加 &，或者要将前台进程发送到后台，按 Ctrl Z。
		如果想保持后台进程运行，即使在退出shell后，可以在前面添加 nohup 命令。此外，对于已经在运行并且没有以nohup开头的进程，可以在事后使用disown来达到相同的效果。
	常用 shell 快捷方式
		动作				命令				注意
		光标移动到行首		Ctrl+a
		光标移动到行尾		Ctrl+e
		光标前进一个字符	Ctrl+f
		光标后退一个字符	Ctrl+b
		光标前进一个单词	Alt+f
		光标后退一个单词	Alt+b
		删除光标左侧的字符	Ctrl+h
		删除光标左侧的单词	Ctrl+w
		删除光标右边内容	Ctrl+k
		删除光标左边内容	Ctrl+u
		清屏				Ctrl+l
		取消命令			Ctrl+c
		撤销				Ctrl+_				仅bash
		搜索历史			Ctrl+r
		取消搜索			Ctrl+g
		注意：这些快捷键是在Emacs编辑模式下，如果倾向于vi，可使用 set -o vi 切换到 vi
2、友好的shell
3、终端复用器
4、脚本编写
	①	脚本基础
		除了变量、流和重定向以及常用命令之外，在脚本上下文中还有一些需要熟悉的特定内容。
		Ⅰ	高级数据类型
		虽然shell通常将所有内容都视为字符串（如果想执行一些更复杂的数字任务，可能不应该使用shell脚本），但它确实支持一些高级数据类型【如数组】：
			os=('Linux' 'macOS' 'Windows')
			echo "${os[0]}"
			numberofos="${#os[@]}"
		Ⅱ	流控制
		流程控制允许在脚本中分支（if）或重复（for和while），使执行取决于特定条件。如：
			for afile in /tmp/*; do
				echo "$afile"
			done

			for i in {1..10}; do
				echo "$i"
			done

			while true; do
				...
			done
		Ⅲ	函数
		函数允许编写更加模块化和可重用的脚本。必须在使用函数之前定义该函数【shell从上到下解释脚本】。如
			sayhi () {
				echo "Hi $1 hope you are well
			}
			sayhi "Michael"
		Ⅳ	高级 I/O
		通过 read ，可以从stdin读取用户输入，可以使用它来引发运行时输入。此外，不要使用 echo ，考虑使用 printf ，它允许对输出（包括颜色）进行细粒度控制。printf 也比 echo 更便携。如：
			read name
			printf "Hello %s" "$name"
		还有其他更高级的概念可供使用【如 signal 和 traps】。
	②	编写可移植的脚本
		如果脚本是可移植的，那么它可以在许多不同的系统上运行（shells、Linux发行版等）。
		注意，即使确定了shell的类型【如，bash】，并非所有功能在不同版本的shell中都以相同的方式工作。归根结底，归结为可以在其中测试脚本的不同环境的数量。
		Ⅰ	执行可移植脚本
			脚本实际上只是文本文件；扩展名并不重要，尽管约定使用 .sh 。有两件事可以将文本文件转换为可执行并且能够由shell运行的脚本：
			》文件需要在第一行声明解释器，使用所谓的shebang（或hashbang），写为 #! 。
			》需要给予文件执行权限【如，chmod +x】。注意最小权限原则。
		Ⅱ	骨架模板
			可作为可移植 bash shell 脚本的骨架模板如下：
				#! /usr/bin/env bash						# ①
				set -o errexit								# ②
				set -o nounset								# ③	
				set -o pipefail								# ④

				firstargument="${1:-somedefualtvalue}"		# ⑤
				echo "$firstargument"

			①	hashbang 指示希望使用 bash 来解释此脚本
			②	定义如果发生错误要停止脚本执行
			③	定义将未设置的变量视为错误【脚本不太可能默默失败】
			④	定义当管道的一部分发生故障时，整个管道应被视为发生故障【有助于避免无声故障】
			⑤	带有默认值的命令行参数示例
		Ⅲ	好习惯
			》Fail fast and loud
			避免无声失败，并快速失败；像 errexit 和 pipefail 可以做到这一点。由于八十、默认情况下往往会静默失败，因此快速失败几乎总是一个好习惯。
			》Sensitive information
			不要将任何敏感信息（如，密码）硬编码到脚本中。此类信息应在运行时通过用户输入或调用API提供。另外，注意ps会泄露程序参数等，这是泄露敏感信息的另一种方式。
			》Input sanitization
			尽可能为变量设置并提供合理的默认值，并清理从用户或其他来源收到的输入。如通过read命令提供或交互引入的启动参数，以避免由于未设置变量而导致看似无辜的 rm -rf "$PROJECTHOME/"* 擦除驱动器的情况。
			》Check dependencies
			不要假设某个工具或命令可用，除非它是内置的或知道目标环境。
			》Error handling
			当脚本失败时（问题不在于是否失败，而是何时何地），为用户提供可操作说明。
			》Documentation
			为脚本块添加注释（# Some doc），并尝试坚持80列宽以提高可读性和差异。
			》Versioning
			考虑使用git对脚本进行版本控制
			》Testing
			检查并测试脚本。
	③	检查和测试脚本
		在开发过程中，需要检查和检查脚本，确保正确使用命令和说明。可以使用 ShellCheck 程序做到这一点，可以在本地下载并安装它，也可通过shellcheck.net使用在线版本。
		另外，考虑使用 shfmt 格式化脚本，它会自动修复shellcheck 稍后报告的问题。
		此外，在将脚本放到仓库之前，考虑使用bats对其进行测试。bats【https://github.com/sstephenson/bats】是 Bash Automated Testing System 的缩写，允许使用测试用例的特殊语法将测试文件定义为bash脚本。
		每个测试用例指示一个带有描述的bash函数，通常会调用这些脚本作为 CI 管道的一部分，如作为Github操作【action】。
	④	端到端示例：Github 用户信息脚本
		示例脚本应该采用 Github 用户句柄并打印除一条消息，其中包含用户加入的年份机器完整信息。如：
			#! /usr/bin/env bash

			set -o errexit
			set -o errtrace
			set -o nounset
			set -o pipefail

			### Command line parameter:
			targetuser="${1:-dimple-wmj}"						# 提供一个默认值，以便在用户未提供时使用

			### Check if our dependencies are met:
			if ! [ -x "$(command -v jq)"]; then
				echo "jq is not installed" >&2
				exit 1
			fi

			### Main:
			githubapi="https:/api.github.com/users/"
			tmpuserdump="tmp/ghuserdump_$targetuser.json"

			result=$(curl -s $githubapi$targetuser)				# 使用 curl 访问 Github API 下载用户信息【JSON格式文件】
			echo $result > $tmpuserdump							# 将用户信息保存到临时文件

			name=$(jq .name $tmpuserdump -r)					# 使用 jq 提取需要的字段
			created_at=$(jq .created_at $tmpuserdump -r)		# created_at 字段的值类似于 2009-02-07T16:07:32Z

			joinyear=$(echo $created_at | cut -f1 -d"-")		# 使用 cut 从 JSON文件中的created_at字段中提取年份
			echo $name joined Github in $joinyear				
		虽然这个脚本看起来不错并且在大多数情况下都可以工作，但总有一些地方可以改进，例如使脚本更加健壮并提供可操作的错误消息。 
		在这种情况下，考虑使用 bashing【https://github.com/xsc/bashing】、rerun【https://github.com/rerun/rerun】或 rr【https://taarr.com/】 等框架来提高模块化性。
5、补充
	》Shell Scripts
		Shell Style Guide【https://google.github.io/styleguide/shellguide.html】
		Bash Best Practices【https://bertvv.github.io/cheat-sheets/Bash.html】
		Bash Scripting Cheatsheet【https://bertvv.github.io/cheat-sheets/Bash.html】


Access Control
1、Basic
	①	资源和所有权
		用户	启动进程和拥有文件。进程是内核加载到主内存并运行的程序（可执行文件）。
		文件	有所有者；默认，创建该文件的用户拥有该文件
		进程	使用文件进行通信和持久化。用户也可间接使用文件，但他们需要通过进程来这样做。
	②	沙箱【sandboxing】
		在谈论资源访问时，经常会遇到的一个术语是沙箱。沙箱是一个定义模糊的术语，可以指一系列不同的方法，从监狱【jails】到容器再到虚拟机，可以在内核或用户空间中进行管理。
		通常有一些东西在沙箱中运行——通常是一些应用程序，并且监督机制在沙箱进程和托管环境之间强制执行一定程度的隔离。
	③	访问控制类型
		访问控制的一方面是访问本身的性质。用户或进程是否直接访问资源。或者也许有一套明确的规则，规定进程在什么情况下可以访问哪种资源（文件或系统调用）。或者甚至可能记录访问本身。
		在Linux环境中，两个最重要的是：
			自主访问控制【DAC】	根据用户的身份限制对资源的访问。它是任意的，因为具有某些权限的用户将它们传递给其他用户。
			强制访问控制		基于表示安全级别的分层模型。用户被分配许可级别，资源被分配安全标签。用户只能访问等于（或低于）自己权限级别对应的资源。
								在强制访问控制模型中，管理员严格且排他地控制访问，设置所有权限。即，用户无法自己设置权限，即使他们拥有资源。
		Linux传统上有一种要么全由要么全无的态度——要么是有权改变一切的超级用户，要么是访问权限有限的普通用户。为了稍微限定以下Linux中【全有或全无的态度】：大多数Linux系统中的默认设置允许【其他人】对几乎每个文件和可执行文件进行读取访问。
		SELinux 可能是最著名的 Linux 强制访问控制实现。 它是为了满足政府机构的高安全要求而开发的，并且通常在这些环境中使用，因为可用性受到严格的规则的影响。 强制访问控制的另一个选项是 AppArmor，自 2.6.36 版本起就包含在 Linux 内核中，并且在 Ubuntu 系列 Linux 发行版中相当流行。
2、用户
	在 Linux 中，经常从目的或预期用途的角度区分两种类型的用户帐户：
	①	系统用户	通常，程序（有时称为守护程序）使用这些类型的帐户来运行后台进程。这些程序提供的服务可以是系统的一部分，如网络【sshd】，也可以是应用程序层【如mysql】。
	②	常规用户	通过shell交互使用Linux的人类用户。
	Linux 通过 UID 来识别用户，属于一个或多个组的用户通过组ID（GID）来识别。不同的Linux发行版有自己的方式来决定如何管理UID范围。如支持systemd的发行版具有以下约定：
		UID 0	 					root
		UID 1 ~ 999					为系统用户保留
		UID 65534					nobody
		UID 1000 ~ 65533
			65536 ~ 4294967294		常规用户
	①	本地用户管理
		实现本地用户管理的四个文件是：
			/etc/passwd				用户数据库
			/etc/group				组数据库
			/etc/shadow				用户密码
			/etc/gshadow			组密码
		/etc/passwd 用于跟踪普通用户的用户名、UID、组成员身份和其他数据【如主目录、登录shell等】。
		》说明
			root:x:0:0:root:/root:/bin/bash
			①	root		用户名【不得超过32个字符】
			②	x			用户的密码，x 表示（加密的）密码存储在 /etc/shadow 中
			③	0			UID。注意，Linux 保留 1000 以下的 UID 供系统使用。
			④	0			用户主组（GID），见 /etc/group
			⑤	root		用户信息【全名或联系信息，如电话号码】。通常也称为GECOS字段【注意，不适用GECOS格式，而是字段本身通常有能够与与账号关联的信息】。
			⑥	/root		用户家目录
			⑦	/bin/bash	登录 shell。要防止交互式登录，请使用 /sbin/nologin
		由于历史原因，密码存储在 /etc/shadow 文件中。虽然每个用户都可以读取 /etc/passwd ，但通常需要root权限才能读取 /etc/shadow 。
		使用 useradd 命令新建用户。
		》useradd 使用说明
		用法：useradd [选项] 登录名
		      useradd -D
		      useradd -D [选项]
		
		选项：
		      --badname                 do not check for bad names
		  -b, --base-dir BASE_DIR       新账户的主目录的基目录
		      --btrfs-subvolume-home    use BTRFS subvolume for home directory
		  -c, --comment COMMENT         新账户的 GECOS 字段
		  -d, --home-dir HOME_DIR       新账户的主目录
		  -D, --defaults                显示或更改默认的 useradd 配置
		  -e, --expiredate EXPIRE_DATE  新账户的过期日期
		  -f, --inactive INACTIVE       新账户的密码不活动期
		  -g, --gid GROUP               新账户主组的名称或 ID
		  -G, --groups GROUPS           新账户的附加组列表
		  -h, --help                    显示此帮助信息并退出
		  -k, --skel SKEL_DIR           使用此目录作为骨架目录
		  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值
		  -l, --no-log-init             不要将此用户添加到最近登录和登录失败数据库
		  -m, --create-home             创建用户的主目录
		  -M, --no-create-home          不创建用户的主目录
		  -N, --no-user-group           不创建同名的组
		  -o, --non-unique              允许使用重复的 UID 创建用户
		  -p, --password PASSWORD       加密后的新账户密码
		  -r, --system                  创建一个系统账户
		  -R, --root CHROOT_DIR         chroot 到的目录
		  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files
		  -s, --shell SHELL             新账户的登录 shell
		  -u, --uid UID                 新账户的用户 ID
		  -U, --user-group              创建与用户同名的组
		  -Z, --selinux-user SEUSER     为 SELinux 用户映射使用指定 SEUSER
		除了用户之外，Linux还有组的概念，组在某种意义上只是一个或多个用户的集合。任何常规用户都属于一个默认组，但也可以是其他组的成员。可以通过 /etc/group 文件找到有关组和映射的信息。
	②	集中用户管理
		如果必须管理多台机器或服务器，本地用户管理很快就会过时。这是需要一种集中的方式来可以在本地应用于一台特定计算机的用户。有如下几种方式：
		Ⅰ	基于目录
			轻量级目录访问协议（LDAP）是一套已有数十年历史的协议，现已有IFTF正式化，它定义了如何通过互联网协议（IP）访问和维护分布式目录。
		Ⅱ	通过网络
			可以使用Kerberos通过网络方式对用户进行身份验证
		Ⅲ	使用配置管理系统
			这些系统（包括 Ansible、Chef、Puppet 或 SaltStack）可用于跨机器一致地创建用户。
3、权限
	①	文件权限
		文件权限是Linux资源访问概念的核心，Linux中的一切或多或少都是文件【一切皆文件】。权限分为三种类型或范围【从窄到宽】：
		Ⅰ	用户	文件所有者
		Ⅱ	组		有一个或多个成员
		Ⅲ	其他人	
		有三种类型的访问：
		Ⅰ	读（r）		对于普通文件，允许用户查看文件的内容。对于目录，允许用户查看目录中文件的名称。
		Ⅱ	写（w）		对于普通文件，允许用户修改或删除文件。对于目录，允许用户创建，重命名和删除目录中的文件。
		Ⅲ	执行（x）	对于普通文件，如果用户也具有该文件的读权限，则允许用户执行该文件。对于目录，允许用户访问目录中的文件信息，有效地允许他们进入该目录（cd）或列出其内容（ls）。
		其他文件访问位【access bits】
		s				应用于可执行文件的 setuid/setgid 权限。运行它的用户继承文件所有者或所属组的有效权限。
		t				粘滞位【sticky bit】。仅与目录有关。如果设置，它将阻止非root用户删除其中的文件（除非该用户拥有该目录/文件）
		Linux中还可以通过 chattr（更改属性）命令进行特殊设置。
		》文件权限说明【ls -al】
			-rw-r--r--. 1 miggi miggi   390 12月  5 18:34 Leanring_Modern_linux
			①	文件模式【file mode】
				Ⅰ	文件类型【-】
				Ⅱ	文件所有者权限【rw-】
				Ⅲ	文件所属组权限【r--】
				Ⅳ	其他人的权限【r--】
			②	硬链接数【1】
			③	文件所有者【miggi】
			④	文件所属组【miggi】
			⑤	文件大小（bytes）【390】
			⑥	上次修改时间戳【12月  5 18:34】
			⑦	文件名
		》文件类型
			-			常规文件
			b			块特殊文件
			c			字符特殊文件
			C			高性能（连续数据）文件
			d			目录
			l			符号连接
			p			命名管道（使用 mkfifo 创建）
			s			套接字文件
			？			其他（未知）文件类型
		》文件权限表示方式：
			r（4）、w（2）、x（1）
	②	进程权限
		在运行时权限上下文中存在不同的相关用户ID（credenti(7) manual page【https://man7.org/linux/man-pages/man7/credentials.7.html】）：
		Ⅰ	真实UID【Real UID】
			真实UID是启动该进程的用户的UID。它代表人类用户的进程所有权。进程本身可通过 getuid(2) 获取其真实的UID，并且可以使用 stat -c "%u %g" /proc/$pid/ 进行查询。
			如当普通用户【如，miggi】执行【passwd】命令时。通过【stat -c "%u %U %g" /proc/$pid/】会发现运行passwd的真实UID是0【root】。
		Ⅱ	有效UID【Effective UID】
			Linux内核使用有效UID来确定进程访问消息队列等共享资源时所拥有的权限。
			在传统的 UNIX 系统上，它们还用于文件访问。 然而，Linux 之前使用专用的文件系统 UID 来获取文件访问权限。出于兼容性原因，仍支持此功能。进程可以通过 geteuid(2) 获取其有效 UID。
		Ⅲ	已保存的设置用户ID【Saved set-user-ID】
			保存的设置用户ID用于 suid 情况，其中进程可以通过在真实UID和保存的设置用户ID之间切换其有效UID来获取特权。
			如，为了允许进程使用某些网络端口，它需要提升权限（如，以root身份运行）。进程可通过 getresuid(2) 获取其保存的设置用户ID。
		Ⅳ	文件系统 UID【Filesystem UID】
			这些特定于Linux的ID用于确定文件访问权限。最初引入此UID是为了支持文件服务器代表普通用户进行操作，同时将进程与所述用户的信号隔离的用例。
			程序通常不会直接操作这个UID。内核会跟踪有效UID何时更改，并自动更改文件系统UID。这意味着文件系统UID通常与有效UID相同，但可以通过 setfsuid(2)进行更改。
			注意，从技术上讲，自内核v2.0起不再需要此UID，但出于兼容性考虑，仍受支持。
		最初，当通过 fork(2) 创建子进程时，它会继承其父进程UID的副本，并且在execve(2) 系统调用期间，会保留进程的真实UID，而有效UID和保存的设置用户ID可能会改变。
		如，当运行passwd时，有效UID是您的UID【如1000】。现在，passwd启用了suid设置，这意味着当运行它时，有效UID时0【root】。还有其他方法可以影响有效UID，如使用chroot和其他沙箱技术。
		POSIX 线程【https://en.wikipedia.org/wiki/Pthreads】要求进程中的所有线程都共享凭据。然而，在内核级别，Linux为每个线程维护单独的用户组凭据。
		除了文件访问权限之外，内核还将进程UID用于其他用途，如：
			①	建立发送信号的权限【如，确定当对某个进程ID执行 kill -9 时会发生什么】
			②	调度和优先级的权限处理【如，nice】
			③	检查资源限制
		虽然在 suid 的背景下使用有效的 UID 进行推理可能很简单，但一旦功能发挥作用，它可能会更具挑战性。
4、高级权限管理
	①	功能【Capabilities】
		在Linux中，与UNIX系统中的传统情况一样，root用户在运行进程时没有任何限制。换句话说，内核只区分两种情况：
		Ⅰ	特权进程，绕过内核权限检查，有效UID为0（root）
		Ⅱ	非特权进程，具有非零有效UID，内核对其进行权限检查
		随着内核v2.2中功能系统调用的引入，这种二进制世界观发生了变化：传统上与root相关的特权现在被分解为可以在每个线程级别上独立分配的不同单元。
		实际上，这个想法是正常进程的能力为零。可以为可执行文件（二进制文件和shell脚本）以及进程分配功能，以逐步添加执行任务所需的权限。
		现在，注意：功能通常仅与系统级任务相关。即大多数时候，不一定依赖它们。一些更广泛使用的功能如下：
			功能【Capability】			语义学【Semantics】
			CAP_CHOWN					允许用户对文件的UID/GID进行任意更改
			CAP_KILL					允许向属于其他用户的进程发送信号
			CAP_SETUID					允许更改UID
			CAP_SETPCAP					允许设置正在运行的进程的功能
			CAP_NET_ADMIN				允许各种与网络相关的操作【如，接口配置】
			CAP_NET_RAW					允许使用RAW和PACKET套接字
			CAP_SYS_CHROOT				允许调用chroot
			CAP_SYS_ADMIN				允许系统管理操作，包括挂载文件系统
			CAP_SYS_PTRACE				允许使用 strace 调试进程
			CAP_SYS_MODULE				允许加载内核模块
		查看系统所有功能概览：
			# capsh --print
			Current: =ep
			Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore
			Ambient set =
			Current IAB: 
			Securebits: 00/0x0/1'b0 (no-new-privs=0)
			 secure-noroot: no (unlocked)
			 secure-no-suid-fixup: no (unlocked)
			 secure-keep-caps: no (unlocked)
			 secure-no-ambient-raise: no (unlocked)
			uid=0(root) euid=0(root)
			gid=0(root)
			groups=0(root)
			Guessed mode: UNCERTAIN (0)
		查看当前进程【shell】的所有功能概览：
			# grep Cap /proc/$$/status
			CapInh: 0000000000000000
			CapPrm: 000001ffffffffff
			CapEff: 000001ffffffffff
			CapBnd: 000001ffffffffff
			CapAmb: 0000000000000000
		可以使用 getcap 和 setcap 以细粒度的方式（即基于每个文件）管理功能。
		功能有助于从“全有或全无”的方法过渡到基于文件的更细粒度的权限。
	②	seccomp Profiles
		安全计算模式【secure computing mode（seccomp）】是自2005年起提供的Linux内核功能。这种沙箱技术背后的基本思想是，使用名为 seccomp(2) 的专用系统调用，可以限制进程可以使用的系统调用。
		可能会发现直接管理 seccomp 很不方便，但有一些方法可以轻松使用它。如，在容器环境中，Docker 和 Kubernetes 都支持 seccomp。
	③	访问控制列表
		借助于访问控制列表（ACLs），在Linux中拥有灵活的权限机制。ACL解决了传统权限的缺陷，因为它们允许向用户或不在用户组列表中的组授予权限。
		可以使用 grep -i acl /boot/config* 来检查发行版是否支持 ACL 【输出中包含 POSIX_ACL=Y】。为了对文件系统使用 ACL，必须在挂载时使用 acl 选项启用它【见 acl 的文档参考】。
5、良好的实践
	以下是更广泛的访问控制背景下的一些安全“良好实践”。 其中一些可能更适用于专业环境。
	①	最少权限
		最小权限原则是指一个人或进程应该只拥有完成给定任务所需的权限。如，如果应用程序不写入文件，则它只需要读取访问权限。 在访问控制的上下文中，可以通过两种方式实践最小权限：
		》通过数字模式使用显式权限比符号模式更好
		》尽可能避免以root身份运行【优先考虑 sudo 提权】
		注意，如果正在编写应用程序，则可以使用 SELinux 策略来限制仅访问选定的文件、目录和其他功能。 相比之下，默认的 Linux 模型可能会让应用程序访问系统上打开的任何文件。
	②	避免 setuid
		利用功能【capabilities】而不是依赖 setuid【为攻击者提供了一种接管系统的好方法】
	③	审计【auditing】
		审计是指以无法篡改结果日志的方式记录操作（以及执行这些操作的人员）。然后，可以使用此只读日志来验证谁在何时做了什么。
6、扩展
	①	通用【General】
		》“A Survey of Access Control Policies”【https://www.cs.umd.edu/sites/default/files/scholarly_papers/ACrowell_1.pdf】
		》Lynis【https://cisofy.com/lynis/】，审计和合规性测试工具
	②	功能【Capabilities】
		》“Linux Capabilities in Practice”【https://blog.container-solutions.com/linux-capabilities-in-practice】
		》“Linux Capabilities: Making Them Work”【https://www.kernel.org/doc/ols/2008/ols2008v1-pages-163-172.pdf】
	③	seccomp
		》“A seccomp Overview”【https://lwn.net/Articles/656307/】
		》“Sandboxing in Linux with Zero Lines of Code”【https://blog.cloudflare.com/sandboxing-in-linux-with-zero-lines-of-code/】
	④	访问控制列表【ACLs】
		》“POSIX Access Control Lists on Linux”【https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/gruenbacher/gruenbacher_html/main.html】
		》“Access Control Lists” via ArchLinux【https://wiki.archlinux.org/title/Access_Control_Lists】
		》“An Introduction to Linux Access Control Lists (ACLs)” via Red Hat【https://www.redhat.com/sysadmin/linux-access-control-lists】


FileSystems
	“一切皆文件”的UNIX概念在Linux中依然存在，虽然这不是100%正确，但Linux中的大多数资源确实是文件。
	还有其他东西在Linux中也以文件形式公开【如设备和伪设备】—— echo "Hello modern Linux users" > /dev/pst/0 ，它将 Hello modern Linux users 打印到屏幕上。
	虽然可能不会将这些资源与文件关联，但可以使用与常规文件相同的方法和工具来访问它们。
	所有这些东西的共同点是标准化、统一的接口：打开文件、收集文件信息、写入文件等。在Linux中，文件系统提供了这种统一的接口。这个接口，再加上Linux将文件视为字节流，而不对结构有任何期望，使我们能够构建可处理各种不同文件类型的工具。
1、基础
	一般来说，文件系统是在内核【kernel】中实现的。虽然出于性能原因，文件系统通常在内核空间中实现，但也可选择在用户空间中实现它们。
	见“Filesystem in Userspace（FUSE）documentation”【https://www.kernel.org/doc/html/latest/filesystems/fuse.html】和 libfuse project site【https://github.com/libfuse/】。
	术语定义:
		①	Drive
			物理（physical）块设备，如硬盘驱动器（HDD）或固态驱动器（SSD）。在虚拟机环境中，还可以模拟驱动器——如，/dev/sda（SCSI设备）或/dev/sdb（SATA设备）或/dev/hda（IDE设备）
		②	Partition
			可以在逻辑上将驱动器划分为分区，即一组存储扇区。如在HDD上创建两个分区，然后将显示为 /dev/sdb1 和 /dev/sdb2 。
		③	Volume
			卷有点类似于分区，但它更灵活，并且也针对特定文件系统进行格式化。
		④	Super block
			格式化后，文件系统在开头有一个特殊的部分，用于捕获文件系统的元数据。这包括文件系统类型、块、状态以及每个块有多少inode等内容。
		⑤	Inodes
			在文件系统中，inodes存储有关文件的元数据【如，大小、所有者、路径、日期和权限】。但，inodes不存储文件名和实际数据。它保存在目录中，目录实际上只是一种特殊的常规文件，将inodes映射到文件名。
	查看系统中存在哪些驱动器、分区和卷：
		# lsblk --exclude 7											# 列出所有块设备，但排除伪（循环）设备
		NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
		sda           8:0    0    20G  0 disk						# 磁盘驱动器为 sda，总量为20G
		├─sda1        8:1    0     1G  0 part /boot					# 这里有两个分区，sda1 是 启动分区
		└─sda2        8:2    0    19G  0 part
		  ├─cs-root 253:0    0    17G  0 lvm  /						# 第二个分区【sda2】，包含两个卷
		  └─cs-swap 253:1    0     2G  0 lvm  [SWAP]
		sr0          11:0    1 112.8M  0 rom
		sr1          11:1    1   9.1G  0 rom
	查看正在使用的文件系统：
		# findmnt -D -t nosquashfs												# 列出文件系统，squashfs 类型【https://www.kernel.org/doc/html/latest/filesystems/squashfs.html】除外。
		SOURCE              FSTYPE     SIZE   USED  AVAIL USE% TARGET
		devtmpfs            devtmpfs     4M      0     4M   0% /dev
		tmpfs               tmpfs      1.8G      0   1.8G   0% /dev/shm
		tmpfs               tmpfs    723.5M     9M 714.4M   1% /run
		/dev/mapper/cs-root xfs       16.9G   1.9G    15G  12% /
		/dev/sda1           xfs        960M 233.9M 726.1M  24% /boot
		tmpfs               tmpfs    361.7M      0 361.7M   0% /run/user/1000
		tmpfs               tmpfs    361.7M      0 361.7M   0% /run/user/0
	squashfs 最初为CD开发的专用只读压缩文件系统，现在也用于快照。
	可以更进一步，查看各个文件系统对象，如目录或文件：
		# stat anaconda-ks.cfg
		  文件：anaconda-ks.cfg
		  大小：807             块：8          IO 块：4096   普通文件			# 文件类型信息
		设备：fd00h/64768d      Inode：17800211    硬链接：1					# 设备和索引节点信息
		权限：(0600/-rw-------)  Uid：(    0/    root)   Gid：(    0/    root)
		环境：system_u:object_r:admin_home_t:s0
		最近访问：2023-12-20 06:06:35.042665672 +0800
		最近更改：2023-12-03 19:24:09.799711336 +0800
		最近改动：2023-12-03 19:24:09.799711336 +0800
		创建时间：2023-12-03 19:24:09.553178493 +0800
	低级文件系统和块设备命令：
		命令				使用场景
		lsblk				列出所有块设备
		fdisk，parted		管理磁盘分区
		blkid				显示块设备属性【如UUID】
		hwinfo				显示硬件信息
		file -s				显示文件系统和分区信息
		stat，df -i，ls -i	显示并列出inode相关信息
	在文件系统上下文中会遇到另一个术语【链接】。有时想要引用具有不同名称的文件或提供快捷方式。Linux中有两种类型的链接：
		①	硬链接【hard links】
			引用inode，不能引用目录。它们也不能跨文件系统。
		②	符号链接【symbolic links or symlinks】
				特殊文件，其内容表示另一个文件的路径的字符串。
		创建硬链接：
			ln myfile somealias
		创建符号链接：
			ln -s myfile somesoftalias
2、虚拟文件系统
	Linux通过称为虚拟文件系统（VFS【https://elixir.bootlin.com/linux/latest/source/Documentation/filesystems/vfs.rst】）的抽象，设法提供对多种资源（内存中、本地附加或网络存储）的类似文件的访问。
	基本思想是在客户端（系统调用）和实现具体设备或其他类型资源的操作的各个文件系统之间引入一个间接层。这意味着VFS将通过操作（打开、读取、查找）于实际实现细节分开。
	VFS 是内核中的一个抽象层，它为客户端提供基于文件范例的访问资源的通用方法。Linux中的文件没有任何规定的结构；它只是一个字节流。由客户端决定字节的含义。VFS抽象了对不同类型的文件系统的访问：
	①	本地文件系统【如，ext3，XFS，FAT，和NTFS】
		这些文件系统使用驱动程序来访问本地块设备，如HDD或SSD。
	②	内存中文件系统【如，tmpfs】
		不受长期存储设备支持，而是驻留在内存（RAM）中。
	③	伪文件系统【如，procfs】
		这些文件系统本质上也是内存中的。它们用于内核接口和设备抽象。
	④	网络文件系统【如，NFS，Netware（nee Novell）】
		这些文件系统也使用驱动程序；然而，实际数据所在的存储设备不是本地连接的而是远程的。这意味着驱动程序涉及到网络操作。
	与文件相关的系统调用有超过100个；然而，从本质上讲，这些操作可以分为几个类别，如：
		类别				系统调用【syscall】示例
		Inodes				chmod，chown，stat
		Files				open，close，seek，truncate，read，write
		Directories			chdir，getcwd，link，unlink，rename，symlink
		Firesystems			mount，flush，chroot
		Others				mmap，poll，sync，flock
	许多 VFS 系统调用分派到特定于文件系统的实现。 对于其他系统调用，有 VFS 默认实现。 此外，Linux内核定义了相关的VFS数据结构——见 include/linux/fs.h【https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h】。如：
		inode	核心文件系统对象，捕获类型、所有权、权限、链接、指向包含文件数据的块的指针、创建和访问统计信息等。
		file	表示一个打开的文件（包括路径、当前位置和inode）
		dentry	存储其父目录和子目录（目录条目）
		super_block	表示一个文件包含挂载信息
		Others	包括 vfsmount 和 file_system_type
	Ⅰ	逻辑卷管理器
		虽然可以使用分区来划分驱动器，但分区很难使用，特别是需要调整大小（更改存储空间）时。逻辑卷管理器（LVM）在物理实体（如驱动器或分区）和文件系统之间使用一个间接层。
		这样就形成了一种设置，允许通过资源池实现无风险、零停机扩展和自动存储扩展。多个物理卷【PV】可以组成一个卷组【VG】，卷组又可以分成多个逻辑卷【LV】，在逻辑卷上创建文件系统。
		①	逻辑卷【PV】
			可以是一个磁盘分区，整个磁盘驱动，和其他设备
		②	逻辑卷【LV】
			是从卷组【VG】创建的块设备。这些在概念上与分区相当。必须在LV上创建文件系统才能使用它。可以在使用时轻松调整LV的大小。
		③	卷组【VG】
			是一组PV和LV之间的中间人。将VG视为共同提供资源的PV池。
		要使用 LVM 管理卷【https://unixutils.com/lvm-cheat-sheet-quick-reference/】，需要许多工具；然而，它们的命名一致且相对易于使用：
		①	PV管理工具	lvmdiskscan、pvdisplay、pvcreate、pvscan
		②	VG管理工具	vgs、vgdisplay、vgcreate、vgextend
		③	LV管理工具	lvs、lvscan、lvcreate
		》列出逻辑卷
			# lvscan
			  ACTIVE            '/dev/cs/swap' [1.00 GiB] inherit
			  ACTIVE            '/dev/cs/root' [<8.00 GiB] inherit
		》显示卷组
			# vgs
			  VG #PV #LV #SN Attr   VSize  VFree
			  cs   1   2   0 wz--n- <9.00g    0 
		》显示物理卷
			# pvdisplay 
			  --- Physical volume ---
			  PV Name               /dev/sda2
			  VG Name               cs
			  PV Size               <9.00 GiB / not usable 3.00 MiB
			  Allocatable           yes (but full)
			  PE Size               4.00 MiB
			  Total PE              2303
			  Free PE               0
			  Allocated PE          2303
			  PV UUID               RxkQml-RRIM-YEtJ-Y5vr-S6Z7-GZyq-YMclHO
		无论使用分区还是LV，使用文件系统还需要执行两个步骤。
	Ⅱ	文件系统操作
		在给定分区或逻辑卷（使用LVM创建）的情况下创建文件系统。涉及两个步骤：创建文件系统，然后安装它，或将其插入文件系统树中。
		①	创建文件系统
		为了使用文件系统，第一步是创建一个。这意味着正在设置组成文件系统的管理部分，并将分区或卷作为输入。一旦掌握了所有信息，就可以使用mkfs创建文件系统。
		mkfs接受两个主要输入：要创建的文件系统的类型和要在其上创建文件系统的设备（如，逻辑卷），如：
			mkfs -t ext4 \					# 创建 ext4 类型的文件系统
				/dev/some_vg/some_lv		# 在逻辑卷【/dev/some_vg/some_lv】上床架文件系统
		创建文件系统没有太多内容，因此主要工作是弄清楚要使用什么文件系统类型。使用 mkfs 创建文件系统后，可以使其在文件系统树中可用。
		②	挂载文件系统
		挂载文件系统意味着将其附加到文件系统树（从 / 开始）。使用 mount 附加文件系统。mount 需要两个主要输入：要附加的文件系统和文件系统树中的位置。
		此外，还可以提供其他输入，包括挂载选项（通过 -o），如只读，以及绑定挂载（通过 --bind ），用于将目录挂载到文件系统树中。
		也可以单独使用 mount 。列出现有挂载：
			# mount -t ext4,tmpfs
			tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel,inode64)
			tmpfs on /run type tmpfs (rw,nosuid,nodev,seclabel,size=188124k,nr_inodes=819200,mode=755,inode64)
			tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,seclabel,size=94060k,nr_inodes=23515,mode=700,inode64)
		必须确保使用创建文件系统时使用的类型来挂载文件系统。如使用 mount -t vfat /dev/sdxX2 /media 来挂载SD卡，必须知道SD卡是使用vfat格式化的。可以使用 -o 选项让 mount 尝试所有文件系统，直到其中一个可以工作。
		此外，挂载仅在系统运行期间有效，因此为了使其永久有效，需要使用 fstab 文件 (/etc/fstab)【开机自动挂载】。
		③	常见的文件系统布局
		一旦有了一个文件系统，一个明显的挑战就是想出一种组织其内容的方法。可能想要组织诸如程序存储位置、配置数据、系统数据和用户数据之类的内容。
		将这种目录及其内容的组织称为文件系统布局。正式地，该布局称为文件系统层次结构标准（FHS【https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html】）。
		它定义目录、包括其结构和推荐内容。Linux基金会维护FHS，它是Linux发行版遵循的一个很好的起点。
		FHS 背后的想法值得称赞。 然而，在实践中会发现文件系统布局很大程度上取决于使用的 Linux 发行版。 因此，建议使用 man hier 命令来了解具体设置。
		常见的顶级目录：
			目录			说明
			bin，sbin		系统程序和命令（通常链接到 /usr/bin 和 /usr/sbin）
			boot			内核镜像和相关组件
			dev				设备（终端，驱动等）
			etc				系统配置文件
			home			用户家目录
			lib				共享的系统库
			mnt，media		可移动媒介的挂载点
			opt				发行版特定；可以托管包管理器文件
			proc，sys		内核接口
			tmp				用于临时文件
			usr				用户程序（通常只读）
			var				用户程序（日志，备份，网络缓冲等）
3、伪文件系统
	伪文件系统只是假装是文件系统，以便可以以通常的方式（ls、cd、cat）与它们交互，但实际上它们包装了一些内核接口。接口可以是一系列东西，包括以下内容：
		①	有关进程的信息
		②	与设备的交互【如键盘】
		③	实用程序【如，可用作数据源或接收器的特殊设备】
	Ⅰ	procfs
		Linux从Unix中继承 /proc 文件系统（procfs）。最初的目的是从内核发布与进程相关的信息，使其可供ps或free等系统命令使用。它的结构规则很少，允许读写访问，随着时间的推移，许多东西都进入其中。一般，可以在那里找到两类信息：
			①	/proc/PID 中的每个进程信息。这是内核通过以PID作为目录名的目录公开的与进程相关的信息。
			②	其他信息，如挂载、网络相关信息、TTY驱动程序、内存信息、系统版本和正常运行时间。
		procfs中的每个进程信息（值得关注）
			条目		类型			信息
			attr		目录			安全属性
			cgroup		文件			控制组
			cmdline		文件			命令行
			cwd			链接			当前工作目录
			environ		文件			环境变量
			exe			链接			进程的可执行文件
			fd			目录			文件描述符
			io			文件			存储I/O（字节/字符 读取和写入）
			limits		文件			资源限制
			mem			文件			使用中的内存
			mounts		文件			使用中的挂载
			net			目录			网络统计
			stat		文件			进程状态
			syscall		文件			系统调用使用
			task		目录			每个任务（线程）信息
			timers		文件			定时器信息
		要查看其实际情况，检查一下进程状态。这里使用status而不是stat，它没有人类可读的标签：
			# cat /proc/self/status | head -10		# 获取当前运行命令【cat】的进程状态
			Name:   cat
			Umask:  0022
			State:  R (running)						# 当前状态（运行中，在CPU中）
			Tgid:   1346
			Ngid:   0
			Pid:    1346							# 当前进程的PI的
			PPid:   1083							# 命令的父进程ID
			TracerPid:      0
			Uid:    0       0       0       0
			Gid:    0       0       0       0
		从网络空间收集信息：
			# cat /proc/self/net/arp 
			IP address       HW type     Flags       HW address            Mask     Device
			192.168.3.1      0x1         0x2         14:51:20:94:4f:87     *        ens33
			192.168.3.4      0x1         0x2         0c:54:15:88:17:5b     *        ens33
		可以从这个特殊的 /proc/self/net/arp 中收集有关当前进程的ARP信息。
	Ⅱ	sysfs
		/sys 文件系统（sysfs）是一种特定于Linux的结构化方式，让内核使用标准化布局公开选择信息（如，有关设备的信息）。sysfs中的目录如下：
			①	block/		该目录符号链接到已发现的块设备。
			②	bus/		在此目录中，可以找到内核支持的每种物理总线类型的一个子目录
			③	class/		该目录包含设备类型
			④	dev/		该目录包含两个子目录：block/【块设备】和 char/【字符设备】，结构是 major-ID:minor-ID 。
			⑤	devices/	在此目录中，内核提供了设备树的表示
			⑥	firmware/	通过这些目录，可以管理特定于固件的属性
			⑦	fs/			该目录包含一些文件系统的子目录
			⑧	module/		在这些目录中，可以找到内核加载的每个模块的子目录。
		sysfs 中还有更多子目录，但有些是新的和/或会受益于更好的文档。会发现 sysfs 中重复的某些信息在 procfs 中也可用，但其他信息（例如内存信息）仅在 procfs 中可用。
		查看块设备信息，如：
			# ls -al /sys/block/sda/
	Ⅲ	devfs
		/dev 文件系统（devfs）托管设备特殊文件，代表从物理设备到随机数发生器或只写数据接收器等设备。通过devfs可用的和管理的设备有：
			①	块设备		以块的形式处理数据，如存储设备（驱动器）
			②	字符设备	逐个字符地处理事物，如终端、键盘或鼠标
			③	特殊设备	生成数据或允许操纵它，包括 /dev/null 或 /dev/random。
		获取一个随机字符串，可执行以下操作：
			tr -dc A-Za-z0-9 < /dev/urandom
		这里生成一个42个字符地随机序列，其中包括大写字母、小写字母和数字字符。虽然 /dev/urandom 看起来像一个文件并且可以像文件一样使用，但它确实是一个特殊的文件，它使用许多源生成（或多或少）随机输出。
			# echo "something" > /dev/tty
			something
		/dev/tty 代表终端，通过这个命令，将 something 发送给它。
4、常规文件
	Ⅰ	通用文件系统
		常规文件的通用文件系统
			文件系统	Linux开始支持年份	文件大小	卷大小		文件数			文件名长度
			ext2			1993			2TB			32TB		10^18			255 字符
			ext3			2001			2TB			32TB		可变			255 字符
			ext4			2008			16TB		1EB			40亿			255 字符
			btrfs			2009			16EB		16EB		2^18			255 字符
			XFS				2001			8EB			8EB			2^64			255 字符
			ZFS				2006			16EB		2^128字节	每个目录10^14	255 字符
			NTFS			1997			16TB		256TB		2^32			255 字符
			vfat			1995			2GB			N/A			每个目录2^16	255 字符
		广泛使用的常规文件文件系统：
			①	ext4【https://wiki.archlinux.org/title/Ext4 】	
				一种广泛使用的文件系统，现在许多发行版都默认使用。它是ext3的向后兼容演变。与ext3一样，它提供日志功能，即将更改记录在日志中，以便在最坏的情况下（如，断电），恢复速度很快。
				这是一个很好的通用选择，ext4 手册【https://www.man7.org/linux/man-pages/man5/ext4.5.html 】
			②	XFS【https://wiki.archlinux.org/title/XFS 】
				日志文件系统最初由 Silicon Graphics (SGI) 在 20 世纪 90 年代初为其工作站设计。 它提供对大文件和高速 I/O 的支持，例如现在在 Red Hat 发行版系列中使用。
			③	ZFS【https://en.wikipedia.org/wiki/ZFS 】
				ZFS 最初由 Sun Microsystems 于 2001 年开发，结合了文件系统和卷管理器功能。
			④	FAT【https://en.wikipedia.org/wiki/FAT_filesystem_and_Linux 】
				这实际上是 Linux 的 FAT 文件系统系列，其中最常用的是 vfat。 主要用例是与 Windows 系统以及使用 FAT 的可移动介质的互操作性。 许多围绕卷的固有考虑因素并不适用。
			驱动器并不是唯一可以存储数据的地方。
	Ⅱ	内存中文件系统
		有许多可用的内存文件系统；有些是通用目的，有些则有非常具体的用例。一些广泛使用的内存文件系统如下：
			①	debugfs【https://www.kernel.org/doc/html/latest/filesystems/debugfs.html 】
				用于调试的专用文件系统；常见挂载方式：mount -t debugfs none /sys/kernel/debug
			②	loopfs【https://man7.org/linux/man-pages/man4/loop.4.html 】
				允许将文件系统映射到块而不是设备。
			③	pipefs
				安装在管道上的特殊（伪）文件系统：启用管道。
			④	swapfs【https://linux.die.net/EVMSUG/x3863.html 】
				用于实现交换（不可挂载）
			⑤	tmpfs【https://www.kernel.org/doc/html/latest/filesystems/tmpfs.html 】
				将文件数据保存在内核缓存中的通用文件系统。它速度块但非持久（断电意味着数据丢失）。
	Ⅲ	写时复制文件系统
		写时复制（CoW）是一个巧妙地概念，可以提高I/O速度，同时使用更少的空间。实现原理如下：
			①	原始文件【file1】假设由A，B和C块组成，复制为目标文件【file2】，仅复制元数据（指向块的指针），而不是复制实际块。由于仅创建元数据，因此速度很快并且不会占用太多空间。
			②	当目标文件【file2】被修改（假设C中的某些内容发生更改）时，只有块C才会被复制：创建一个名为C'的新块，虽然file2仍然指向（使用）未修改的块A和B，但它现在使用新块（C'）来捕获新数据。
		联合挂载【union mounts https://en.wikipedia.org/wiki/Union_mount 】，其想法是，可以将多个目录组合（挂载）到一个位置，这样，对于结果目录的用户来说，该目录似乎包含所有参与目录的组合内容（或：并集）。
		使用联合挂载时，经常遇到的术语“上层文件系统”和“下层文件系统”，这暗示了挂载的分层顺序。详情见“Unifying Filesystems with Union Mounts”【https://lwn.net/Articles/312641/ 】
		对于联合挂载，细节决定成败。必须制定有关当文件存在于多个位置时会发生什么或写入或删除文件意味着什么的规则。
		CoW在Linux文件系统中的实现如下：
			①	Unionfs【https://unionfs.filesystems.org/ 】
				Unionfs为CoW文件系统实现了联合挂载。它允许在安装时使用优先级透明地覆盖来自不同文件系统的文件和目录。它广泛流行并在CD-ROM和DVD环境中使用。
			②	OverlayFS【https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html 】
				Linux 的联合挂载文件系统实现于 2009 年推出，并于 2014 年添加到内核中。使用 OverlayFS，一旦打开文件，所有操作都直接由底层（较低或较高）文件系统处理。
			③	AUFS【https://en.wikipedia.org/wiki/Aufs 】
				另一种事项内核联合挂载的尝试，AUFS尚未合并到内核中。它在Docker中默认使用；现在Docker默认使用带有存储驱动程序Overlay2的OverlayFS。
			④	btrfs【https://archive.kernel.org/oldwiki/btrfs.wiki.kernel.org/index.php/Main_Page.html 】
				btrfs是b-tree system的缩写，是最初由Oracle公司设计的CoW。如今，许多公司都为btrfs的开发做出了贡献，包括Facebook、Intel、SUSE和Red Hat。
				它具有许多功能，例如快照（用于基于软件的 RAID）和自动检测静默数据损坏。 这使得 btrfs 非常适合专业环境——例如，在服务器上。
扩展
	Ⅰ	Basics
	“UNIX File Systems: How UNIX Organizes and Accesses Files on Disk”【https://www.oakton.edu/user/2/rjtaylor/CIS228/Slide/UNIX%20File%20Systems%202.pdf 】
	“KHB: A Filesystems Reading List”【https://lwn.net/Articles/196292/ 】
	Ⅱ	VFS
	“Overview of the Linux Virtual File System”【https://www.kernel.org/doc/html/latest/filesystems/vfs.html 】
	“Introduction to the Linux Virtual Filesystem (VFS)”【https://www.starlab.io/blog/introduction-to-the-linux-virtual-filesystem-vfs-part-i-a-high-level-tour 】
	“LVM” on ArchWiki【https://wiki.archlinux.org/title/LVM 】
	“LVM2 Resource Page”【https://sourceware.org/lvm2/ 】
	“How to Use GUI LVM Tools”【https://www.linuxjournal.com/content/review-gui-lvm-tools 】
	“Linux Filesystem Hierarchy”【https://tldp.org/LDP/Linux-Filesystem-Hierarchy/Linux-Filesystem-Hierarchy.pdf 】
	“Persistent BPF Objects”【https://lwn.net/Articles/664688/ 】
	Ⅲ	Regular files
	“Filesystem Efficiency—Comparison of EXT4, XFS, BTRFS, and ZFS” thread on reddit【https://www.reddit.com/r/DataHoarder/comments/f5uzv8/filesystem_efficiancy_comparision_of_ext4_xfs/ 】
	“Linux Filesystem Performance Tests”【https://www.linux-magazine.com/Online/Features/Filesystems-Benchmarked 】
	“Comparison of File Systems for an SSD” thread on Linux.org【https://www.linux.org/threads/comparison-of-file-systems-for-an-ssd.28780/ 】
	“Kernel Korner—Unionfs: Bringing Filesystems Together”【https://www.linuxjournal.com/article/7714 】
	“Getting Started with btrfs for Linux”【https://opensource.com/article/20/11/btrfs-linux 】

				
Applications, Package Management, and Containers
1、基础
	①	程序【program】
		这通常是Linux可以加载到内存并执行的二进制文件或Shell脚本。引用该实体的另一种方式是可执行的【executable】。可执行文件的类型决定了运行它的确切方式。如shel将解释并执行shell脚本。
	②	进程【progress】
		基于程序的运行实体，在不休眠时加载到内存中并使用CPU或I/O。
	③	守护进程【daemon】
		有时也称为服务，这是一个为其他进程提供某种功能的后台进程。如，打印机守护程序允许您进行打印。 还有用于 Web 服务、日志记录、时间以及您日常依赖的许多其他实用程序的守护程序。
	④	应用程序【application】
		一个程序，包括它的依赖项。通常是一个实质性的程序，包括用户界面。通常将术语“应用程序”与程序、其配置及其数据的整个生命周期联系起来：从查找和安装到升级到删除。
	⑤	包【package】
		包含程序和配置的文件；用于分发软件应用程序。
	⑥	包管理器【package manager】
		一种程序，将包作为输入，并根据其内容和用户指令，在Linux环境中安装它，升级它或删除它。
	⑦	供应链【supply chain】
		软件生产商和分销商的集合，使您能够查找和使用基于软件包的应用程序；
	⑧	开机【booting】
		Linux中的启动顺序涉及硬件和操作系统初始化步骤，包括加载内核和启动服务（或守护进程）程序，目的是使Linux进入可使用的状态。
2、Linux启动过程
	Linux启动过程通常是一个多阶段的工作，其中硬件和内核一起工作。启动过程如下，包括五个步骤：
		|				Hardware				 	|	Kernel space	|		User space		 |
			开机 ——> UEFI 或 BIOS ——> Boot loader   ——> 	Kernel  	——> Init ——> 其他用户空间
	①	UEFI or BIOS
		在现代环境中，统一可扩展固件接口（UEFI）规范定义了启动配置（存储在NVRAM中）和启动加载程序。
		在较旧的系统中，在此步骤中，开机自检（POST）完成后，基本I/O系统（BIOS）将初始化硬件（管理I/O端口和中断）并将控制权移交给引导加载程序。
	②	boot loader
		引导加载程序有一个目标：引导内核。根据启动介质的不同，细节可能略有不同。有一系列引导加载程序选项，包括当前的（如GRUB 2、systemd-boot、SYSLINUX、rEFInd）和旧版（如LILO、GRUB 1）。
	③	kernel
		内核通常以压缩形式位于/boot 目录中。这意味着第一步是将内核提取并加载到内存中。在初始化其子系统、文件系统和驱动程序后，内核将控制权移交给init系统，引导过程随之正确结束。
	④	init
		init系统负责在系统范围内启动守护进程（服务进程）。该init进程是进程层次结构的根，其进程ID（PID）为1。PID为1的进程将一直运行，直到关闭系统电源。
		除了负责启动其他守护进程之外，PID 1进程传统上还负责处理孤儿进程【不再具有父进程的进程】。
	⑤	其他用户空间
		通常，在此之后会发生一些其他用户空间级初始化，具体取决于环境：
		》通常会进行终端、环境和shell初始化。
		》考虑到用户偏好和配置，启动了用于具有GUI的桌面环境的显示管理器、图形服务器等。
	Gentoo wiki 对可用的init系统进行了很好的比较【https://wiki.gentoo.org/wiki/Comparison_of_init_systems】。
	》补充【System V Init】
		System V风格的init程序（或简称SysV init）【https://savannah.nongnu.org/projects/sysvinit 】是Linux中的传统init系统。
		Linux从Unix继承了SysV，它定义了所谓的运行级别（系统状态【如暂停】，单用户、多用户模式或GUI模式），其配置通常存储在 /etc/init.d 中。
		然而，启动守护进程的顺序方式和特定于发行版的配置处理使得这成为一个不太可移植的选项。
3、systemd
	systemd【https://systemd.io/ 】 最初是一个 init 系统，是initd的替代品。但现在它是一个强大的管理程序，包括日志记录、网络配置和网络时间同步等功能。
	它提供了一种灵活、可移植的方式来定义守护进程及其依赖项，并提供了一个统一的接口来控制配置。目前几乎所有的Linux发行版都在使用systemd。
	特别是，systemd 通过执行以下操作来解决以前init系统的缺点：
		》提供统一的方式来管理跨发行版的启动
		》实施更快、更易于理解的服务配置
		》提供现代化的管理套件，包括监控、资源使用控制（通过cgroup）和内置审计
	此外，init 在初始化时按顺序（即按字母数字顺序）启动服务，而systemd可以启动任何满足其依赖关系的服务，从而可能加快启动时间。
	通过单元【unit】告诉 systemd 运行什么、何时运行以及如何运行。
	Ⅰ	Units
		systemd 中的单元【unit】是具有不同语义的逻辑分组，具体取决于其功能和/或其目标资源。systemd根据目标资源区分许多单元：
			①	service 单元	描述如何管理服务或应用程序
			②	target 单元		捕获依赖关系
			③	mount 单元		定义一个挂载点
			④	timer 单元		为cron 作业等定义计时器
		其他不太重要的单元类型包括：
			①	socket			描述网络或IPC套接字
			②	device			用于 udev 或 sysfs 文件系统
			③	automount		配置自动挂载点
			④	swap			描述交换空间
			⑤	path			用于基于路径的激活
			⑥	snapshot		允许在更改后重建系统的当前状态
			⑦	slice			与cgroup关联
			⑧	scope			管理外部创建的系统进程集
		为了被 systemd 识别，一个单元需要被序列化成一个文件。systemd在多个位置查找单元文件。三个最重要的文件路径如下：
			①	/lib/systemd/system		Package-installed units					
			②	/etc/systemd/system		System admin-configured units
			③	/run/systemd/system		Nonpersistent runtime modifications
	Ⅱ	使用 systemctl 进行管理
		用于与 systemd 交互以管理服务的工具是 systemctl【https://man7.org/linux/man-pages/man1/systemctl.1.html 】
		有用的 systemd 命令如下：
			命令									用法
			systemctl enable XXX.service			启用服务；设置开机自启
			systemctl daemon-reload					重新加载所有单元文件并重新创建整个依赖关系树
			systemctl start XXX.service				启动服务
			systemctl stop XXX.service				停止服务
			systemctl restart XXX.service			停止，然后启动服务
			systemctl reload XXX.service			向服务发出重新加载命令；回退重新启动
			systemctl kill XXX.service				停止服务执行
			systemctl status XXX.service			获取服务状态的简短摘要，包括一些日志行
		注意，systemctl 还提供了更多命令，从依赖项管理和查询到控制整个系统（例如重新启动）。systemd 生态系统还有许多其他可能会方便的命令行工具。 这包括但不限于以下内容：
			bootctl【https://man7.org/linux/man-pages/man1/bootctl.1.html 】
				允许检查引导加载程序状态并管理可用的引导加载程序。
			timedatectl
				允许设置和查看 时间和日期相关信息【https://opensource.com/article/20/6/time-date-systemd 】
			coredumpctl
				使您能够处理保存的核心转储。排除故障时请考虑使用此工具
	Ⅲ	使用 journalctl 进行监控
		日志【journal】是 systemd 的一个组件；从技术上讲，它是由 systemd-journald守护进程管理的二进制文件，为 systemd 组件记录的所有消息提供集中位置。可通过journalctl 查看 systemd 管理的日志。
	Ⅳ	示例
		定义一个类型为 service 的 systemd 单元文件【告诉 systemd 如何启动应用程序】，如：
			# greeter.service
			[Unit]
			Description=My Greeting Service		# 服务描述，当使用 systemctl status 时，会显示

			[Service]
			Type=oneshot		
			ExecStart=/home/miggi/greeter.sh	# 应用程序的路径
		定义一个 timer unit【https://wiki.archlinux.org/title/Systemd/Timers 】来每隔一个小时启动greeter 服务。如：
			# greeter.timer
			[Unit]
			Description=Runs Greeting service at the top of the hour

			[Timer]
			OnCalendar=hourly					# 使用 systemd 时间和日期格式【https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html 】时间表
		将定义的单元文件放在 /run/systemd/system 中，以便 systemd 识别它们。现在可以使用 greeter 定时器了【因为当将其复制到相应的目录时，systemd会自动拾取它】。
			# systemctl start greeter.timer
			# systemctl status greeter.timer
			● greeter.timer - Runs Greeting service at the top of the hour
			     Loaded: loaded (/run/systemd/system/greeter.timer; static)
			     Active: active (waiting) since Fri 2023-12-22 06:03:21 CST; 3s ago
			      Until: Fri 2023-12-22 06:03:21 CST; 3s ago
			    Trigger: Fri 2023-12-22 07:00:00 CST; 56min left
			   Triggers: ● greeter.service
			
			12月 22 06:03:21 localhost.localdomain systemd[1]: Started Runs Greeting service at the top of the hour.
		可以通过journalctl检查日志，如：
			# journalctl -f -u greeter.service			# 使用 journalctl 查看并跟踪【-f】greeter.service 单元（使用-u选择）的日志。
4、Linux 应用程序供应链【supply chain】
	供应链的含义是，一个由组织和个人组成的向消费者提供产品的系统。这里产品时由软件工件组成的应用程序，消费者则是使用应用程序的人，也可以将其视为管理应用程序的工具。
	Linux应用程序供应中的三个不同领域如下：
		①	软件维护者【Software maintainers】
			其中包括个人开发人员、开源项目和公司，例如独立软件供应商 (ISV)，它们生产软件工件并将其发布，例如作为存储库 (repo) 的包。
		②	仓库【Repository】
			这列出了包含应用程序的全部或部分以及元数据的包。该包通常捕获应用程序的依赖项。依赖项是应用程序运行所需的其他包。保持这些依赖关系是最新的很困难。
		③	工具【Tooling（包管理器）】
			在目标系统方面，这可以在存储库中查找软件包，并按照用户的指示安装、更新和删除应用程序。注意，一个或多个包可以代表应用程序及其依赖项。
	有许多选项可用于包和依赖项管理，例如传统的包管理器、基于容器的解决方案以及更新的方法。有关包和依赖项管理选项的三个主要类别的说明如下：
		①	传统包管理器
			通常区分低级【如，RPM】和高级【如，yum，dnf】工具。如包管理器可以解决依赖关系并提供高级接口（安装、更新、删除），将其称为高级包管理器。
		②	基于容器的解决方案
			这些最初来自服务器和云计算领域。 考虑到它们的功能，应用程序管理是一种用例，但不一定是主要用例。 换句话说，作为开发人员，会喜欢容器，因为它们能够轻松测试事物并轻松交付生产就绪的应用程序。
		③	现代包管理器
			这些根源于桌面环境，其主要目标是让最终用户尽可能轻松地使用应用程序。
5、包和包管理器
	包格式和包管理器通常源自两个主要的 Linux 发行版系列：Red Hat（RHEL、Fedora、CentOS 等）和 Debian 的系统（Debian、Ubuntu 等）。相关地两个概念如下：
		①	包【package】
			从技术上讲，文件通常是压缩的并且可能包含元数据。
		②	工具【tooling（包管理器）】
			处理目标系统上的这些包，以安装和维护应用程序。包管理器通常与仓库进行交互并维护包的本地缓存。
	Ⅰ	RPM 包管理器
		RPM Package Manager【https://en.wikipedia.org/wiki/RPM_Package_Manager 】最初由 Red Hat 创建，但现在广泛用于各种发行版。 .rpm 文件格式用于 Linux Standard Base，可以包含二进制文件或源文件。 
		这些软件包可以进行加密验证，并支持通过补丁文件进行增量更新。使用 RPM 的包管理器如下：
			yum			Amazon Linux，CentOS，Fedora 和 Red Hat	【http://yum.baseurl.org/ 】
			DNF			CentOS，Fedora，和 RedHat 【https://docs.fedoraproject.org/en-US/quick-docs/dnf/ 】
			Zypper		openSUSE 和 SUSE Linux Enterprise
		示例【安装 Go】
			①	找到 Go 的包
				yum search golang
			②	找到包的相关信息后，使用以下命令安装：
				yum install golang
			③	验证，准确检查安装的内容和位置：
				yum info golang
	Ⅱ	Debian deb
	Ⅲ	特定语言的包管理器
		还有特定于编程语言的包管理器，如下所示：
		①	C/C++		有许多不同的包管理器，包括 Conan 和 vcpkg	【https://caiorss.github.io/C-Cpp-Notes/package-managers.html 】
		②	Go			内置包管理器（go get，go mod）
		③	Node.js		npm和其他
		④	Java		maven和nuts，和其他
		⑤	Python		pip和PyPM
		⑥	Ruby		rubygems 和 Rails
		⑦	Rust		cargo
6、容器






		




	


Linux 概述
1、资源可见性
	秉承UNIX的优良传统，Linux默认具有全局资源视图。
	在Linux 和Unix中“一切皆文件”。在这里，认为资源是任何可以用来帮助软件执行的东西【包括硬件及其抽象（CPU和RAM、文件）、文件系统、硬盘驱动器、固态驱动器（SSD）、进程、与网络相关的东西（如设备或路由表），以及代表用户的凭据。】
	注意：并非Linux中的所有资源都是文件或通过文件接口表示。有一些系统，可以更进一步。
	Linux资源的具体示例如下：
	①	查看Linux版本信息：
	# cat /proc/version 
	Linux version 5.14.0-352.el9.x86_64 (mockbuild@x86-05.stream.rdu2.redhat.com) (gcc (GCC) 11.4.1 20230605 (Red Hat 11.4.1-2), GNU ld version 2.35.2-42.el9) #1 SMP PREEMPT_DYNAMIC Wed Aug 9 00:25:27 UTC 2023cat /proc/version
	②	查看正在使用的CPU的特定硬件信息：
	# cat /proc/cpuinfo | grep "model name"
	model name      : Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
	③	打印进程状态（有关当前进程的详细信息）并将输出限制为仅显示当前六行。
	# cat /proc/$$/status | head -n6
		Name:   bash
		Umask:  0022
		State:  S (sleeping)
		Tgid:   1034
		Ngid:   0
		Pid:    1034
	》补充：$$
		这是一个特殊变量，涉及当前进程。在shell上下文中，$$是在其中输入命令的shell的进程ID。
	在Linux中可以有多个具有相同PID的进程【不同的上下文【命名空间】中可以有多个具有相同PID的进程，如在容器化设置。
	每个进程可能认为它很特殊，具有PID 1，在更传统的设置中，它是为用户空间进程树的根保留的。
	给定资源可以有全局视图（两个用户在完全相同的位置查看文件）以及本地或虚拟化视图。Linux中的所有内容并非默认都是全局的。
	多个用户或进程并行运行的错觉的一部分是对资源的（有限的）可见性。在Linux中提供（某些受支持的）资源的本地视图是通过命名空间。
	第二个独立的维度是隔离。考虑进程隔离的一种方法是限制内存消耗，以便一个进程不会导致其他进程没有内存可用。如为应用程序提供1GB的RAM供使用。如果它使用更多，就会因为内存不足而被杀死。这提供了一定程度的保护。在Linux中，使用称为cgroups的内核功能来提供这种隔离。
	另一方面，完全隔离的环境使应用程序看起来完全独立。如虚拟机可用于提供完全隔离。
	任何Linux发行版的核心都具有内核【kernel】，提供其他所有内容所构建的API。文件、网络和可观察性这三个核心主题随处可见。
	从形式上来说，POSIX（便携式操作系统接口）是一个IEEE标准，用于定义UNIX操作系统的服务接口。动机是提供不同实现之间的可移植性。如果读到“符合POSIX标准”之类的内容，考虑一组在官方采购环境中特别相关的正式规范，而在日常使用中则不太相关。
	Linux 的构建是为了兼容 POSIX 以及 UNIX 系统 V 接口定义 (SVID)，这赋予了它老式 AT&T UNIX 系统的风格，而不是 Berkeley Software Distribution (BSD)风格系统。


hells and Scripting
1、基础
	①	终端【terminals】
	终端是提供文本用户界面的程序。即终端支持从键盘读取字符并显示在屏幕上。除了基本的面向字符的输入和输出之外，终端还支持所谓的转义序列或转义代码，用于光标和屏幕处理，并可能支持颜色。如【Ctrl H】产生退格，从而删除光标左侧的字符。
	环境变量【TERM】标识正在使用的终端仿真器，其配置可通过 infocmp 获得。
	终端的示例不仅包括 xterm、rxvt 和 Gnome terminator，还包括利用 GPU 的新一代终端，例如 Alacritty、kitty 和 warp。
	②	Shells
	shell是一个在终端内运行并充当命令解释器的程序。shell 通过流【streams】提供输入和输出处理，支持变量，有一些可以使用的内置命令，处理命令执行和状态，并且通常支持交互式使用和脚本化使用。
	shell在sh中定义，经常遇到的POSIX shell，它在脚本和可移植性的上下文中变得更加重要。最初有 Bourne shell sh，现在它通常被 bash sh取代【Bourne Again Shell】。
	可以使用 file -h /bin/sh来查看，或使用 echo $0，或 echo $SHELL 。
	# file -h /bin/sh
	/bin/sh: symbolic link to bash
	# echo $0
	-bash
	# echo $SHELL
	/bin/bash
	sh 以及其他变体还有更多实现，例如 Korn shell、ksh 和 C shell、csh。
		Ⅰ	流【Streams】
		shell 为每个进程准备了三个用于输入和输出的默认文件描述符（FD）：
			》stdin（FD 0）
			》stdout（FD 1）
			》stderr（FD 2）
		这些 FD 默认情况下分别连接到屏幕和键盘。 换句话说，除非指定其他内容，否则在 shell 中输入的命令将从键盘获取输入 (stdin)，并将其输出 (stdout) 传送到屏幕。
		如果不想使用 shell 提供的默认值（如，不希望在屏幕上输出stderr，希望将其保存到文件中），可以重定向流。
		可以使用 $FD> 和 <$FD 重定向进程的输出流，其中，$FD 是文件描述符——如，2> 表示重定向 stderr 流。注意，1> 和 > 是相同的，因为 stdout 是默认值。如果想重定向 stdout 和 stderr ，使用 &> ，当想摆脱流时，可使用 /dev/null 。如：
		①	通过重定向 stdout 和 stderr 到 /dev/null来丢弃输出：
			curl https://example.com &> /dev/null
		②	重定向输出和状态到不同的文件：
			curl https://example.com > /tmp/content.txt 2> /tmp/curl-status
		③	交互式输入并保存到文件；使用Ctrl D停止捕获并存储内容：
			cat > /tmp/interactive-input.txt
		④	使用从 stdin 读取的 tr 命令将所有单词小写
			tr < /tmp/curl-status [A-Z] [a-z]
		shell 通常可以理解一些特殊字符：
		①	&
			放置在命令末尾，在后台执行命令
		②	\
			用于在下一行继续命令，以提高长命令的可读性
		③	|
			将一个进程的标准输出与下一个进程的标准输入连接起来，允许传递数据，而不必将其存储在文件中所谓临时位置。
		Ⅱ	变量【Variables】
		在shell中经常遇到的一个术语是变量。每当不想或无法对值进行硬编码时，都可以使用变量来存储和更改值。使用案例如下：
			①	当想要处理Linux公开的配置项时【如，shell 查找 $PATH 变量中捕获的可执行文件位置】。这是一种可读取/写入变量的接口。
			②	当想要以交互式项用户查询某个值时，如在脚本上下文中。
			③	当想要通过定义一次长值来缩短输入时。
		区分两种变量
			①	环境变量
				Shell范围的设置；用 env 列出它们
			②	Shell 变量
				在当前执行的上下文中有效；在bash中用 set 列出它们。Shell变量不会被子进程继承。在bash中可使用 export 来创建环境变量。要访问一个变量的值，在其前面放一个$，当想删除一个变量时，使用 unset。
		示例：
			[root@dns-server ~]# set MY_VAR=42								定义一个shell 变量，并为其赋值
			[root@dns-server ~]# set | grep MY_VAR
			_=MY_VAR=42														_= 表示其没有导出【exported】
			[root@dns-server ~]# export MY_GLOBAL_VAR="fun with vars"		定义一个环境变量
			[root@dns-server ~]# set | grep "MY_*"							
			MY_GLOBAL_VAR='fun with vars'
			_='MY_GLOBAL_VAR=fun with vars'
			[root@dns-server ~]# env | grep "MY_*"							列出环境变量
			MY_GLOBAL_VAR=fun with vars
			[root@dns-server ~]# bash										创建一个新的shell会话——当前shell会话的子进程，不会继承其 MY_VAR shell变量
			[root@dns-server ~]# echo $MY_GLOBAL_VAR
			fun with vars
			[root@dns-server ~]# set | grep "MY_*"
			MY_GLOBAL_VAR='fun with vars'
			[root@dns-server ~]# exit
			exit
			[root@dns-server ~]# unset $MY_VAR								移除 shell 变量 MY_VAR
			[root@dns-server ~]# set | grep 'MY_*'
			MY_GLOBAL_VAR='fun with vars'
		对于任何变量，都可以使用 echo $XXX 查看相应的值，其中 XXX 是变量名称。常用shell 和 环境变量如下：
			变量			类型				描述
			EDITOR			ENV					默认情况下用于编辑文件的程序路径
			HOME			POSIX				当前用户的家目录路径
			HOSTNAME		bash shell			当前主机的主机名
			IFS				POSIX				用于分隔字段的字符列表；当shell在扩展时分割单词时使用
			PATH			POSIX				包含 shell 查找可执行程序（二进制文件或脚本）的目录列表
			PS1				ENV					shell 提示符
			PWD				ENV					当前工作目录的完整路径
			OLDPWD			bash shell			最后一个cd命令之前的目录的完整路径
			RANDOM			bash shell			0~32767之间的随机整数
			SHELL			ENV					包含当前使用的shell
			TERM			ENV					使用的终端模拟器
			UID				ENV					当前用户的UID（整数值）
			USER			ENV					当前用户
			_				bash shell			在前台执行的上一个命令的最后一个参数
			?				bash shell			退出状态码
			$				bash shell			当前进程的ID（整数值）
			0				bash shell			当前进程的进程名
		bash特定变量的完整列表【https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html】。
		Ⅲ	退出状态
		shell 使用所谓的退出状态向调用者传达命令执行的完成情况。 一般来说，Linux 命令在终止时会返回一个状态。 这可以是正常终止或异常终止。0 退出状态表示命令已成功运行，没有任何错误，而 1 到 255 之间的非零值表示失败。
		使用 $? 查看退出状态。
		注意，管道中的退出状态管理，因为某些shell仅提供最后一个状态。可以使用$PIPESTATUS来解决此限制。
		Ⅳ 	内置命令
		shell带有许多内置命令【如，yes、echo、cat或read】（根据Linux发行版，其中一些命令可能不是内置命令，而是位于 /usr/bin 中）。可以使用help 命令来列出内置命令。注意，其他一切都是shell 外部程序。
		查找可执行文件，如：
			# which is
			# type is
		Ⅴ	任务控制
		大多数 shell 支持的一项功能称为作业控制。 默认情况下，当输入命令时，它会控制屏幕和键盘，通常称之为在前台运行。要在后台启动进程，在末尾添加 &，或者要将前台进程发送到后台，按 Ctrl Z。
		如果想保持后台进程运行，即使在退出shell后，可以在前面添加 nohup 命令。此外，对于已经在运行并且没有以nohup开头的进程，可以在事后使用disown来达到相同的效果。
	常用 shell 快捷方式
		动作				命令				注意
		光标移动到行首		Ctrl+a
		光标移动到行尾		Ctrl+e
		光标前进一个字符	Ctrl+f
		光标后退一个字符	Ctrl+b
		光标前进一个单词	Alt+f
		光标后退一个单词	Alt+b
		删除光标左侧的字符	Ctrl+h
		删除光标左侧的单词	Ctrl+w
		删除光标右边内容	Ctrl+k
		删除光标左边内容	Ctrl+u
		清屏				Ctrl+l
		取消命令			Ctrl+c
		撤销				Ctrl+_				仅bash
		搜索历史			Ctrl+r
		取消搜索			Ctrl+g
		注意：这些快捷键是在Emacs编辑模式下，如果倾向于vi，可使用 set -o vi 切换到 vi
2、友好的shell
3、终端复用器
4、脚本编写
	①	脚本基础
		除了变量、流和重定向以及常用命令之外，在脚本上下文中还有一些需要熟悉的特定内容。
		Ⅰ	高级数据类型
		虽然shell通常将所有内容都视为字符串（如果想执行一些更复杂的数字任务，可能不应该使用shell脚本），但它确实支持一些高级数据类型【如数组】：
			os=('Linux' 'macOS' 'Windows')
			echo "${os[0]}"
			numberofos="${#os[@]}"
		Ⅱ	流控制
		流程控制允许在脚本中分支（if）或重复（for和while），使执行取决于特定条件。如：
			for afile in /tmp/*; do
				echo "$afile"
			done

			for i in {1..10}; do
				echo "$i"
			done

			while true; do
				...
			done
		Ⅲ	函数
		函数允许编写更加模块化和可重用的脚本。必须在使用函数之前定义该函数【shell从上到下解释脚本】。如
			sayhi () {
				echo "Hi $1 hope you are well
			}
			sayhi "Michael"
		Ⅳ	高级 I/O
		通过 read ，可以从stdin读取用户输入，可以使用它来引发运行时输入。此外，不要使用 echo ，考虑使用 printf ，它允许对输出（包括颜色）进行细粒度控制。printf 也比 echo 更便携。如：
			read name
			printf "Hello %s" "$name"
		还有其他更高级的概念可供使用【如 signal 和 traps】。
	②	编写可移植的脚本
		如果脚本是可移植的，那么它可以在许多不同的系统上运行（shells、Linux发行版等）。
		注意，即使确定了shell的类型【如，bash】，并非所有功能在不同版本的shell中都以相同的方式工作。归根结底，归结为可以在其中测试脚本的不同环境的数量。
		Ⅰ	执行可移植脚本
			脚本实际上只是文本文件；扩展名并不重要，尽管约定使用 .sh 。有两件事可以将文本文件转换为可执行并且能够由shell运行的脚本：
			》文件需要在第一行声明解释器，使用所谓的shebang（或hashbang），写为 #! 。
			》需要给予文件执行权限【如，chmod +x】。注意最小权限原则。
		Ⅱ	骨架模板
			可作为可移植 bash shell 脚本的骨架模板如下：
				#! /usr/bin/env bash						# ①
				set -o errexit								# ②
				set -o nounset								# ③	
				set -o pipefail								# ④

				firstargument="${1:-somedefualtvalue}"		# ⑤
				echo "$firstargument"

			①	hashbang 指示希望使用 bash 来解释此脚本
			②	定义如果发生错误要停止脚本执行
			③	定义将未设置的变量视为错误【脚本不太可能默默失败】
			④	定义当管道的一部分发生故障时，整个管道应被视为发生故障【有助于避免无声故障】
			⑤	带有默认值的命令行参数示例
		Ⅲ	好习惯
			》Fail fast and loud
			避免无声失败，并快速失败；像 errexit 和 pipefail 可以做到这一点。由于八十、默认情况下往往会静默失败，因此快速失败几乎总是一个好习惯。
			》Sensitive information
			不要将任何敏感信息（如，密码）硬编码到脚本中。此类信息应在运行时通过用户输入或调用API提供。另外，注意ps会泄露程序参数等，这是泄露敏感信息的另一种方式。
			》Input sanitization
			尽可能为变量设置并提供合理的默认值，并清理从用户或其他来源收到的输入。如通过read命令提供或交互引入的启动参数，以避免由于未设置变量而导致看似无辜的 rm -rf "$PROJECTHOME/"* 擦除驱动器的情况。
			》Check dependencies
			不要假设某个工具或命令可用，除非它是内置的或知道目标环境。
			》Error handling
			当脚本失败时（问题不在于是否失败，而是何时何地），为用户提供可操作说明。
			》Documentation
			为脚本块添加注释（# Some doc），并尝试坚持80列宽以提高可读性和差异。
			》Versioning
			考虑使用git对脚本进行版本控制
			》Testing
			检查并测试脚本。
	③	检查和测试脚本
		在开发过程中，需要检查和检查脚本，确保正确使用命令和说明。可以使用 ShellCheck 程序做到这一点，可以在本地下载并安装它，也可通过shellcheck.net使用在线版本。
		另外，考虑使用 shfmt 格式化脚本，它会自动修复shellcheck 稍后报告的问题。
		此外，在将脚本放到仓库之前，考虑使用bats对其进行测试。bats【https://github.com/sstephenson/bats】是 Bash Automated Testing System 的缩写，允许使用测试用例的特殊语法将测试文件定义为bash脚本。
		每个测试用例指示一个带有描述的bash函数，通常会调用这些脚本作为 CI 管道的一部分，如作为Github操作【action】。
	④	端到端示例：Github 用户信息脚本
		示例脚本应该采用 Github 用户句柄并打印除一条消息，其中包含用户加入的年份机器完整信息。如：
			#! /usr/bin/env bash

			set -o errexit
			set -o errtrace
			set -o nounset
			set -o pipefail

			### Command line parameter:
			targetuser="${1:-dimple-wmj}"						# 提供一个默认值，以便在用户未提供时使用

			### Check if our dependencies are met:
			if ! [ -x "$(command -v jq)"]; then
				echo "jq is not installed" >&2
				exit 1
			fi

			### Main:
			githubapi="https:/api.github.com/users/"
			tmpuserdump="tmp/ghuserdump_$targetuser.json"

			result=$(curl -s $githubapi$targetuser)				# 使用 curl 访问 Github API 下载用户信息【JSON格式文件】
			echo $result > $tmpuserdump							# 将用户信息保存到临时文件

			name=$(jq .name $tmpuserdump -r)					# 使用 jq 提取需要的字段
			created_at=$(jq .created_at $tmpuserdump -r)		# created_at 字段的值类似于 2009-02-07T16:07:32Z

			joinyear=$(echo $created_at | cut -f1 -d"-")		# 使用 cut 从 JSON文件中的created_at字段中提取年份
			echo $name joined Github in $joinyear				
		虽然这个脚本看起来不错并且在大多数情况下都可以工作，但总有一些地方可以改进，例如使脚本更加健壮并提供可操作的错误消息。 
		在这种情况下，考虑使用 bashing【https://github.com/xsc/bashing】、rerun【https://github.com/rerun/rerun】或 rr【https://taarr.com/】 等框架来提高模块化性。
5、补充
	》Shell Scripts
		Shell Style Guide【https://google.github.io/styleguide/shellguide.html】
		Bash Best Practices【https://bertvv.github.io/cheat-sheets/Bash.html】
		Bash Scripting Cheatsheet【https://bertvv.github.io/cheat-sheets/Bash.html】


Access Control
1、Basic
	①	资源和所有权
		用户	启动进程和拥有文件。进程是内核加载到主内存并运行的程序（可执行文件）。
		文件	有所有者；默认，创建该文件的用户拥有该文件
		进程	使用文件进行通信和持久化。用户也可间接使用文件，但他们需要通过进程来这样做。
	②	沙箱【sandboxing】
		在谈论资源访问时，经常会遇到的一个术语是沙箱。沙箱是一个定义模糊的术语，可以指一系列不同的方法，从监狱【jails】到容器再到虚拟机，可以在内核或用户空间中进行管理。
		通常有一些东西在沙箱中运行——通常是一些应用程序，并且监督机制在沙箱进程和托管环境之间强制执行一定程度的隔离。
	③	访问控制类型
		访问控制的一方面是访问本身的性质。用户或进程是否直接访问资源。或者也许有一套明确的规则，规定进程在什么情况下可以访问哪种资源（文件或系统调用）。或者甚至可能记录访问本身。
		在Linux环境中，两个最重要的是：
			自主访问控制【DAC】	根据用户的身份限制对资源的访问。它是任意的，因为具有某些权限的用户将它们传递给其他用户。
			强制访问控制		基于表示安全级别的分层模型。用户被分配许可级别，资源被分配安全标签。用户只能访问等于（或低于）自己权限级别对应的资源。
								在强制访问控制模型中，管理员严格且排他地控制访问，设置所有权限。即，用户无法自己设置权限，即使他们拥有资源。
		Linux传统上有一种要么全由要么全无的态度——要么是有权改变一切的超级用户，要么是访问权限有限的普通用户。为了稍微限定以下Linux中【全有或全无的态度】：大多数Linux系统中的默认设置允许【其他人】对几乎每个文件和可执行文件进行读取访问。
		SELinux 可能是最著名的 Linux 强制访问控制实现。 它是为了满足政府机构的高安全要求而开发的，并且通常在这些环境中使用，因为可用性受到严格的规则的影响。 强制访问控制的另一个选项是 AppArmor，自 2.6.36 版本起就包含在 Linux 内核中，并且在 Ubuntu 系列 Linux 发行版中相当流行。
2、用户
	在 Linux 中，经常从目的或预期用途的角度区分两种类型的用户帐户：
	①	系统用户	通常，程序（有时称为守护程序）使用这些类型的帐户来运行后台进程。这些程序提供的服务可以是系统的一部分，如网络【sshd】，也可以是应用程序层【如mysql】。
	②	常规用户	通过shell交互使用Linux的人类用户。
	Linux 通过 UID 来识别用户，属于一个或多个组的用户通过组ID（GID）来识别。不同的Linux发行版有自己的方式来决定如何管理UID范围。如支持systemd的发行版具有以下约定：
		UID 0	 					root
		UID 1 ~ 999					为系统用户保留
		UID 65534					nobody
		UID 1000 ~ 65533
			65536 ~ 4294967294		常规用户
	①	本地用户管理
		实现本地用户管理的四个文件是：
			/etc/passwd				用户数据库
			/etc/group				组数据库
			/etc/shadow				用户密码
			/etc/gshadow			组密码
		/etc/passwd 用于跟踪普通用户的用户名、UID、组成员身份和其他数据【如主目录、登录shell等】。
		》说明
			root:x:0:0:root:/root:/bin/bash
			①	root		用户名【不得超过32个字符】
			②	x			用户的密码，x 表示（加密的）密码存储在 /etc/shadow 中
			③	0			UID。注意，Linux 保留 1000 以下的 UID 供系统使用。
			④	0			用户主组（GID），见 /etc/group
			⑤	root		用户信息【全名或联系信息，如电话号码】。通常也称为GECOS字段【注意，不适用GECOS格式，而是字段本身通常有能够与与账号关联的信息】。
			⑥	/root		用户家目录
			⑦	/bin/bash	登录 shell。要防止交互式登录，请使用 /sbin/nologin
		由于历史原因，密码存储在 /etc/shadow 文件中。虽然每个用户都可以读取 /etc/passwd ，但通常需要root权限才能读取 /etc/shadow 。
		使用 useradd 命令新建用户。
		》useradd 使用说明
		用法：useradd [选项] 登录名
		      useradd -D
		      useradd -D [选项]
		
		选项：
		      --badname                 do not check for bad names
		  -b, --base-dir BASE_DIR       新账户的主目录的基目录
		      --btrfs-subvolume-home    use BTRFS subvolume for home directory
		  -c, --comment COMMENT         新账户的 GECOS 字段
		  -d, --home-dir HOME_DIR       新账户的主目录
		  -D, --defaults                显示或更改默认的 useradd 配置
		  -e, --expiredate EXPIRE_DATE  新账户的过期日期
		  -f, --inactive INACTIVE       新账户的密码不活动期
		  -g, --gid GROUP               新账户主组的名称或 ID
		  -G, --groups GROUPS           新账户的附加组列表
		  -h, --help                    显示此帮助信息并退出
		  -k, --skel SKEL_DIR           使用此目录作为骨架目录
		  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值
		  -l, --no-log-init             不要将此用户添加到最近登录和登录失败数据库
		  -m, --create-home             创建用户的主目录
		  -M, --no-create-home          不创建用户的主目录
		  -N, --no-user-group           不创建同名的组
		  -o, --non-unique              允许使用重复的 UID 创建用户
		  -p, --password PASSWORD       加密后的新账户密码
		  -r, --system                  创建一个系统账户
		  -R, --root CHROOT_DIR         chroot 到的目录
		  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files
		  -s, --shell SHELL             新账户的登录 shell
		  -u, --uid UID                 新账户的用户 ID
		  -U, --user-group              创建与用户同名的组
		  -Z, --selinux-user SEUSER     为 SELinux 用户映射使用指定 SEUSER
		除了用户之外，Linux还有组的概念，组在某种意义上只是一个或多个用户的集合。任何常规用户都属于一个默认组，但也可以是其他组的成员。可以通过 /etc/group 文件找到有关组和映射的信息。
	②	集中用户管理
		如果必须管理多台机器或服务器，本地用户管理很快就会过时。这是需要一种集中的方式来可以在本地应用于一台特定计算机的用户。有如下几种方式：
		Ⅰ	基于目录
			轻量级目录访问协议（LDAP）是一套已有数十年历史的协议，现已有IFTF正式化，它定义了如何通过互联网协议（IP）访问和维护分布式目录。
		Ⅱ	通过网络
			可以使用Kerberos通过网络方式对用户进行身份验证
		Ⅲ	使用配置管理系统
			这些系统（包括 Ansible、Chef、Puppet 或 SaltStack）可用于跨机器一致地创建用户。
3、权限
	①	文件权限
		文件权限是Linux资源访问概念的核心，Linux中的一切或多或少都是文件【一切皆文件】。权限分为三种类型或范围【从窄到宽】：
		Ⅰ	用户	文件所有者
		Ⅱ	组		有一个或多个成员
		Ⅲ	其他人	
		有三种类型的访问：
		Ⅰ	读（r）		对于普通文件，允许用户查看文件的内容。对于目录，允许用户查看目录中文件的名称。
		Ⅱ	写（w）		对于普通文件，允许用户修改或删除文件。对于目录，允许用户创建，重命名和删除目录中的文件。
		Ⅲ	执行（x）	对于普通文件，如果用户也具有该文件的读权限，则允许用户执行该文件。对于目录，允许用户访问目录中的文件信息，有效地允许他们进入该目录（cd）或列出其内容（ls）。
		其他文件访问位【access bits】
		s				应用于可执行文件的 setuid/setgid 权限。运行它的用户继承文件所有者或所属组的有效权限。
		t				粘滞位【sticky bit】。仅与目录有关。如果设置，它将阻止非root用户删除其中的文件（除非该用户拥有该目录/文件）
		Linux中还可以通过 chattr（更改属性）命令进行特殊设置。
		》文件权限说明【ls -al】
			-rw-r--r--. 1 miggi miggi   390 12月  5 18:34 Leanring_Modern_linux
			①	文件模式【file mode】
				Ⅰ	文件类型【-】
				Ⅱ	文件所有者权限【rw-】
				Ⅲ	文件所属组权限【r--】
				Ⅳ	其他人的权限【r--】
			②	硬链接数【1】
			③	文件所有者【miggi】
			④	文件所属组【miggi】
			⑤	文件大小（bytes）【390】
			⑥	上次修改时间戳【12月  5 18:34】
			⑦	文件名
		》文件类型
			-			常规文件
			b			块特殊文件
			c			字符特殊文件
			C			高性能（连续数据）文件
			d			目录
			l			符号连接
			p			命名管道（使用 mkfifo 创建）
			s			套接字文件
			？			其他（未知）文件类型
		》文件权限表示方式：
			r（4）、w（2）、x（1）
	②	进程权限
		在运行时权限上下文中存在不同的相关用户ID（credenti(7) manual page【https://man7.org/linux/man-pages/man7/credentials.7.html】）：
		Ⅰ	真实UID【Real UID】
			真实UID是启动该进程的用户的UID。它代表人类用户的进程所有权。进程本身可通过 getuid(2) 获取其真实的UID，并且可以使用 stat -c "%u %g" /proc/$pid/ 进行查询。
			如当普通用户【如，miggi】执行【passwd】命令时。通过【stat -c "%u %U %g" /proc/$pid/】会发现运行passwd的真实UID是0【root】。
		Ⅱ	有效UID【Effective UID】
			Linux内核使用有效UID来确定进程访问消息队列等共享资源时所拥有的权限。
			在传统的 UNIX 系统上，它们还用于文件访问。 然而，Linux 之前使用专用的文件系统 UID 来获取文件访问权限。出于兼容性原因，仍支持此功能。进程可以通过 geteuid(2) 获取其有效 UID。
		Ⅲ	已保存的设置用户ID【Saved set-user-ID】
			保存的设置用户ID用于 suid 情况，其中进程可以通过在真实UID和保存的设置用户ID之间切换其有效UID来获取特权。
			如，为了允许进程使用某些网络端口，它需要提升权限（如，以root身份运行）。进程可通过 getresuid(2) 获取其保存的设置用户ID。
		Ⅳ	文件系统 UID【Filesystem UID】
			这些特定于Linux的ID用于确定文件访问权限。最初引入此UID是为了支持文件服务器代表普通用户进行操作，同时将进程与所述用户的信号隔离的用例。
			程序通常不会直接操作这个UID。内核会跟踪有效UID何时更改，并自动更改文件系统UID。这意味着文件系统UID通常与有效UID相同，但可以通过 setfsuid(2)进行更改。
			注意，从技术上讲，自内核v2.0起不再需要此UID，但出于兼容性考虑，仍受支持。
		最初，当通过 fork(2) 创建子进程时，它会继承其父进程UID的副本，并且在execve(2) 系统调用期间，会保留进程的真实UID，而有效UID和保存的设置用户ID可能会改变。
		如，当运行passwd时，有效UID是您的UID【如1000】。现在，passwd启用了suid设置，这意味着当运行它时，有效UID时0【root】。还有其他方法可以影响有效UID，如使用chroot和其他沙箱技术。
		POSIX 线程【https://en.wikipedia.org/wiki/Pthreads】要求进程中的所有线程都共享凭据。然而，在内核级别，Linux为每个线程维护单独的用户组凭据。
		除了文件访问权限之外，内核还将进程UID用于其他用途，如：
			①	建立发送信号的权限【如，确定当对某个进程ID执行 kill -9 时会发生什么】
			②	调度和优先级的权限处理【如，nice】
			③	检查资源限制
		虽然在 suid 的背景下使用有效的 UID 进行推理可能很简单，但一旦功能发挥作用，它可能会更具挑战性。
4、高级权限管理
	①	功能【Capabilities】
		在Linux中，与UNIX系统中的传统情况一样，root用户在运行进程时没有任何限制。换句话说，内核只区分两种情况：
		Ⅰ	特权进程，绕过内核权限检查，有效UID为0（root）
		Ⅱ	非特权进程，具有非零有效UID，内核对其进行权限检查
		随着内核v2.2中功能系统调用的引入，这种二进制世界观发生了变化：传统上与root相关的特权现在被分解为可以在每个线程级别上独立分配的不同单元。
		实际上，这个想法是正常进程的能力为零。可以为可执行文件（二进制文件和shell脚本）以及进程分配功能，以逐步添加执行任务所需的权限。
		现在，注意：功能通常仅与系统级任务相关。即大多数时候，不一定依赖它们。一些更广泛使用的功能如下：
			功能【Capability】			语义学【Semantics】
			CAP_CHOWN					允许用户对文件的UID/GID进行任意更改
			CAP_KILL					允许向属于其他用户的进程发送信号
			CAP_SETUID					允许更改UID
			CAP_SETPCAP					允许设置正在运行的进程的功能
			CAP_NET_ADMIN				允许各种与网络相关的操作【如，接口配置】
			CAP_NET_RAW					允许使用RAW和PACKET套接字
			CAP_SYS_CHROOT				允许调用chroot
			CAP_SYS_ADMIN				允许系统管理操作，包括挂载文件系统
			CAP_SYS_PTRACE				允许使用 strace 调试进程
			CAP_SYS_MODULE				允许加载内核模块
		查看系统所有功能概览：
			# capsh --print
			Current: =ep
			Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore
			Ambient set =
			Current IAB: 
			Securebits: 00/0x0/1'b0 (no-new-privs=0)
			 secure-noroot: no (unlocked)
			 secure-no-suid-fixup: no (unlocked)
			 secure-keep-caps: no (unlocked)
			 secure-no-ambient-raise: no (unlocked)
			uid=0(root) euid=0(root)
			gid=0(root)
			groups=0(root)
			Guessed mode: UNCERTAIN (0)
		查看当前进程【shell】的所有功能概览：
			# grep Cap /proc/$$/status
			CapInh: 0000000000000000
			CapPrm: 000001ffffffffff
			CapEff: 000001ffffffffff
			CapBnd: 000001ffffffffff
			CapAmb: 0000000000000000
		可以使用 getcap 和 setcap 以细粒度的方式（即基于每个文件）管理功能。
		功能有助于从“全有或全无”的方法过渡到基于文件的更细粒度的权限。
	②	seccomp Profiles
		安全计算模式【secure computing mode（seccomp）】是自2005年起提供的Linux内核功能。这种沙箱技术背后的基本思想是，使用名为 seccomp(2) 的专用系统调用，可以限制进程可以使用的系统调用。
		可能会发现直接管理 seccomp 很不方便，但有一些方法可以轻松使用它。如，在容器环境中，Docker 和 Kubernetes 都支持 seccomp。
	③	访问控制列表
		借助于访问控制列表（ACLs），在Linux中拥有灵活的权限机制。ACL解决了传统权限的缺陷，因为它们允许向用户或不在用户组列表中的组授予权限。
		可以使用 grep -i acl /boot/config* 来检查发行版是否支持 ACL 【输出中包含 POSIX_ACL=Y】。为了对文件系统使用 ACL，必须在挂载时使用 acl 选项启用它【见 acl 的文档参考】。
5、良好的实践
	以下是更广泛的访问控制背景下的一些安全“良好实践”。 其中一些可能更适用于专业环境。
	①	最少权限
		最小权限原则是指一个人或进程应该只拥有完成给定任务所需的权限。如，如果应用程序不写入文件，则它只需要读取访问权限。 在访问控制的上下文中，可以通过两种方式实践最小权限：
		》通过数字模式使用显式权限比符号模式更好
		》尽可能避免以root身份运行【优先考虑 sudo 提权】
		注意，如果正在编写应用程序，则可以使用 SELinux 策略来限制仅访问选定的文件、目录和其他功能。 相比之下，默认的 Linux 模型可能会让应用程序访问系统上打开的任何文件。
	②	避免 setuid
		利用功能【capabilities】而不是依赖 setuid【为攻击者提供了一种接管系统的好方法】
	③	审计【auditing】
		审计是指以无法篡改结果日志的方式记录操作（以及执行这些操作的人员）。然后，可以使用此只读日志来验证谁在何时做了什么。
6、扩展
	①	通用【General】
		》“A Survey of Access Control Policies”【https://www.cs.umd.edu/sites/default/files/scholarly_papers/ACrowell_1.pdf】
		》Lynis【https://cisofy.com/lynis/】，审计和合规性测试工具
	②	功能【Capabilities】
		》“Linux Capabilities in Practice”【https://blog.container-solutions.com/linux-capabilities-in-practice】
		》“Linux Capabilities: Making Them Work”【https://www.kernel.org/doc/ols/2008/ols2008v1-pages-163-172.pdf】
	③	seccomp
		》“A seccomp Overview”【https://lwn.net/Articles/656307/】
		》“Sandboxing in Linux with Zero Lines of Code”【https://blog.cloudflare.com/sandboxing-in-linux-with-zero-lines-of-code/】
	④	访问控制列表【ACLs】
		》“POSIX Access Control Lists on Linux”【https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/gruenbacher/gruenbacher_html/main.html】
		》“Access Control Lists” via ArchLinux【https://wiki.archlinux.org/title/Access_Control_Lists】
		》“An Introduction to Linux Access Control Lists (ACLs)” via Red Hat【https://www.redhat.com/sysadmin/linux-access-control-lists】


FileSystems
	“一切皆文件”的UNIX概念在Linux中依然存在，虽然这不是100%正确，但Linux中的大多数资源确实是文件。
	还有其他东西在Linux中也以文件形式公开【如设备和伪设备】—— echo "Hello modern Linux users" > /dev/pst/0 ，它将 Hello modern Linux users 打印到屏幕上。
	虽然可能不会将这些资源与文件关联，但可以使用与常规文件相同的方法和工具来访问它们。
	所有这些东西的共同点是标准化、统一的接口：打开文件、收集文件信息、写入文件等。在Linux中，文件系统提供了这种统一的接口。这个接口，再加上Linux将文件视为字节流，而不对结构有任何期望，使我们能够构建可处理各种不同文件类型的工具。
1、基础
	


Linux 概述
1、资源可见性
	秉承UNIX的优良传统，Linux默认具有全局资源视图。
	在Linux 和Unix中“一切皆文件”。在这里，认为资源是任何可以用来帮助软件执行的东西【包括硬件及其抽象（CPU和RAM、文件）、文件系统、硬盘驱动器、固态驱动器（SSD）、进程、与网络相关的东西（如设备或路由表），以及代表用户的凭据。】
	注意：并非Linux中的所有资源都是文件或通过文件接口表示。有一些系统，可以更进一步。
	Linux资源的具体示例如下：
	①	查看Linux版本信息：
	# cat /proc/version 
	Linux version 5.14.0-352.el9.x86_64 (mockbuild@x86-05.stream.rdu2.redhat.com) (gcc (GCC) 11.4.1 20230605 (Red Hat 11.4.1-2), GNU ld version 2.35.2-42.el9) #1 SMP PREEMPT_DYNAMIC Wed Aug 9 00:25:27 UTC 2023cat /proc/version
	②	查看正在使用的CPU的特定硬件信息：
	# cat /proc/cpuinfo | grep "model name"
	model name      : Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
	③	打印进程状态（有关当前进程的详细信息）并将输出限制为仅显示当前六行。
	# cat /proc/$$/status | head -n6
		Name:   bash
		Umask:  0022
		State:  S (sleeping)
		Tgid:   1034
		Ngid:   0
		Pid:    1034
	》补充：$$
		这是一个特殊变量，涉及当前进程。在shell上下文中，$$是在其中输入命令的shell的进程ID。
	在Linux中可以有多个具有相同PID的进程【不同的上下文【命名空间】中可以有多个具有相同PID的进程，如在容器化设置。
	每个进程可能认为它很特殊，具有PID 1，在更传统的设置中，它是为用户空间进程树的根保留的。
	给定资源可以有全局视图（两个用户在完全相同的位置查看文件）以及本地或虚拟化视图。Linux中的所有内容并非默认都是全局的。
	多个用户或进程并行运行的错觉的一部分是对资源的（有限的）可见性。在Linux中提供（某些受支持的）资源的本地视图是通过命名空间。
	第二个独立的维度是隔离。考虑进程隔离的一种方法是限制内存消耗，以便一个进程不会导致其他进程没有内存可用。如为应用程序提供1GB的RAM供使用。如果它使用更多，就会因为内存不足而被杀死。这提供了一定程度的保护。在Linux中，使用称为cgroups的内核功能来提供这种隔离。
	另一方面，完全隔离的环境使应用程序看起来完全独立。如虚拟机可用于提供完全隔离。
	任何Linux发行版的核心都具有内核【kernel】，提供其他所有内容所构建的API。文件、网络和可观察性这三个核心主题随处可见。
	从形式上来说，POSIX（便携式操作系统接口）是一个IEEE标准，用于定义UNIX操作系统的服务接口。动机是提供不同实现之间的可移植性。如果读到“符合POSIX标准”之类的内容，考虑一组在官方采购环境中特别相关的正式规范，而在日常使用中则不太相关。
	Linux 的构建是为了兼容 POSIX 以及 UNIX 系统 V 接口定义 (SVID)，这赋予了它老式 AT&T UNIX 系统的风格，而不是 Berkeley Software Distribution (BSD)风格系统。


hells and Scripting
1、基础
	①	终端【terminals】
	终端是提供文本用户界面的程序。即终端支持从键盘读取字符并显示在屏幕上。除了基本的面向字符的输入和输出之外，终端还支持所谓的转义序列或转义代码，用于光标和屏幕处理，并可能支持颜色。如【Ctrl H】产生退格，从而删除光标左侧的字符。
	环境变量【TERM】标识正在使用的终端仿真器，其配置可通过 infocmp 获得。
	终端的示例不仅包括 xterm、rxvt 和 Gnome terminator，还包括利用 GPU 的新一代终端，例如 Alacritty、kitty 和 warp。
	②	Shells
	shell是一个在终端内运行并充当命令解释器的程序。shell 通过流【streams】提供输入和输出处理，支持变量，有一些可以使用的内置命令，处理命令执行和状态，并且通常支持交互式使用和脚本化使用。
	shell在sh中定义，经常遇到的POSIX shell，它在脚本和可移植性的上下文中变得更加重要。最初有 Bourne shell sh，现在它通常被 bash sh取代【Bourne Again Shell】。
	可以使用 file -h /bin/sh来查看，或使用 echo $0，或 echo $SHELL 。
	# file -h /bin/sh
	/bin/sh: symbolic link to bash
	# echo $0
	-bash
	# echo $SHELL
	/bin/bash
	sh 以及其他变体还有更多实现，例如 Korn shell、ksh 和 C shell、csh。
		Ⅰ	流【Streams】
		shell 为每个进程准备了三个用于输入和输出的默认文件描述符（FD）：
			》stdin（FD 0）
			》stdout（FD 1）
			》stderr（FD 2）
		这些 FD 默认情况下分别连接到屏幕和键盘。 换句话说，除非指定其他内容，否则在 shell 中输入的命令将从键盘获取输入 (stdin)，并将其输出 (stdout) 传送到屏幕。
		如果不想使用 shell 提供的默认值（如，不希望在屏幕上输出stderr，希望将其保存到文件中），可以重定向流。
		可以使用 $FD> 和 <$FD 重定向进程的输出流，其中，$FD 是文件描述符——如，2> 表示重定向 stderr 流。注意，1> 和 > 是相同的，因为 stdout 是默认值。如果想重定向 stdout 和 stderr ，使用 &> ，当想摆脱流时，可使用 /dev/null 。如：
		①	通过重定向 stdout 和 stderr 到 /dev/null来丢弃输出：
			curl https://example.com &> /dev/null
		②	重定向输出和状态到不同的文件：
			curl https://example.com > /tmp/content.txt 2> /tmp/curl-status
		③	交互式输入并保存到文件；使用Ctrl D停止捕获并存储内容：
			cat > /tmp/interactive-input.txt
		④	使用从 stdin 读取的 tr 命令将所有单词小写
			tr < /tmp/curl-status [A-Z] [a-z]
		shell 通常可以理解一些特殊字符：
		①	&
			放置在命令末尾，在后台执行命令
		②	\
			用于在下一行继续命令，以提高长命令的可读性
		③	|
			将一个进程的标准输出与下一个进程的标准输入连接起来，允许传递数据，而不必将其存储在文件中所谓临时位置。
		Ⅱ	变量【Variables】
		在shell中经常遇到的一个术语是变量。每当不想或无法对值进行硬编码时，都可以使用变量来存储和更改值。使用案例如下：
			①	当想要处理Linux公开的配置项时【如，shell 查找 $PATH 变量中捕获的可执行文件位置】。这是一种可读取/写入变量的接口。
			②	当想要以交互式项用户查询某个值时，如在脚本上下文中。
			③	当想要通过定义一次长值来缩短输入时。
		区分两种变量
			①	环境变量
				Shell范围的设置；用 env 列出它们
			②	Shell 变量
				在当前执行的上下文中有效；在bash中用 set 列出它们。Shell变量不会被子进程继承。在bash中可使用 export 来创建环境变量。要访问一个变量的值，在其前面放一个$，当想删除一个变量时，使用 unset。
		示例：
			[root@dns-server ~]# set MY_VAR=42								定义一个shell 变量，并为其赋值
			[root@dns-server ~]# set | grep MY_VAR
			_=MY_VAR=42														_= 表示其没有导出【exported】
			[root@dns-server ~]# export MY_GLOBAL_VAR="fun with vars"		定义一个环境变量
			[root@dns-server ~]# set | grep "MY_*"							
			MY_GLOBAL_VAR='fun with vars'
			_='MY_GLOBAL_VAR=fun with vars'
			[root@dns-server ~]# env | grep "MY_*"							列出环境变量
			MY_GLOBAL_VAR=fun with vars
			[root@dns-server ~]# bash										创建一个新的shell会话——当前shell会话的子进程，不会继承其 MY_VAR shell变量
			[root@dns-server ~]# echo $MY_GLOBAL_VAR
			fun with vars
			[root@dns-server ~]# set | grep "MY_*"
			MY_GLOBAL_VAR='fun with vars'
			[root@dns-server ~]# exit
			exit
			[root@dns-server ~]# unset $MY_VAR								移除 shell 变量 MY_VAR
			[root@dns-server ~]# set | grep 'MY_*'
			MY_GLOBAL_VAR='fun with vars'
		对于任何变量，都可以使用 echo $XXX 查看相应的值，其中 XXX 是变量名称。常用shell 和 环境变量如下：
			变量			类型				描述
			EDITOR			ENV					默认情况下用于编辑文件的程序路径
			HOME			POSIX				当前用户的家目录路径
			HOSTNAME		bash shell			当前主机的主机名
			IFS				POSIX				用于分隔字段的字符列表；当shell在扩展时分割单词时使用
			PATH			POSIX				包含 shell 查找可执行程序（二进制文件或脚本）的目录列表
			PS1				ENV					shell 提示符
			PWD				ENV					当前工作目录的完整路径
			OLDPWD			bash shell			最后一个cd命令之前的目录的完整路径
			RANDOM			bash shell			0~32767之间的随机整数
			SHELL			ENV					包含当前使用的shell
			TERM			ENV					使用的终端模拟器
			UID				ENV					当前用户的UID（整数值）
			USER			ENV					当前用户
			_				bash shell			在前台执行的上一个命令的最后一个参数
			?				bash shell			退出状态码
			$				bash shell			当前进程的ID（整数值）
			0				bash shell			当前进程的进程名
		bash特定变量的完整列表【https://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html】。
		Ⅲ	退出状态
		shell 使用所谓的退出状态向调用者传达命令执行的完成情况。 一般来说，Linux 命令在终止时会返回一个状态。 这可以是正常终止或异常终止。0 退出状态表示命令已成功运行，没有任何错误，而 1 到 255 之间的非零值表示失败。
		使用 $? 查看退出状态。
		注意，管道中的退出状态管理，因为某些shell仅提供最后一个状态。可以使用$PIPESTATUS来解决此限制。
		Ⅳ 	内置命令
		shell带有许多内置命令【如，yes、echo、cat或read】（根据Linux发行版，其中一些命令可能不是内置命令，而是位于 /usr/bin 中）。可以使用help 命令来列出内置命令。注意，其他一切都是shell 外部程序。
		查找可执行文件，如：
			# which is
			# type is
		Ⅴ	任务控制
		大多数 shell 支持的一项功能称为作业控制。 默认情况下，当输入命令时，它会控制屏幕和键盘，通常称之为在前台运行。要在后台启动进程，在末尾添加 &，或者要将前台进程发送到后台，按 Ctrl Z。
		如果想保持后台进程运行，即使在退出shell后，可以在前面添加 nohup 命令。此外，对于已经在运行并且没有以nohup开头的进程，可以在事后使用disown来达到相同的效果。
	常用 shell 快捷方式
		动作				命令				注意
		光标移动到行首		Ctrl+a
		光标移动到行尾		Ctrl+e
		光标前进一个字符	Ctrl+f
		光标后退一个字符	Ctrl+b
		光标前进一个单词	Alt+f
		光标后退一个单词	Alt+b
		删除光标左侧的字符	Ctrl+h
		删除光标左侧的单词	Ctrl+w
		删除光标右边内容	Ctrl+k
		删除光标左边内容	Ctrl+u
		清屏				Ctrl+l
		取消命令			Ctrl+c
		撤销				Ctrl+_				仅bash
		搜索历史			Ctrl+r
		取消搜索			Ctrl+g
		注意：这些快捷键是在Emacs编辑模式下，如果倾向于vi，可使用 set -o vi 切换到 vi
2、友好的shell
3、终端复用器
4、脚本编写
	①	脚本基础
		除了变量、流和重定向以及常用命令之外，在脚本上下文中还有一些需要熟悉的特定内容。
		Ⅰ	高级数据类型
		虽然shell通常将所有内容都视为字符串（如果想执行一些更复杂的数字任务，可能不应该使用shell脚本），但它确实支持一些高级数据类型【如数组】：
			os=('Linux' 'macOS' 'Windows')
			echo "${os[0]}"
			numberofos="${#os[@]}"
		Ⅱ	流控制
		流程控制允许在脚本中分支（if）或重复（for和while），使执行取决于特定条件。如：
			for afile in /tmp/*; do
				echo "$afile"
			done

			for i in {1..10}; do
				echo "$i"
			done

			while true; do
				...
			done
		Ⅲ	函数
		函数允许编写更加模块化和可重用的脚本。必须在使用函数之前定义该函数【shell从上到下解释脚本】。如
			sayhi () {
				echo "Hi $1 hope you are well
			}
			sayhi "Michael"
		Ⅳ	高级 I/O
		通过 read ，可以从stdin读取用户输入，可以使用它来引发运行时输入。此外，不要使用 echo ，考虑使用 printf ，它允许对输出（包括颜色）进行细粒度控制。printf 也比 echo 更便携。如：
			read name
			printf "Hello %s" "$name"
		还有其他更高级的概念可供使用【如 signal 和 traps】。
	②	编写可移植的脚本
		如果脚本是可移植的，那么它可以在许多不同的系统上运行（shells、Linux发行版等）。
		注意，即使确定了shell的类型【如，bash】，并非所有功能在不同版本的shell中都以相同的方式工作。归根结底，归结为可以在其中测试脚本的不同环境的数量。
		Ⅰ	执行可移植脚本
			脚本实际上只是文本文件；扩展名并不重要，尽管约定使用 .sh 。有两件事可以将文本文件转换为可执行并且能够由shell运行的脚本：
			》文件需要在第一行声明解释器，使用所谓的shebang（或hashbang），写为 #! 。
			》需要给予文件执行权限【如，chmod +x】。注意最小权限原则。
		Ⅱ	骨架模板
			可作为可移植 bash shell 脚本的骨架模板如下：
				#! /usr/bin/env bash						# ①
				set -o errexit								# ②
				set -o nounset								# ③	
				set -o pipefail								# ④

				firstargument="${1:-somedefualtvalue}"		# ⑤
				echo "$firstargument"

			①	hashbang 指示希望使用 bash 来解释此脚本
			②	定义如果发生错误要停止脚本执行
			③	定义将未设置的变量视为错误【脚本不太可能默默失败】
			④	定义当管道的一部分发生故障时，整个管道应被视为发生故障【有助于避免无声故障】
			⑤	带有默认值的命令行参数示例
		Ⅲ	好习惯
			》Fail fast and loud
			避免无声失败，并快速失败；像 errexit 和 pipefail 可以做到这一点。由于八十、默认情况下往往会静默失败，因此快速失败几乎总是一个好习惯。
			》Sensitive information
			不要将任何敏感信息（如，密码）硬编码到脚本中。此类信息应在运行时通过用户输入或调用API提供。另外，注意ps会泄露程序参数等，这是泄露敏感信息的另一种方式。
			》Input sanitization
			尽可能为变量设置并提供合理的默认值，并清理从用户或其他来源收到的输入。如通过read命令提供或交互引入的启动参数，以避免由于未设置变量而导致看似无辜的 rm -rf "$PROJECTHOME/"* 擦除驱动器的情况。
			》Check dependencies
			不要假设某个工具或命令可用，除非它是内置的或知道目标环境。
			》Error handling
			当脚本失败时（问题不在于是否失败，而是何时何地），为用户提供可操作说明。
			》Documentation
			为脚本块添加注释（# Some doc），并尝试坚持80列宽以提高可读性和差异。
			》Versioning
			考虑使用git对脚本进行版本控制
			》Testing
			检查并测试脚本。
	③	检查和测试脚本
		在开发过程中，需要检查和检查脚本，确保正确使用命令和说明。可以使用 ShellCheck 程序做到这一点，可以在本地下载并安装它，也可通过shellcheck.net使用在线版本。
		另外，考虑使用 shfmt 格式化脚本，它会自动修复shellcheck 稍后报告的问题。
		此外，在将脚本放到仓库之前，考虑使用bats对其进行测试。bats【https://github.com/sstephenson/bats】是 Bash Automated Testing System 的缩写，允许使用测试用例的特殊语法将测试文件定义为bash脚本。
		每个测试用例指示一个带有描述的bash函数，通常会调用这些脚本作为 CI 管道的一部分，如作为Github操作【action】。
	④	端到端示例：Github 用户信息脚本
		示例脚本应该采用 Github 用户句柄并打印除一条消息，其中包含用户加入的年份机器完整信息。如：
			#! /usr/bin/env bash

			set -o errexit
			set -o errtrace
			set -o nounset
			set -o pipefail

			### Command line parameter:
			targetuser="${1:-dimple-wmj}"						# 提供一个默认值，以便在用户未提供时使用

			### Check if our dependencies are met:
			if ! [ -x "$(command -v jq)"]; then
				echo "jq is not installed" >&2
				exit 1
			fi

			### Main:
			githubapi="https:/api.github.com/users/"
			tmpuserdump="tmp/ghuserdump_$targetuser.json"

			result=$(curl -s $githubapi$targetuser)				# 使用 curl 访问 Github API 下载用户信息【JSON格式文件】
			echo $result > $tmpuserdump							# 将用户信息保存到临时文件

			name=$(jq .name $tmpuserdump -r)					# 使用 jq 提取需要的字段
			created_at=$(jq .created_at $tmpuserdump -r)		# created_at 字段的值类似于 2009-02-07T16:07:32Z

			joinyear=$(echo $created_at | cut -f1 -d"-")		# 使用 cut 从 JSON文件中的created_at字段中提取年份
			echo $name joined Github in $joinyear				
		虽然这个脚本看起来不错并且在大多数情况下都可以工作，但总有一些地方可以改进，例如使脚本更加健壮并提供可操作的错误消息。 
		在这种情况下，考虑使用 bashing【https://github.com/xsc/bashing】、rerun【https://github.com/rerun/rerun】或 rr【https://taarr.com/】 等框架来提高模块化性。
5、补充
	》Shell Scripts
		Shell Style Guide【https://google.github.io/styleguide/shellguide.html】
		Bash Best Practices【https://bertvv.github.io/cheat-sheets/Bash.html】
		Bash Scripting Cheatsheet【https://bertvv.github.io/cheat-sheets/Bash.html】


Access Control
1、Basic
	①	资源和所有权
		用户	启动进程和拥有文件。进程是内核加载到主内存并运行的程序（可执行文件）。
		文件	有所有者；默认，创建该文件的用户拥有该文件
		进程	使用文件进行通信和持久化。用户也可间接使用文件，但他们需要通过进程来这样做。
	②	沙箱【sandboxing】
		在谈论资源访问时，经常会遇到的一个术语是沙箱。沙箱是一个定义模糊的术语，可以指一系列不同的方法，从监狱【jails】到容器再到虚拟机，可以在内核或用户空间中进行管理。
		通常有一些东西在沙箱中运行——通常是一些应用程序，并且监督机制在沙箱进程和托管环境之间强制执行一定程度的隔离。
	③	访问控制类型
		访问控制的一方面是访问本身的性质。用户或进程是否直接访问资源。或者也许有一套明确的规则，规定进程在什么情况下可以访问哪种资源（文件或系统调用）。或者甚至可能记录访问本身。
		在Linux环境中，两个最重要的是：
			自主访问控制【DAC】	根据用户的身份限制对资源的访问。它是任意的，因为具有某些权限的用户将它们传递给其他用户。
			强制访问控制		基于表示安全级别的分层模型。用户被分配许可级别，资源被分配安全标签。用户只能访问等于（或低于）自己权限级别对应的资源。
								在强制访问控制模型中，管理员严格且排他地控制访问，设置所有权限。即，用户无法自己设置权限，即使他们拥有资源。
		Linux传统上有一种要么全由要么全无的态度——要么是有权改变一切的超级用户，要么是访问权限有限的普通用户。为了稍微限定以下Linux中【全有或全无的态度】：大多数Linux系统中的默认设置允许【其他人】对几乎每个文件和可执行文件进行读取访问。
		SELinux 可能是最著名的 Linux 强制访问控制实现。 它是为了满足政府机构的高安全要求而开发的，并且通常在这些环境中使用，因为可用性受到严格的规则的影响。 强制访问控制的另一个选项是 AppArmor，自 2.6.36 版本起就包含在 Linux 内核中，并且在 Ubuntu 系列 Linux 发行版中相当流行。
2、用户
	在 Linux 中，经常从目的或预期用途的角度区分两种类型的用户帐户：
	①	系统用户	通常，程序（有时称为守护程序）使用这些类型的帐户来运行后台进程。这些程序提供的服务可以是系统的一部分，如网络【sshd】，也可以是应用程序层【如mysql】。
	②	常规用户	通过shell交互使用Linux的人类用户。
	Linux 通过 UID 来识别用户，属于一个或多个组的用户通过组ID（GID）来识别。不同的Linux发行版有自己的方式来决定如何管理UID范围。如支持systemd的发行版具有以下约定：
		UID 0	 					root
		UID 1 ~ 999					为系统用户保留
		UID 65534					nobody
		UID 1000 ~ 65533
			65536 ~ 4294967294		常规用户
	①	本地用户管理
		实现本地用户管理的四个文件是：
			/etc/passwd				用户数据库
			/etc/group				组数据库
			/etc/shadow				用户密码
			/etc/gshadow			组密码
		/etc/passwd 用于跟踪普通用户的用户名、UID、组成员身份和其他数据【如主目录、登录shell等】。
		》说明
			root:x:0:0:root:/root:/bin/bash
			①	root		用户名【不得超过32个字符】
			②	x			用户的密码，x 表示（加密的）密码存储在 /etc/shadow 中
			③	0			UID。注意，Linux 保留 1000 以下的 UID 供系统使用。
			④	0			用户主组（GID），见 /etc/group
			⑤	root		用户信息【全名或联系信息，如电话号码】。通常也称为GECOS字段【注意，不适用GECOS格式，而是字段本身通常有能够与与账号关联的信息】。
			⑥	/root		用户家目录
			⑦	/bin/bash	登录 shell。要防止交互式登录，请使用 /sbin/nologin
		由于历史原因，密码存储在 /etc/shadow 文件中。虽然每个用户都可以读取 /etc/passwd ，但通常需要root权限才能读取 /etc/shadow 。
		使用 useradd 命令新建用户。
		》useradd 使用说明
		用法：useradd [选项] 登录名
		      useradd -D
		      useradd -D [选项]
		
		选项：
		      --badname                 do not check for bad names
		  -b, --base-dir BASE_DIR       新账户的主目录的基目录
		      --btrfs-subvolume-home    use BTRFS subvolume for home directory
		  -c, --comment COMMENT         新账户的 GECOS 字段
		  -d, --home-dir HOME_DIR       新账户的主目录
		  -D, --defaults                显示或更改默认的 useradd 配置
		  -e, --expiredate EXPIRE_DATE  新账户的过期日期
		  -f, --inactive INACTIVE       新账户的密码不活动期
		  -g, --gid GROUP               新账户主组的名称或 ID
		  -G, --groups GROUPS           新账户的附加组列表
		  -h, --help                    显示此帮助信息并退出
		  -k, --skel SKEL_DIR           使用此目录作为骨架目录
		  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值
		  -l, --no-log-init             不要将此用户添加到最近登录和登录失败数据库
		  -m, --create-home             创建用户的主目录
		  -M, --no-create-home          不创建用户的主目录
		  -N, --no-user-group           不创建同名的组
		  -o, --non-unique              允许使用重复的 UID 创建用户
		  -p, --password PASSWORD       加密后的新账户密码
		  -r, --system                  创建一个系统账户
		  -R, --root CHROOT_DIR         chroot 到的目录
		  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files
		  -s, --shell SHELL             新账户的登录 shell
		  -u, --uid UID                 新账户的用户 ID
		  -U, --user-group              创建与用户同名的组
		  -Z, --selinux-user SEUSER     为 SELinux 用户映射使用指定 SEUSER
		除了用户之外，Linux还有组的概念，组在某种意义上只是一个或多个用户的集合。任何常规用户都属于一个默认组，但也可以是其他组的成员。可以通过 /etc/group 文件找到有关组和映射的信息。
	②	集中用户管理
		如果必须管理多台机器或服务器，本地用户管理很快就会过时。这是需要一种集中的方式来可以在本地应用于一台特定计算机的用户。有如下几种方式：
		Ⅰ	基于目录
			轻量级目录访问协议（LDAP）是一套已有数十年历史的协议，现已有IFTF正式化，它定义了如何通过互联网协议（IP）访问和维护分布式目录。
		Ⅱ	通过网络
			可以使用Kerberos通过网络方式对用户进行身份验证
		Ⅲ	使用配置管理系统
			这些系统（包括 Ansible、Chef、Puppet 或 SaltStack）可用于跨机器一致地创建用户。
3、权限
	①	文件权限
		文件权限是Linux资源访问概念的核心，Linux中的一切或多或少都是文件【一切皆文件】。权限分为三种类型或范围【从窄到宽】：
		Ⅰ	用户	文件所有者
		Ⅱ	组		有一个或多个成员
		Ⅲ	其他人	
		有三种类型的访问：
		Ⅰ	读（r）		对于普通文件，允许用户查看文件的内容。对于目录，允许用户查看目录中文件的名称。
		Ⅱ	写（w）		对于普通文件，允许用户修改或删除文件。对于目录，允许用户创建，重命名和删除目录中的文件。
		Ⅲ	执行（x）	对于普通文件，如果用户也具有该文件的读权限，则允许用户执行该文件。对于目录，允许用户访问目录中的文件信息，有效地允许他们进入该目录（cd）或列出其内容（ls）。
		其他文件访问位【access bits】
		s				应用于可执行文件的 setuid/setgid 权限。运行它的用户继承文件所有者或所属组的有效权限。
		t				粘滞位【sticky bit】。仅与目录有关。如果设置，它将阻止非root用户删除其中的文件（除非该用户拥有该目录/文件）
		Linux中还可以通过 chattr（更改属性）命令进行特殊设置。
		》文件权限说明【ls -al】
			-rw-r--r--. 1 miggi miggi   390 12月  5 18:34 Leanring_Modern_linux
			①	文件模式【file mode】
				Ⅰ	文件类型【-】
				Ⅱ	文件所有者权限【rw-】
				Ⅲ	文件所属组权限【r--】
				Ⅳ	其他人的权限【r--】
			②	硬链接数【1】
			③	文件所有者【miggi】
			④	文件所属组【miggi】
			⑤	文件大小（bytes）【390】
			⑥	上次修改时间戳【12月  5 18:34】
			⑦	文件名
		》文件类型
			-			常规文件
			b			块特殊文件
			c			字符特殊文件
			C			高性能（连续数据）文件
			d			目录
			l			符号连接
			p			命名管道（使用 mkfifo 创建）
			s			套接字文件
			？			其他（未知）文件类型
		》文件权限表示方式：
			r（4）、w（2）、x（1）
	②	进程权限
		在运行时权限上下文中存在不同的相关用户ID（credenti(7) manual page【https://man7.org/linux/man-pages/man7/credentials.7.html】）：
		Ⅰ	真实UID【Real UID】
			真实UID是启动该进程的用户的UID。它代表人类用户的进程所有权。进程本身可通过 getuid(2) 获取其真实的UID，并且可以使用 stat -c "%u %g" /proc/$pid/ 进行查询。
			如当普通用户【如，miggi】执行【passwd】命令时。通过【stat -c "%u %U %g" /proc/$pid/】会发现运行passwd的真实UID是0【root】。
		Ⅱ	有效UID【Effective UID】
			Linux内核使用有效UID来确定进程访问消息队列等共享资源时所拥有的权限。
			在传统的 UNIX 系统上，它们还用于文件访问。 然而，Linux 之前使用专用的文件系统 UID 来获取文件访问权限。出于兼容性原因，仍支持此功能。进程可以通过 geteuid(2) 获取其有效 UID。
		Ⅲ	已保存的设置用户ID【Saved set-user-ID】
			保存的设置用户ID用于 suid 情况，其中进程可以通过在真实UID和保存的设置用户ID之间切换其有效UID来获取特权。
			如，为了允许进程使用某些网络端口，它需要提升权限（如，以root身份运行）。进程可通过 getresuid(2) 获取其保存的设置用户ID。
		Ⅳ	文件系统 UID【Filesystem UID】
			这些特定于Linux的ID用于确定文件访问权限。最初引入此UID是为了支持文件服务器代表普通用户进行操作，同时将进程与所述用户的信号隔离的用例。
			程序通常不会直接操作这个UID。内核会跟踪有效UID何时更改，并自动更改文件系统UID。这意味着文件系统UID通常与有效UID相同，但可以通过 setfsuid(2)进行更改。
			注意，从技术上讲，自内核v2.0起不再需要此UID，但出于兼容性考虑，仍受支持。
		最初，当通过 fork(2) 创建子进程时，它会继承其父进程UID的副本，并且在execve(2) 系统调用期间，会保留进程的真实UID，而有效UID和保存的设置用户ID可能会改变。
		如，当运行passwd时，有效UID是您的UID【如1000】。现在，passwd启用了suid设置，这意味着当运行它时，有效UID时0【root】。还有其他方法可以影响有效UID，如使用chroot和其他沙箱技术。
		POSIX 线程【https://en.wikipedia.org/wiki/Pthreads】要求进程中的所有线程都共享凭据。然而，在内核级别，Linux为每个线程维护单独的用户组凭据。
		除了文件访问权限之外，内核还将进程UID用于其他用途，如：
			①	建立发送信号的权限【如，确定当对某个进程ID执行 kill -9 时会发生什么】
			②	调度和优先级的权限处理【如，nice】
			③	检查资源限制
		虽然在 suid 的背景下使用有效的 UID 进行推理可能很简单，但一旦功能发挥作用，它可能会更具挑战性。
4、高级权限管理
	①	功能【Capabilities】
		在Linux中，与UNIX系统中的传统情况一样，root用户在运行进程时没有任何限制。换句话说，内核只区分两种情况：
		Ⅰ	特权进程，绕过内核权限检查，有效UID为0（root）
		Ⅱ	非特权进程，具有非零有效UID，内核对其进行权限检查
		随着内核v2.2中功能系统调用的引入，这种二进制世界观发生了变化：传统上与root相关的特权现在被分解为可以在每个线程级别上独立分配的不同单元。
		实际上，这个想法是正常进程的能力为零。可以为可执行文件（二进制文件和shell脚本）以及进程分配功能，以逐步添加执行任务所需的权限。
		现在，注意：功能通常仅与系统级任务相关。即大多数时候，不一定依赖它们。一些更广泛使用的功能如下：
			功能【Capability】			语义学【Semantics】
			CAP_CHOWN					允许用户对文件的UID/GID进行任意更改
			CAP_KILL					允许向属于其他用户的进程发送信号
			CAP_SETUID					允许更改UID
			CAP_SETPCAP					允许设置正在运行的进程的功能
			CAP_NET_ADMIN				允许各种与网络相关的操作【如，接口配置】
			CAP_NET_RAW					允许使用RAW和PACKET套接字
			CAP_SYS_CHROOT				允许调用chroot
			CAP_SYS_ADMIN				允许系统管理操作，包括挂载文件系统
			CAP_SYS_PTRACE				允许使用 strace 调试进程
			CAP_SYS_MODULE				允许加载内核模块
		查看系统所有功能概览：
			# capsh --print
			Current: =ep
			Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore
			Ambient set =
			Current IAB: 
			Securebits: 00/0x0/1'b0 (no-new-privs=0)
			 secure-noroot: no (unlocked)
			 secure-no-suid-fixup: no (unlocked)
			 secure-keep-caps: no (unlocked)
			 secure-no-ambient-raise: no (unlocked)
			uid=0(root) euid=0(root)
			gid=0(root)
			groups=0(root)
			Guessed mode: UNCERTAIN (0)
		查看当前进程【shell】的所有功能概览：
			# grep Cap /proc/$$/status
			CapInh: 0000000000000000
			CapPrm: 000001ffffffffff
			CapEff: 000001ffffffffff
			CapBnd: 000001ffffffffff
			CapAmb: 0000000000000000
		可以使用 getcap 和 setcap 以细粒度的方式（即基于每个文件）管理功能。
		功能有助于从“全有或全无”的方法过渡到基于文件的更细粒度的权限。
	②	seccomp Profiles
		安全计算模式【secure computing mode（seccomp）】是自2005年起提供的Linux内核功能。这种沙箱技术背后的基本思想是，使用名为 seccomp(2) 的专用系统调用，可以限制进程可以使用的系统调用。
		可能会发现直接管理 seccomp 很不方便，但有一些方法可以轻松使用它。如，在容器环境中，Docker 和 Kubernetes 都支持 seccomp。
	③	访问控制列表
		借助于访问控制列表（ACLs），在Linux中拥有灵活的权限机制。ACL解决了传统权限的缺陷，因为它们允许向用户或不在用户组列表中的组授予权限。
		可以使用 grep -i acl /boot/config* 来检查发行版是否支持 ACL 【输出中包含 POSIX_ACL=Y】。为了对文件系统使用 ACL，必须在挂载时使用 acl 选项启用它【见 acl 的文档参考】。
5、良好的实践
	以下是更广泛的访问控制背景下的一些安全“良好实践”。 其中一些可能更适用于专业环境。
	①	最少权限
		最小权限原则是指一个人或进程应该只拥有完成给定任务所需的权限。如，如果应用程序不写入文件，则它只需要读取访问权限。 在访问控制的上下文中，可以通过两种方式实践最小权限：
		》通过数字模式使用显式权限比符号模式更好
		》尽可能避免以root身份运行【优先考虑 sudo 提权】
		注意，如果正在编写应用程序，则可以使用 SELinux 策略来限制仅访问选定的文件、目录和其他功能。 相比之下，默认的 Linux 模型可能会让应用程序访问系统上打开的任何文件。
	②	避免 setuid
		利用功能【capabilities】而不是依赖 setuid【为攻击者提供了一种接管系统的好方法】
	③	审计【auditing】
		审计是指以无法篡改结果日志的方式记录操作（以及执行这些操作的人员）。然后，可以使用此只读日志来验证谁在何时做了什么。
6、扩展
	①	通用【General】
		》“A Survey of Access Control Policies”【https://www.cs.umd.edu/sites/default/files/scholarly_papers/ACrowell_1.pdf】
		》Lynis【https://cisofy.com/lynis/】，审计和合规性测试工具
	②	功能【Capabilities】
		》“Linux Capabilities in Practice”【https://blog.container-solutions.com/linux-capabilities-in-practice】
		》“Linux Capabilities: Making Them Work”【https://www.kernel.org/doc/ols/2008/ols2008v1-pages-163-172.pdf】
	③	seccomp
		》“A seccomp Overview”【https://lwn.net/Articles/656307/】
		》“Sandboxing in Linux with Zero Lines of Code”【https://blog.cloudflare.com/sandboxing-in-linux-with-zero-lines-of-code/】
	④	访问控制列表【ACLs】
		》“POSIX Access Control Lists on Linux”【https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/gruenbacher/gruenbacher_html/main.html】
		》“Access Control Lists” via ArchLinux【https://wiki.archlinux.org/title/Access_Control_Lists】
		》“An Introduction to Linux Access Control Lists (ACLs)” via Red Hat【https://www.redhat.com/sysadmin/linux-access-control-lists】


FileSystems
	“一切皆文件”的UNIX概念在Linux中依然存在，虽然这不是100%正确，但Linux中的大多数资源确实是文件。
	还有其他东西在Linux中也以文件形式公开【如设备和伪设备】—— echo "Hello modern Linux users" > /dev/pst/0 ，它将 Hello modern Linux users 打印到屏幕上。
	虽然可能不会将这些资源与文件关联，但可以使用与常规文件相同的方法和工具来访问它们。
	所有这些东西的共同点是标准化、统一的接口：打开文件、收集文件信息、写入文件等。在Linux中，文件系统提供了这种统一的接口。这个接口，再加上Linux将文件视为字节流，而不对结构有任何期望，使我们能够构建可处理各种不同文件类型的工具。
1、基础
	一般来说，文件系统是在内核【kernel】中实现的。虽然出于性能原因，文件系统通常在内核空间中实现，但也可选择在用户空间中实现它们。
	见“Filesystem in Userspace（FUSE）documentation”【https://www.kernel.org/doc/html/latest/filesystems/fuse.html】和 libfuse project site【https://github.com/libfuse/】。
	术语定义:
		①	Drive
			物理（physical）块设备，如硬盘驱动器（HDD）或固态驱动器（SSD）。在虚拟机环境中，还可以模拟驱动器——如，/dev/sda（SCSI设备）或/dev/sdb（SATA设备）或/dev/hda（IDE设备）
		②	Partition
			可以在逻辑上将驱动器划分为分区，即一组存储扇区。如在HDD上创建两个分区，然后将显示为 /dev/sdb1 和 /dev/sdb2 。
		③	Volume
			卷有点类似于分区，但它更灵活，并且也针对特定文件系统进行格式化。
		④	Super block
			格式化后，文件系统在开头有一个特殊的部分，用于捕获文件系统的元数据。这包括文件系统类型、块、状态以及每个块有多少inode等内容。
		⑤	Inodes
			在文件系统中，inodes存储有关文件的元数据【如，大小、所有者、路径、日期和权限】。但，inodes不存储文件名和实际数据。它保存在目录中，目录实际上只是一种特殊的常规文件，将inodes映射到文件名。
	查看系统中存在哪些驱动器、分区和卷：
		# lsblk --exclude 7											# 列出所有块设备，但排除伪（循环）设备
		NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
		sda           8:0    0    20G  0 disk						# 磁盘驱动器为 sda，总量为20G
		├─sda1        8:1    0     1G  0 part /boot					# 这里有两个分区，sda1 是 启动分区
		└─sda2        8:2    0    19G  0 part
		  ├─cs-root 253:0    0    17G  0 lvm  /						# 第二个分区【sda2】，包含两个卷
		  └─cs-swap 253:1    0     2G  0 lvm  [SWAP]
		sr0          11:0    1 112.8M  0 rom
		sr1          11:1    1   9.1G  0 rom
	查看正在使用的文件系统：
		# findmnt -D -t nosquashfs												# 列出文件系统，squashfs 类型【https://www.kernel.org/doc/html/latest/filesystems/squashfs.html】除外。
		SOURCE              FSTYPE     SIZE   USED  AVAIL USE% TARGET
		devtmpfs            devtmpfs     4M      0     4M   0% /dev
		tmpfs               tmpfs      1.8G      0   1.8G   0% /dev/shm
		tmpfs               tmpfs    723.5M     9M 714.4M   1% /run
		/dev/mapper/cs-root xfs       16.9G   1.9G    15G  12% /
		/dev/sda1           xfs        960M 233.9M 726.1M  24% /boot
		tmpfs               tmpfs    361.7M      0 361.7M   0% /run/user/1000
		tmpfs               tmpfs    361.7M      0 361.7M   0% /run/user/0
	squashfs 最初为CD开发的专用只读压缩文件系统，现在也用于快照。
	可以更进一步，查看各个文件系统对象，如目录或文件：
		# stat anaconda-ks.cfg
		  文件：anaconda-ks.cfg
		  大小：807             块：8          IO 块：4096   普通文件			# 文件类型信息
		设备：fd00h/64768d      Inode：17800211    硬链接：1					# 设备和索引节点信息
		权限：(0600/-rw-------)  Uid：(    0/    root)   Gid：(    0/    root)
		环境：system_u:object_r:admin_home_t:s0
		最近访问：2023-12-20 06:06:35.042665672 +0800
		最近更改：2023-12-03 19:24:09.799711336 +0800
		最近改动：2023-12-03 19:24:09.799711336 +0800
		创建时间：2023-12-03 19:24:09.553178493 +0800
	低级文件系统和块设备命令：
		命令				使用场景
		lsblk				列出所有块设备
		fdisk，parted		管理磁盘分区
		blkid				显示块设备属性【如UUID】
		hwinfo				显示硬件信息
		file -s				显示文件系统和分区信息
		stat，df -i，ls -i	显示并列出inode相关信息
	在文件系统上下文中会遇到另一个术语【链接】。有时想要引用具有不同名称的文件或提供快捷方式。Linux中有两种类型的链接：
		①	硬链接【hard links】
			引用inode，不能引用目录。它们也不能跨文件系统。
		②	符号链接【symbolic links or symlinks】
				特殊文件，其内容表示另一个文件的路径的字符串。
		创建硬链接：
			ln myfile somealias
		创建符号链接：
			ln -s myfile somesoftalias
2、虚拟文件系统
	Linux通过称为虚拟文件系统（VFS【https://elixir.bootlin.com/linux/latest/source/Documentation/filesystems/vfs.rst】）的抽象，设法提供对多种资源（内存中、本地附加或网络存储）的类似文件的访问。
	基本思想是在客户端（系统调用）和实现具体设备或其他类型资源的操作的各个文件系统之间引入一个间接层。这意味着VFS将通过操作（打开、读取、查找）于实际实现细节分开。
	VFS 是内核中的一个抽象层，它为客户端提供基于文件范例的访问资源的通用方法。Linux中的文件没有任何规定的结构；它只是一个字节流。由客户端决定字节的含义。VFS抽象了对不同类型的文件系统的访问：
	①	本地文件系统【如，ext3，XFS，FAT，和NTFS】
		这些文件系统使用驱动程序来访问本地块设备，如HDD或SSD。
	②	内存中文件系统【如，tmpfs】
		不受长期存储设备支持，而是驻留在内存（RAM）中。
	③	伪文件系统【如，procfs】
		这些文件系统本质上也是内存中的。它们用于内核接口和设备抽象。
	④	网络文件系统【如，NFS，Netware（nee Novell）】
		这些文件系统也使用驱动程序；然而，实际数据所在的存储设备不是本地连接的而是远程的。这意味着驱动程序涉及到网络操作。
	与文件相关的系统调用有超过100个；然而，从本质上讲，这些操作可以分为几个类别，如：
		类别				系统调用【syscall】示例
		Inodes				chmod，chown，stat
		Files				open，close，seek，truncate，read，write
		Directories			chdir，getcwd，link，unlink，rename，symlink
		Firesystems			mount，flush，chroot
		Others				mmap，poll，sync，flock
	许多 VFS 系统调用分派到特定于文件系统的实现。 对于其他系统调用，有 VFS 默认实现。 此外，Linux内核定义了相关的VFS数据结构——见 include/linux/fs.h【https://elixir.bootlin.com/linux/latest/source/include/linux/fs.h】。如：
		inode	核心文件系统对象，捕获类型、所有权、权限、链接、指向包含文件数据的块的指针、创建和访问统计信息等。
		file	表示一个打开的文件（包括路径、当前位置和inode）
		dentry	存储其父目录和子目录（目录条目）
		super_block	表示一个文件包含挂载信息
		Others	包括 vfsmount 和 file_system_type
	Ⅰ	逻辑卷管理器
		虽然可以使用分区来划分驱动器，但分区很难使用，特别是需要调整大小（更改存储空间）时。逻辑卷管理器（LVM）在物理实体（如驱动器或分区）和文件系统之间使用一个间接层。
		这样就形成了一种设置，允许通过资源池实现无风险、零停机扩展和自动存储扩展。多个物理卷【PV】可以组成一个卷组【VG】，卷组又可以分成多个逻辑卷【LV】，在逻辑卷上创建文件系统。
		①	逻辑卷【PV】
			可以是一个磁盘分区，整个磁盘驱动，和其他设备
		②	逻辑卷【LV】
			是从卷组【VG】创建的块设备。这些在概念上与分区相当。必须在LV上创建文件系统才能使用它。可以在使用时轻松调整LV的大小。
		③	卷组【VG】
			是一组PV和LV之间的中间人。将VG视为共同提供资源的PV池。
		要使用 LVM 管理卷【https://unixutils.com/lvm-cheat-sheet-quick-reference/】，需要许多工具；然而，它们的命名一致且相对易于使用：
		①	PV管理工具	lvmdiskscan、pvdisplay、pvcreate、pvscan
		②	VG管理工具	vgs、vgdisplay、vgcreate、vgextend
		③	LV管理工具	lvs、lvscan、lvcreate
		》列出逻辑卷
			# lvscan
			  ACTIVE            '/dev/cs/swap' [1.00 GiB] inherit
			  ACTIVE            '/dev/cs/root' [<8.00 GiB] inherit
		》显示卷组
			# vgs
			  VG #PV #LV #SN Attr   VSize  VFree
			  cs   1   2   0 wz--n- <9.00g    0 
		》显示物理卷
			# pvdisplay 
			  --- Physical volume ---
			  PV Name               /dev/sda2
			  VG Name               cs
			  PV Size               <9.00 GiB / not usable 3.00 MiB
			  Allocatable           yes (but full)
			  PE Size               4.00 MiB
			  Total PE              2303
			  Free PE               0
			  Allocated PE          2303
			  PV UUID               RxkQml-RRIM-YEtJ-Y5vr-S6Z7-GZyq-YMclHO
		无论使用分区还是LV，使用文件系统还需要执行两个步骤。
	Ⅱ	文件系统操作
		在给定分区或逻辑卷（使用LVM创建）的情况下创建文件系统。涉及两个步骤：创建文件系统，然后安装它，或将其插入文件系统树中。
		①	创建文件系统
		为了使用文件系统，第一步是创建一个。这意味着正在设置组成文件系统的管理部分，并将分区或卷作为输入。一旦掌握了所有信息，就可以使用mkfs创建文件系统。
		mkfs接受两个主要输入：要创建的文件系统的类型和要在其上创建文件系统的设备（如，逻辑卷），如：
			mkfs -t ext4 \					# 创建 ext4 类型的文件系统
				/dev/some_vg/some_lv		# 在逻辑卷【/dev/some_vg/some_lv】上床架文件系统
		创建文件系统没有太多内容，因此主要工作是弄清楚要使用什么文件系统类型。使用 mkfs 创建文件系统后，可以使其在文件系统树中可用。
		②	挂载文件系统
		挂载文件系统意味着将其附加到文件系统树（从 / 开始）。使用 mount 附加文件系统。mount 需要两个主要输入：要附加的文件系统和文件系统树中的位置。
		此外，还可以提供其他输入，包括挂载选项（通过 -o），如只读，以及绑定挂载（通过 --bind ），用于将目录挂载到文件系统树中。
		也可以单独使用 mount 。列出现有挂载：
			# mount -t ext4,tmpfs
			tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel,inode64)
			tmpfs on /run type tmpfs (rw,nosuid,nodev,seclabel,size=188124k,nr_inodes=819200,mode=755,inode64)
			tmpfs on /run/user/0 type tmpfs (rw,nosuid,nodev,relatime,seclabel,size=94060k,nr_inodes=23515,mode=700,inode64)
		必须确保使用创建文件系统时使用的类型来挂载文件系统。如使用 mount -t vfat /dev/sdxX2 /media 来挂载SD卡，必须知道SD卡是使用vfat格式化的。可以使用 -o 选项让 mount 尝试所有文件系统，直到其中一个可以工作。
		此外，挂载仅在系统运行期间有效，因此为了使其永久有效，需要使用 fstab 文件 (/etc/fstab)【开机自动挂载】。
		③	常见的文件系统布局
		一旦有了一个文件系统，一个明显的挑战就是想出一种组织其内容的方法。可能想要组织诸如程序存储位置、配置数据、系统数据和用户数据之类的内容。
		将这种目录及其内容的组织称为文件系统布局。正式地，该布局称为文件系统层次结构标准（FHS【https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html】）。
		它定义目录、包括其结构和推荐内容。Linux基金会维护FHS，它是Linux发行版遵循的一个很好的起点。
		FHS 背后的想法值得称赞。 然而，在实践中会发现文件系统布局很大程度上取决于使用的 Linux 发行版。 因此，建议使用 man hier 命令来了解具体设置。
		常见的顶级目录：
			目录			说明
			bin，sbin		系统程序和命令（通常链接到 /usr/bin 和 /usr/sbin）
			boot			内核镜像和相关组件
			dev				设备（终端，驱动等）
			etc				系统配置文件
			home			用户家目录
			lib				共享的系统库
			mnt，media		可移动媒介的挂载点
			opt				发行版特定；可以托管包管理器文件
			proc，sys		内核接口
			tmp				用于临时文件
			usr				用户程序（通常只读）
			var				用户程序（日志，备份，网络缓冲等）
3、伪文件系统
	伪文件系统只是假装是文件系统，以便可以以通常的方式（ls、cd、cat）与它们交互，但实际上它们包装了一些内核接口。接口可以是一系列东西，包括以下内容：
		①	有关进程的信息
		②	与设备的交互【如键盘】
		③	实用程序【如，可用作数据源或接收器的特殊设备】
	Ⅰ	procfs
		Linux从Unix中继承 /proc 文件系统（procfs）。最初的目的是从内核发布与进程相关的信息，使其可供ps或free等系统命令使用。它的结构规则很少，允许读写访问，随着时间的推移，许多东西都进入其中。一般，可以在那里找到两类信息：
			①	/proc/PID 中的每个进程信息。这是内核通过以PID作为目录名的目录公开的与进程相关的信息。
			②	其他信息，如挂载、网络相关信息、TTY驱动程序、内存信息、系统版本和正常运行时间。
		procfs中的每个进程信息（值得关注）
			条目		类型			信息
			attr		目录			安全属性
			cgroup		文件			控制组
			cmdline		文件			命令行
			cwd			链接			当前工作目录
			environ		文件			环境变量
			exe			链接			进程的可执行文件
			fd			目录			文件描述符
			io			文件			存储I/O（字节/字符 读取和写入）
			limits		文件			资源限制
			mem			文件			使用中的内存
			mounts		文件			使用中的挂载
			net			目录			网络统计
			stat		文件			进程状态
			syscall		文件			系统调用使用
			task		目录			每个任务（线程）信息
			timers		文件			定时器信息
		要查看其实际情况，检查一下进程状态。这里使用status而不是stat，它没有人类可读的标签：
			# cat /proc/self/status | head -10		# 获取当前运行命令【cat】的进程状态
			Name:   cat
			Umask:  0022
			State:  R (running)						# 当前状态（运行中，在CPU中）
			Tgid:   1346
			Ngid:   0
			Pid:    1346							# 当前进程的PI的
			PPid:   1083							# 命令的父进程ID
			TracerPid:      0
			Uid:    0       0       0       0
			Gid:    0       0       0       0
		从网络空间收集信息：
			# cat /proc/self/net/arp 
			IP address       HW type     Flags       HW address            Mask     Device
			192.168.3.1      0x1         0x2         14:51:20:94:4f:87     *        ens33
			192.168.3.4      0x1         0x2         0c:54:15:88:17:5b     *        ens33
		可以从这个特殊的 /proc/self/net/arp 中收集有关当前进程的ARP信息。
	Ⅱ	sysfs
		/sys 文件系统（sysfs）是一种特定于Linux的结构化方式，让内核使用标准化布局公开选择信息（如，有关设备的信息）。sysfs中的目录如下：
			①	block/		该目录符号链接到已发现的块设备。
			②	bus/		在此目录中，可以找到内核支持的每种物理总线类型的一个子目录
			③	class/		该目录包含设备类型
			④	dev/		该目录包含两个子目录：block/【块设备】和 char/【字符设备】，结构是 major-ID:minor-ID 。
			⑤	devices/	在此目录中，内核提供了设备树的表示
			⑥	firmware/	通过这些目录，可以管理特定于固件的属性
			⑦	fs/			该目录包含一些文件系统的子目录
			⑧	module/		在这些目录中，可以找到内核加载的每个模块的子目录。
		sysfs 中还有更多子目录，但有些是新的和/或会受益于更好的文档。会发现 sysfs 中重复的某些信息在 procfs 中也可用，但其他信息（例如内存信息）仅在 procfs 中可用。
		查看块设备信息，如：
			# ls -al /sys/block/sda/
	Ⅲ	devfs
		/dev 文件系统（devfs）托管设备特殊文件，代表从物理设备到随机数发生器或只写数据接收器等设备。通过devfs可用的和管理的设备有：
			①	块设备		以块的形式处理数据，如存储设备（驱动器）
			②	字符设备	逐个字符地处理事物，如终端、键盘或鼠标
			③	特殊设备	生成数据或允许操纵它，包括 /dev/null 或 /dev/random。
		获取一个随机字符串，可执行以下操作：
			tr -dc A-Za-z0-9 < /dev/urandom
		这里生成一个42个字符地随机序列，其中包括大写字母、小写字母和数字字符。虽然 /dev/urandom 看起来像一个文件并且可以像文件一样使用，但它确实是一个特殊的文件，它使用许多源生成（或多或少）随机输出。
			# echo "something" > /dev/tty
			something
		/dev/tty 代表终端，通过这个命令，将 something 发送给它。
4、常规文件
	Ⅰ	通用文件系统
		常规文件的通用文件系统
			文件系统	Linux开始支持年份	文件大小	卷大小		文件数			文件名长度
			ext2			1993			2TB			32TB		10^18			255 字符
			ext3			2001			2TB			32TB		可变			255 字符
			ext4			2008			16TB		1EB			40亿			255 字符
			btrfs			2009			16EB		16EB		2^18			255 字符
			XFS				2001			8EB			8EB			2^64			255 字符
			ZFS				2006			16EB		2^128字节	每个目录10^14	255 字符
			NTFS			1997			16TB		256TB		2^32			255 字符
			vfat			1995			2GB			N/A			每个目录2^16	255 字符
		广泛使用的常规文件文件系统：
			①	ext4【https://wiki.archlinux.org/title/Ext4 】	
				一种广泛使用的文件系统，现在许多发行版都默认使用。它是ext3的向后兼容演变。与ext3一样，它提供日志功能，即将更改记录在日志中，以便在最坏的情况下（如，断电），恢复速度很快。
				这是一个很好的通用选择，ext4 手册【https://www.man7.org/linux/man-pages/man5/ext4.5.html 】
			②	XFS【https://wiki.archlinux.org/title/XFS 】
				日志文件系统最初由 Silicon Graphics (SGI) 在 20 世纪 90 年代初为其工作站设计。 它提供对大文件和高速 I/O 的支持，例如现在在 Red Hat 发行版系列中使用。
			③	ZFS【https://en.wikipedia.org/wiki/ZFS 】
				ZFS 最初由 Sun Microsystems 于 2001 年开发，结合了文件系统和卷管理器功能。
			④	FAT【https://en.wikipedia.org/wiki/FAT_filesystem_and_Linux 】
				这实际上是 Linux 的 FAT 文件系统系列，其中最常用的是 vfat。 主要用例是与 Windows 系统以及使用 FAT 的可移动介质的互操作性。 许多围绕卷的固有考虑因素并不适用。
			驱动器并不是唯一可以存储数据的地方。
	Ⅱ	内存中文件系统
		有许多可用的内存文件系统；有些是通用目的，有些则有非常具体的用例。一些广泛使用的内存文件系统如下：
			①	debugfs【https://www.kernel.org/doc/html/latest/filesystems/debugfs.html 】
				用于调试的专用文件系统；常见挂载方式：mount -t debugfs none /sys/kernel/debug
			②	loopfs【https://man7.org/linux/man-pages/man4/loop.4.html 】
				允许将文件系统映射到块而不是设备。
			③	pipefs
				安装在管道上的特殊（伪）文件系统：启用管道。
			④	swapfs【https://linux.die.net/EVMSUG/x3863.html 】
				用于实现交换（不可挂载）
			⑤	tmpfs【https://www.kernel.org/doc/html/latest/filesystems/tmpfs.html 】
				将文件数据保存在内核缓存中的通用文件系统。它速度块但非持久（断电意味着数据丢失）。
	Ⅲ	写时复制文件系统
		写时复制（CoW）是一个巧妙地概念，可以提高I/O速度，同时使用更少的空间。实现原理如下：
			①	原始文件【file1】假设由A，B和C块组成，复制为目标文件【file2】，仅复制元数据（指向块的指针），而不是复制实际块。由于仅创建元数据，因此速度很快并且不会占用太多空间。
			②	当目标文件【file2】被修改（假设C中的某些内容发生更改）时，只有块C才会被复制：创建一个名为C'的新块，虽然file2仍然指向（使用）未修改的块A和B，但它现在使用新块（C'）来捕获新数据。
		联合挂载【union mounts https://en.wikipedia.org/wiki/Union_mount 】，其想法是，可以将多个目录组合（挂载）到一个位置，这样，对于结果目录的用户来说，该目录似乎包含所有参与目录的组合内容（或：并集）。
		使用联合挂载时，经常遇到的术语“上层文件系统”和“下层文件系统”，这暗示了挂载的分层顺序。详情见“Unifying Filesystems with Union Mounts”【https://lwn.net/Articles/312641/ 】
		对于联合挂载，细节决定成败。必须制定有关当文件存在于多个位置时会发生什么或写入或删除文件意味着什么的规则。
		CoW在Linux文件系统中的实现如下：
			①	Unionfs【https://unionfs.filesystems.org/ 】
				Unionfs为CoW文件系统实现了联合挂载。它允许在安装时使用优先级透明地覆盖来自不同文件系统的文件和目录。它广泛流行并在CD-ROM和DVD环境中使用。
			②	OverlayFS【https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html 】
				Linux 的联合挂载文件系统实现于 2009 年推出，并于 2014 年添加到内核中。使用 OverlayFS，一旦打开文件，所有操作都直接由底层（较低或较高）文件系统处理。
			③	AUFS【https://en.wikipedia.org/wiki/Aufs 】
				另一种事项内核联合挂载的尝试，AUFS尚未合并到内核中。它在Docker中默认使用；现在Docker默认使用带有存储驱动程序Overlay2的OverlayFS。
			④	btrfs【https://archive.kernel.org/oldwiki/btrfs.wiki.kernel.org/index.php/Main_Page.html 】
				btrfs是b-tree system的缩写，是最初由Oracle公司设计的CoW。如今，许多公司都为btrfs的开发做出了贡献，包括Facebook、Intel、SUSE和Red Hat。
				它具有许多功能，例如快照（用于基于软件的 RAID）和自动检测静默数据损坏。 这使得 btrfs 非常适合专业环境——例如，在服务器上。
扩展
	Ⅰ	Basics
	“UNIX File Systems: How UNIX Organizes and Accesses Files on Disk”【https://www.oakton.edu/user/2/rjtaylor/CIS228/Slide/UNIX%20File%20Systems%202.pdf 】
	“KHB: A Filesystems Reading List”【https://lwn.net/Articles/196292/ 】
	Ⅱ	VFS
	“Overview of the Linux Virtual File System”【https://www.kernel.org/doc/html/latest/filesystems/vfs.html 】
	“Introduction to the Linux Virtual Filesystem (VFS)”【https://www.starlab.io/blog/introduction-to-the-linux-virtual-filesystem-vfs-part-i-a-high-level-tour 】
	“LVM” on ArchWiki【https://wiki.archlinux.org/title/LVM 】
	“LVM2 Resource Page”【https://sourceware.org/lvm2/ 】
	“How to Use GUI LVM Tools”【https://www.linuxjournal.com/content/review-gui-lvm-tools 】
	“Linux Filesystem Hierarchy”【https://tldp.org/LDP/Linux-Filesystem-Hierarchy/Linux-Filesystem-Hierarchy.pdf 】
	“Persistent BPF Objects”【https://lwn.net/Articles/664688/ 】
	Ⅲ	Regular files
	“Filesystem Efficiency—Comparison of EXT4, XFS, BTRFS, and ZFS” thread on reddit【https://www.reddit.com/r/DataHoarder/comments/f5uzv8/filesystem_efficiancy_comparision_of_ext4_xfs/ 】
	“Linux Filesystem Performance Tests”【https://www.linux-magazine.com/Online/Features/Filesystems-Benchmarked 】
	“Comparison of File Systems for an SSD” thread on Linux.org【https://www.linux.org/threads/comparison-of-file-systems-for-an-ssd.28780/ 】
	“Kernel Korner—Unionfs: Bringing Filesystems Together”【https://www.linuxjournal.com/article/7714 】
	“Getting Started with btrfs for Linux”【https://opensource.com/article/20/11/btrfs-linux 】

				
Applications, Package Management, and Containers
1、基础
	①	程序【program】
		这通常是Linux可以加载到内存并执行的二进制文件或Shell脚本。引用该实体的另一种方式是可执行的【executable】。可执行文件的类型决定了运行它的确切方式。如shel将解释并执行shell脚本。
	②	进程【progress】
		基于程序的运行实体，在不休眠时加载到内存中并使用CPU或I/O。
	③	守护进程【daemon】
		有时也称为服务，这是一个为其他进程提供某种功能的后台进程。如，打印机守护程序允许您进行打印。 还有用于 Web 服务、日志记录、时间以及您日常依赖的许多其他实用程序的守护程序。
	④	应用程序【application】
		一个程序，包括它的依赖项。通常是一个实质性的程序，包括用户界面。通常将术语“应用程序”与程序、其配置及其数据的整个生命周期联系起来：从查找和安装到升级到删除。
	⑤	包【package】
		包含程序和配置的文件；用于分发软件应用程序。
	⑥	包管理器【package manager】
		一种程序，将包作为输入，并根据其内容和用户指令，在Linux环境中安装它，升级它或删除它。
	⑦	供应链【supply chain】
		软件生产商和分销商的集合，使您能够查找和使用基于软件包的应用程序；
	⑧	开机【booting】
		Linux中的启动顺序涉及硬件和操作系统初始化步骤，包括加载内核和启动服务（或守护进程）程序，目的是使Linux进入可使用的状态。
2、Linux启动过程
	Linux启动过程通常是一个多阶段的工作，其中硬件和内核一起工作。启动过程如下，包括五个步骤：
		|				Hardware				 	|	Kernel space	|		User space		 |
			开机 ——> UEFI 或 BIOS ——> Boot loader   ——> 	Kernel  	——> Init ——> 其他用户空间
	①	UEFI or BIOS
		在现代环境中，统一可扩展固件接口（UEFI）规范定义了启动配置（存储在NVRAM中）和启动加载程序。
		在较旧的系统中，在此步骤中，开机自检（POST）完成后，基本I/O系统（BIOS）将初始化硬件（管理I/O端口和中断）并将控制权移交给引导加载程序。
	②	boot loader
		引导加载程序有一个目标：引导内核。根据启动介质的不同，细节可能略有不同。有一系列引导加载程序选项，包括当前的（如GRUB 2、systemd-boot、SYSLINUX、rEFInd）和旧版（如LILO、GRUB 1）。
	③	kernel
		内核通常以压缩形式位于/boot 目录中。这意味着第一步是将内核提取并加载到内存中。在初始化其子系统、文件系统和驱动程序后，内核将控制权移交给init系统，引导过程随之正确结束。
	④	init
		init系统负责在系统范围内启动守护进程（服务进程）。该init进程是进程层次结构的根，其进程ID（PID）为1。PID为1的进程将一直运行，直到关闭系统电源。
		除了负责启动其他守护进程之外，PID 1进程传统上还负责处理孤儿进程【不再具有父进程的进程】。
	⑤	其他用户空间
		通常，在此之后会发生一些其他用户空间级初始化，具体取决于环境：
		》通常会进行终端、环境和shell初始化。
		》考虑到用户偏好和配置，启动了用于具有GUI的桌面环境的显示管理器、图形服务器等。
	Gentoo wiki 对可用的init系统进行了很好的比较【https://wiki.gentoo.org/wiki/Comparison_of_init_systems】。
	》补充【System V Init】
		System V风格的init程序（或简称SysV init）【https://savannah.nongnu.org/projects/sysvinit 】是Linux中的传统init系统。
		Linux从Unix继承了SysV，它定义了所谓的运行级别（系统状态【如暂停】，单用户、多用户模式或GUI模式），其配置通常存储在 /etc/init.d 中。
		然而，启动守护进程的顺序方式和特定于发行版的配置处理使得这成为一个不太可移植的选项。
3、systemd
	systemd【https://systemd.io/ 】 最初是一个 init 系统，是initd的替代品。但现在它是一个强大的管理程序，包括日志记录、网络配置和网络时间同步等功能。
	它提供了一种灵活、可移植的方式来定义守护进程及其依赖项，并提供了一个统一的接口来控制配置。目前几乎所有的Linux发行版都在使用systemd。
	特别是，systemd 通过执行以下操作来解决以前init系统的缺点：
		》提供统一的方式来管理跨发行版的启动
		》实施更快、更易于理解的服务配置
		》提供现代化的管理套件，包括监控、资源使用控制（通过cgroup）和内置审计
	此外，init 在初始化时按顺序（即按字母数字顺序）启动服务，而systemd可以启动任何满足其依赖关系的服务，从而可能加快启动时间。
	通过单元【unit】告诉 systemd 运行什么、何时运行以及如何运行。
	Ⅰ	Units
		systemd 中的单元【unit】是具有不同语义的逻辑分组，具体取决于其功能和/或其目标资源。systemd根据目标资源区分许多单元：
			①	service 单元	描述如何管理服务或应用程序
			②	target 单元		捕获依赖关系
			③	mount 单元		定义一个挂载点
			④	timer 单元		为cron 作业等定义计时器
		其他不太重要的单元类型包括：
			①	socket			描述网络或IPC套接字
			②	device			用于 udev 或 sysfs 文件系统
			③	automount		配置自动挂载点
			④	swap			描述交换空间
			⑤	path			用于基于路径的激活
			⑥	snapshot		允许在更改后重建系统的当前状态
			⑦	slice			与cgroup关联
			⑧	scope			管理外部创建的系统进程集
		为了被 systemd 识别，一个单元需要被序列化成一个文件。systemd在多个位置查找单元文件。三个最重要的文件路径如下：
			①	/lib/systemd/system		Package-installed units					
			②	/etc/systemd/system		System admin-configured units
			③	/run/systemd/system		Nonpersistent runtime modifications
	Ⅱ	使用 systemctl 进行管理
		用于与 systemd 交互以管理服务的工具是 systemctl【https://man7.org/linux/man-pages/man1/systemctl.1.html 】
		有用的 systemd 命令如下：
			命令									用法
			systemctl enable XXX.service			启用服务；设置开机自启
			systemctl daemon-reload					重新加载所有单元文件并重新创建整个依赖关系树
			systemctl start XXX.service				启动服务
			systemctl stop XXX.service				停止服务
			systemctl restart XXX.service			停止，然后启动服务
			systemctl reload XXX.service			向服务发出重新加载命令；回退重新启动
			systemctl kill XXX.service				停止服务执行
			systemctl status XXX.service			获取服务状态的简短摘要，包括一些日志行
		注意，systemctl 还提供了更多命令，从依赖项管理和查询到控制整个系统（例如重新启动）。systemd 生态系统还有许多其他可能会方便的命令行工具。 这包括但不限于以下内容：
			bootctl【https://man7.org/linux/man-pages/man1/bootctl.1.html 】
				允许检查引导加载程序状态并管理可用的引导加载程序。
			timedatectl
				允许设置和查看 时间和日期相关信息【https://opensource.com/article/20/6/time-date-systemd 】
			coredumpctl
				使您能够处理保存的核心转储。排除故障时请考虑使用此工具
	Ⅲ	使用 journalctl 进行监控
		日志【journal】是 systemd 的一个组件；从技术上讲，它是由 systemd-journald守护进程管理的二进制文件，为 systemd 组件记录的所有消息提供集中位置。可通过journalctl 查看 systemd 管理的日志。
	Ⅳ	示例
		定义一个类型为 service 的 systemd 单元文件【告诉 systemd 如何启动应用程序】，如：
			# greeter.service
			[Unit]
			Description=My Greeting Service		# 服务描述，当使用 systemctl status 时，会显示

			[Service]
			Type=oneshot		
			ExecStart=/home/miggi/greeter.sh	# 应用程序的路径
		定义一个 timer unit【https://wiki.archlinux.org/title/Systemd/Timers 】来每隔一个小时启动greeter 服务。如：
			# greeter.timer
			[Unit]
			Description=Runs Greeting service at the top of the hour

			[Timer]
			OnCalendar=hourly					# 使用 systemd 时间和日期格式【https://www.freedesktop.org/software/systemd/man/latest/systemd.time.html 】时间表
		将定义的单元文件放在 /run/systemd/system 中，以便 systemd 识别它们。现在可以使用 greeter 定时器了【因为当将其复制到相应的目录时，systemd会自动拾取它】。
			# systemctl start greeter.timer
			# systemctl status greeter.timer
			● greeter.timer - Runs Greeting service at the top of the hour
			     Loaded: loaded (/run/systemd/system/greeter.timer; static)
			     Active: active (waiting) since Fri 2023-12-22 06:03:21 CST; 3s ago
			      Until: Fri 2023-12-22 06:03:21 CST; 3s ago
			    Trigger: Fri 2023-12-22 07:00:00 CST; 56min left
			   Triggers: ● greeter.service
			
			12月 22 06:03:21 localhost.localdomain systemd[1]: Started Runs Greeting service at the top of the hour.
		可以通过journalctl检查日志，如：
			# journalctl -f -u greeter.service			# 使用 journalctl 查看并跟踪【-f】greeter.service 单元（使用-u选择）的日志。
4、Linux 应用程序供应链【supply chain】
	供应链的含义是，一个由组织和个人组成的向消费者提供产品的系统。这里产品时由软件工件组成的应用程序，消费者则是使用应用程序的人，也可以将其视为管理应用程序的工具。
	Linux应用程序供应中的三个不同领域如下：
		①	软件维护者【Software maintainers】
			其中包括个人开发人员、开源项目和公司，例如独立软件供应商 (ISV)，它们生产软件工件并将其发布，例如作为存储库 (repo) 的包。
		②	仓库【Repository】
			这列出了包含应用程序的全部或部分以及元数据的包。该包通常捕获应用程序的依赖项。依赖项是应用程序运行所需的其他包。保持这些依赖关系是最新的很困难。
		③	工具【Tooling（包管理器）】
			在目标系统方面，这可以在存储库中查找软件包，并按照用户的指示安装、更新和删除应用程序。注意，一个或多个包可以代表应用程序及其依赖项。
	有许多选项可用于包和依赖项管理，例如传统的包管理器、基于容器的解决方案以及更新的方法。有关包和依赖项管理选项的三个主要类别的说明如下：
		①	传统包管理器
			通常区分低级【如，RPM】和高级【如，yum，dnf】工具。如包管理器可以解决依赖关系并提供高级接口（安装、更新、删除），将其称为高级包管理器。
		②	基于容器的解决方案
			这些最初来自服务器和云计算领域。 考虑到它们的功能，应用程序管理是一种用例，但不一定是主要用例。 换句话说，作为开发人员，会喜欢容器，因为它们能够轻松测试事物并轻松交付生产就绪的应用程序。
		③	现代包管理器
			这些根源于桌面环境，其主要目标是让最终用户尽可能轻松地使用应用程序。
5、包和包管理器
	包格式和包管理器通常源自两个主要的 Linux 发行版系列：Red Hat（RHEL、Fedora、CentOS 等）和 Debian 的系统（Debian、Ubuntu 等）。相关地两个概念如下：
		①	包【package】
			从技术上讲，文件通常是压缩的并且可能包含元数据。
		②	工具【tooling（包管理器）】
			处理目标系统上的这些包，以安装和维护应用程序。包管理器通常与仓库进行交互并维护包的本地缓存。
	Ⅰ	RPM 包管理器
		RPM Package Manager【https://en.wikipedia.org/wiki/RPM_Package_Manager 】最初由 Red Hat 创建，但现在广泛用于各种发行版。 .rpm 文件格式用于 Linux Standard Base，可以包含二进制文件或源文件。 
		这些软件包可以进行加密验证，并支持通过补丁文件进行增量更新。使用 RPM 的包管理器如下：
			yum			Amazon Linux，CentOS，Fedora 和 Red Hat	【http://yum.baseurl.org/ 】
			DNF			CentOS，Fedora，和 RedHat 【https://docs.fedoraproject.org/en-US/quick-docs/dnf/ 】
			Zypper		openSUSE 和 SUSE Linux Enterprise
		示例【安装 Go】
			①	找到 Go 的包
				yum search golang
			②	找到包的相关信息后，使用以下命令安装：
				yum install golang
			③	验证，准确检查安装的内容和位置：
				yum info golang
	Ⅱ	Debian deb
	Ⅲ	特定语言的包管理器
		还有特定于编程语言的包管理器，如下所示：
		①	C/C++		有许多不同的包管理器，包括 Conan 和 vcpkg	【https://caiorss.github.io/C-Cpp-Notes/package-managers.html 】
		②	Go			内置包管理器（go get，go mod）
		③	Node.js		npm和其他
		④	Java		maven和nuts，和其他
		⑤	Python		pip和PyPM
		⑥	Ruby		rubygems 和 Rails
		⑦	Rust		cargo
6、容器
	这里，可以将容器理解为一个Linux进程组，它使用Linux 命名空间、cgroup和可选的CoW文件系统来提供应用程序级依赖关系管理。容器的用例范围从本地测试和开发到使用分布式系统，如使用Kubernetes中的容器化微服务。
	虽然容器对于开发人员和系统管理员非常有用，但作为最终用户，可能会更习惯使用更高级别的工具来管理应用程序。
	针对系统管理员，引入容器包括以下内容：
		①	Linux-VServer（2001）							【https://en.wikipedia.org/wiki/Linux-VServer 】
		②	OpenVZ（2005）									【https://openvz.org/ 】
		③	LXC（2008）										【https://linuxcontainers.org/ 】
		④	Let Me Contain That for You（lmctfy）（2013）	【https://github.com/google/lmctfy 】

	所有这些方法的共同点是使用Linux内核提供的基本构建块（如，命名空间或cgroup）来允许用户运行应用程序。
	Docker 在这一概念上进行了创新，引入了两个突破性的元素：通过容器镜像定义打包的标准化方法和人性化的用户界面（例如 docker run）。 
	容器镜像的定义和分发方式以及容器的执行方式构成了现在所谓的开放容器计划 (OCI) 【https://opencontainers.org/ 】核心规范的基础。 当在这里讨论容器时，关注的是符合 OCI 的实现。
	OCI容器的三个核心规范如下：
		①	Runtime specification											【https://github.com/opencontainers/runtime-spec 】
			定义运行时需要支持的内容，包括操作和声明周期阶段。
		②	Image format specification										【https://github.com/opencontainers/image-spec 】
			定义如何基于元数据和层构建容器镜像
		③	Distribution specification										【https://github.com/opencontainers/distribution-spec 】
			定义容器镜像的传输方式，即存储库在容器上下文中的有效工作方式
	与容器相关的另一个想法是不变性。这意味着一旦配置组合在一起，就无法在使用过程中更改它。换句话说，更改需要创建新的（静态）配置和新的资源（如进程）。
	Ⅰ	Linux Namespaces
		Linux最初对资源有全局视图。为了允许进程对资源（如文件系统、网络甚至用户）有本地视图，Linux引入了命名空间。
		Linux命名空间都是关于资源可见性的，可用于隔离操作系统资源的不同方面。在这种情况下，隔离主要是关于进程所看到的内容，不一定是硬边界（从安全角度来看）。
		要创建命名空间，可以使用三个相关的系统调用：
			①	clone														【https://man7.org/linux/man-pages/man2/clone.2.html 】
				用于创建可以与父进程共享其部分执行上下文的子进程。
			②	unshare														【https://man7.org/linux/man-pages/man2/unshare.2.html 】
				用于从现有进程中删除共享执行上下文。
			③	setns														【https://man7.org/linux/man-pages/man2/setns.2.html 】
				用于将现有进程加入现有命名空间。
		这些系统调用采用一系列标志作为参数，使得能对要创建、加入或离开的命名空间进行细粒度控制：
			①	CLONE_NEWNS
				用于文件系统挂载点【https://man7.org/linux/man-pages/man7/mount_namespaces.7.html 】。通过 /proc/$PID/mounts 可见。自 Linux 2.4.19 开始支持。
			②	CLONE_NEWUTS
				用于创建 主机名和（NIS）域名【https://lwn.net/Articles/179345/ 】隔离。通过 uname -n 和 hostname -f 可见。自 Linux 2.6.19 开始支持。
			③	CLONE_NEWPIC
				用于执行 进程间通信（IPC)【https://lwn.net/Articles/187274/ 】资源隔离，如System V IPC对象或POSIX消息队列。通过 /proc/sys/fs/mqueue，/proc/sys/kernel，和/proc/sysvipc 可见。自Linux 2.6.19开始支持。
			④	CLONE_NEWPID
				用于 PID 编号空间隔离【https://lwn.net/Articles/259217/ 】（PID inside/outside the namespace）。可通过 /proc/$PID/status 收集关于它的详情。自Linux 2.6.24开始支持。
			⑤	CLONE_NEWNET
				用于控制网络系统资源【https://lwn.net/Articles/219794/ 】（如，网络设备，IP地址，IP路由表，和端口号）的可见性。可通过 ip netns list ，/proc/net，和/sys/class/net 查看。自Linux 2.6.29开始支持。
			⑥	CLONE_NEWUSER
				用于映射命名空间内部/外部的 UID+GIDs【https://lwn.net/Articles/528078/ 】。可通过 id 命令和 /proc/$PID/uid_map 和 /proc/$PID/gid_map 查询 UIDs 和 GIDs 和它们的映射。自Linux 3.8 开始支持。
			⑦	CLONE_NEWCGROUP
				用于管理 命名空间中的cgroups【https://man7.org/linux/man-pages/man7/cgroup_namespaces.7.html 】。可通过 /sys/fs/cgroup，/proc/cgroups 和 /proc/$PID/cgroup 查看。自Linux 4.6 开始支持。
		查看系统上使用的命名空间的一种方法如下：
			# lsns
			        NS TYPE   NPROCS   PID USER COMMAND
			4026531834 time      155     1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 31
			4026531835 cgroup    155     1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 31
			4026531836 pid       155     1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 31
			4026531837 user      155     1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 31
			4026531838 uts       153     1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 31
			4026531839 ipc       155     1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 31
			4026531840 net       155     1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 31
			4026531841 mnt       146     1 root /usr/lib/systemd/systemd --switched-root --system --deserialize 31
			4026531862 mnt         1    29 root kdevtmpfs
			4026532495 mnt         1   643 root /usr/lib/systemd/systemd-udevd
			4026532496 uts         1   643 root /usr/lib/systemd/systemd-udevd
			4026532609 mnt         1   734 root /sbin/auditd
			4026532610 mnt         2   755 dbus /usr/bin/dbus-broker-launch --scope system --audit
			4026532611 mnt         1   759 root /usr/sbin/irqbalance --foreground
			4026532612 mnt         1   760 root /usr/lib/systemd/systemd-logind
			4026532613 uts         1   760 root /usr/lib/systemd/systemd-logind
			4026532614 mnt         1   819 root /usr/sbin/NetworkManager --no-daemon
			4026532684 mnt         1   920 root /usr/sbin/rsyslogd -n
	Ⅱ	Linux cgroups
		命名空间与可见性有关，而cgroup【https://www.man7.org/linux/man-pages/man7/cgroups.7.html 】提供了一种不同的功能：它们是一种组织进程组的机制。除了分层组织之外，还可以使用cgroup来控制系统资源的使用。
		此外，cgroup还提供资源使用情况跟踪（如，显示进程（组）使用了多少RAM或CPU秒数）。将cgroup视为声明性单元，将控制器视为一段内核代码，用于强制执行特定资源限制或报告其使用情况。
		cgroup版本如下：
		①	cgroup v1
			对于 cgroup v1，社区采用了一种临时方法，根据需要添加新的 cgroup 和控制器。 存在以下 v1 cgroup 和控制器：
			①	CFS bandwidth control
				通过 cpu cgroup 使用。自Linux2.6.24开始支持
			②	CPU accounting controller
				通过 cpuacct cgroup 使用。自Linux2.6.24开始支持
			③	cpusets cgroup
				允许给任务【task】分配CPU和内存。自Linux2.6.24开始支持。
			④	Memory resource controller
				允许隔离任务的内存行为。自Linux2.6.25开始支持
			⑤	Device whitelist controller
				允许控制设备文件的使用。自Linux2.6.26开始支持
			⑥	freezer cgroup
				用于批处理作业【batch job】的管理。自Linux2.6.28开始支持
			⑦	Network clssifer cgroup
				用于为数据包分配不同的优先级。自Linux2.6.29开始支持
			⑧	Block IO controller
				允许节流【throttle】阻塞 I/O，自Linux2.6.33开始支持
			⑨	perf_event command
				允许收集性能数据。自Linux2.6.39开始支持
			⑩	Network priority cgroup
				允许动态设置网络流量的优先级，自Linux3.3开始支持
			⑩ ①	HugeTLB controller
				允许限制HugeTLB的使用。自Linux3.5开始支持
			⑩ ②	Process number controller
				允许cgroup层次结构在达到特定限制后创建新进程。从Linux4.3开始支持。
		②	cgroup v2
			cgroup v2 是根据 v1 的经验教训对 cgroup 进行了彻底重写。 无论是在一致的配置和 cgroup 的使用以及（集中且统一的）文档方面都是如此。 
			与cgroup v1 每进程设计不同，cgroup v2 仅具有单一层次结构，并且所有控制器都以相同的方式进行管理。 以下是 v2 控制器：
			①	CPU控制器
				调节CPU周期的分布，支持不同的模型（weight，max）并包括使用情况报告。
			②	内存控制器
				使用一系列参数调节内存分配，支持用户空间内存、内核数据结构（如dentry和inode）以及TCP套接字缓冲区。
			③	I/O控制器
				通过基于权重和绝对带宽或每秒I/O操作数（IOPS）限制来调节I/O资源的分配，报告字节和IOPS读写。
			④	Process number（PID）controller
				与v1版本相同
			⑤	cpuset controller
				与v1版本相同
			⑥	device controller
				管理对设备文件的访问，在eBPF之上实现。
			⑦	rdma controller
				规范远程直接内存访问（RDMA）资源的分配和核算。
			⑧	HugeTLB controller
				与v1版本相同
			v2中还有各种cgroup，允许对标量资源进行资源限制和跟踪机制（不能像其他cgroup资源一样进行抽象）。可以通过 systemctl 查看 Linux 系统中的所有v2 cgroup。如：
				# systemctl status
				● localhost.localdomain
				    State: running
				    Units: 282 loaded (incl. loaded aliases)
				     Jobs: 0 queued
				   Failed: 0 units
				    Since: Fri 2023-12-22 18:55:15 CST; 4h 7min ago
				  systemd: 252-17.el9
				   CGroup: /
				           ├─init.scope
				           │ └─1 /usr/lib/systemd/systemd --switched-root --system --deserialize 31
				           ├─system.slice
				           │ ├─NetworkManager.service
				           │ │ └─819 /usr/sbin/NetworkManager --no-daemon
				           │ ├─auditd.service
				           │ │ └─734 /sbin/auditd
				           │ ├─crond.service
				           │ │ └─859 /usr/sbin/crond -n
						   ...
						   └─user.slice
				             ├─user-0.slice
				             │ ├─session-3.scope
				             │ │ ├─1519 "sshd: root [priv]"
				             │ │ ├─1533 "sshd: root@pts/1"
				             │ │ ├─1534 -bash
				             │ │ ├─1681 systemctl status
				             │ │ └─1682 less
				             │ └─user@0.service
				             │   └─init.scope
				             │     ├─1524 /usr/lib/systemd/systemd --user
				             │     └─1526 "(sd-pam)"
			cgroup的另一个有用视图是交互式资源使用情况，如：
				# systemd-cgtop
			可以预期，随着现代内核版本的使用更加广泛，cgroups v2 将成为标准。 确实有某些发行版，例如 Arch、Fedora 31 和 Ubuntu 21.10，默认已经有 v2。
	Ⅲ	写时复制【CoW】文件系统
		容器的第三个构建块是CoW文件系统。这些在构建时使用。它们将应用程序及其所有依赖项打包到一个可以分发的独立文件中。
		通常，CoW文件系统与绑定挂载【bind mounts https://docs.docker.com/storage/bind-mounts/ 】结合使用，以有效的方式将不同依赖项的内容分层。
	Ⅳ	Docker
		Docker 是 Docker Inc. 于 2014 年开发和推广的一种人性化容器实现。使用 Docker，可以轻松打包程序及其依赖项，并在从桌面到云的各种环境中启动它们。 
		Docker 的独特之处不在于构建块（命名空间、cgroup、CoW 文件系统和绑定安装）。 这些在 Docker 出现之前就已存在一段时间了。 
		其特别之处在于，Docker 将这些构建块组合在一起，通过隐藏管理命名空间和 cgroup 等低级位的复杂性，使它们易于使用。
		Docker中有两个主要概念：镜像和运行容器。
		①	容器镜像
			压缩归档文件，其中包含JSON文件和层（实际上是目录）中的元数据。Docker守护进程根据需要从容器注册表中提取容器镜像。
		②	作为运行时工件的容器（如，app A/B/C）
			可以启动、停止、终止和删除它。可以使用客户端CLI工具（docker）与Docker守护进程交互。该CLI工具向守护进程发送命令，守护进程依次执行相应的操作，如构建或运行容器。
		如下提供了常用Docker CLI命令的简短参考，涵盖构建时和运行时阶段。要获取完整参考（包括用例），参阅Docker文档【https://docs.docker.com/engine/reference/commandline/docker/ 】。
			常用 Docker 命令：
				命令		描述								示例
				run			启动一个容器						以守护进程运行NGINX并在退出时删除容器：docker run -d --rm nginx:1.21
				ps			列出容器							列出所有容器（包括非运行中）：docker ps -a
				inspect		显示底层信息						查看容器IP：docker inspect -f '{{.NetworkSettings.IPAddress}}'
				build		本地生成容器镜像					基于当前目录和标签构建镜像：docker build -t some:tag .
				push		上传容器镜像到仓库					推送到AWS仓库：docker push public.ecr.aws/some:tag
				pull		从仓库下载容器镜像					从AWS仓库拉取：docker pull public.ecr.aws/some:tag
				images		列出本地容器镜像					列出某个确切registry中的镜像：docker images ubuntu
				image		管理容器镜像						移除所有未使用的镜像：docker image prune -all
		①	容器镜像
			要定义有关如何构建容器镜像的说明，可以使用称为Dockerfile【https://docs.docker.com/engine/reference/builder/ 】的纯文本文件格式。Dockerfile中可以有不同的指令：
			》基础镜像
				FROM	从基础镜像创建一个新的构建阶段
			》元数据
				LABEL	给镜像添加元数据
			》参数和环境变量
				ARGS，ENV
			》构建时规范
				COPY，RUN 等，定义如何逐层构建镜像。
			》运行时规范
				CMD 和 ENTRYPOINT。定义容器如何运行
			使用 docker build 命令，可以将代表应用程序的文件集合（作为源或二进制格式）与 Dockerfile 一起转换为容器镜像。该容器镜像是可以运行或推送到仓库的工件，以便将其分发给其他人以拉取并最终运行。
		②	运行时容器
			可以使用交互式输入（连接终端）或作为守护进程（后台）运行容器。docker run 采用容器镜像和一组运行时输入，如环境变量、要公开的端口和要挂载的卷。
			利用此信息，Docker创建必要的命令空间和cgroup，并启动容器镜像（CMD或ENTRYPOINT）中定义的应用程序。
	Ⅴ	其他容器工具
		不必使用Docker来处理OCI容器；作为替代方案，可以使用 podman【https://podman.io/ 】和 buildah【https://buildah.io/ 】。这些无守护程序工具允许构建OCI容器镜像（buildah）并运行它们（podman）。
		此外，还有许多工具可以使OCI容器、命名空间和cgroup的使用变得更加容易，包括但不限于以下工具：
			》containerd
				管理OCI容器生命周期的守护进程，从镜像传输和存储到容器运行时监督。
			》skopeo
				用于容器镜像操作（复制、检查清单等）
			》systemd-cgtop
				top 的一种cgroups 感知变体，以交互方式显示资源使用情况。
			》nsenter
				允许在指定的现有命名空间中执行程序
			》unshare
				允许运行具有特定命名空间的程序（通过 flags选择加入）
			》lsns
				列出有关Linux命名空间的信息
			》cinf
				列出与进程ID关联的Linux命名空间和cgroup的信息。
7、现代包管理器
	除了通常特定于发行版的更传统的包管理器之外，还有一种新的包管理器。 这些现代解决方案通常使用容器，旨在跨分发或针对特定环境。 例如，它们可以让 Linux 桌面用户轻松安装 GUI 应用程序。
	Ⅰ	Snap
		Canonical Ltd. 设计和推广的软件打包和部署系统。 它配备了完善的沙箱设置，可在桌面、云和物联网环境中使用。
	Ⅱ	Flatpak
		针对Linux桌面环境进行了优化，使用cgroup、命名空间、绑定挂载和seccomp作为其构建块。
	Ⅲ	AppImage
		已存在多年，提倡“一个应用程序等于一个文件”的理念； 也就是说，除了目标 Linux 系统中包含的内容之外，它不需要任何依赖项。 随着时间的推移，AppImage 中出现了许多有趣的功能，从高效更新到桌面集成再到软件目录。
	Ⅳ	Homebrew
		最初来自 macOS 世界，但可用于 Linux，并且越来越受欢迎。 它是用 Ruby 编写的，具有强大而直观的用户界面。
扩展
	启动进程和初始化系统
		①	Analyzing the Linux boot process 【https://opensource.com/article/18/1/analyzing-linux-boot-process 】
		②	Stages of Linux booting process 【https://www.crybit.com/linux-boot-process/ 】
		③	How To Configure a Linux Service to Start Automatically After a Crash or Reboot【https://www.digitalocean.com/community/tutorial-series/how-to-configure-a-linux-service-to-start-automatically-after-a-crash-or-reboot 】
	包管理
		①	State of the Software Supply Chain 【https://www.sonatype.com/state-of-the-software-supply-chain/Introduction 】
		②	Linux Package Management【https://www.linode.com/docs/guides/tools-reference/linux-package-management/ 】
		③	Understanding RPM Package Management Tutorial【https://access.redhat.com/sites/default/files/attachments/rpm_tutorial_20120831.pdf 】
		④	Debian packages【https://www.debian.org/distrib/packages 】
	容器
		①	A Practical Introduction to Container Terminology 【https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction# 】
		②	OCI vs Docker: What is a container?【https://www.padok.fr/en/blog/container-docker-oci】
		③	Building containers without Docker【https://blog.alexellis.io/building-containers-without-docker/ 】
		④	Why Red Hat is investing in CRI-O and Podman【https://www.redhat.com/en/blog/why-red-hat-investing-cri-o-and-podman 】
		⑤	揭秘容器【https://github.com/saschagrunert/demystifying-containers 】
		⑥	Rootless Containers【https://rootlesscontaine.rs/ 】
		⑦	The hunt for a better Dockerfile 【https://matduggan.com/the-hunt-for-a-better-dockerfile/ 】
	

Networking
1、基础
	在现代环境中，网络起着核心作用。鉴于网络有许多移动部件和层，可能很难确定问题是与硬件相关还是源于软件堆栈。Linux网络的另一个挑战来自抽象。
	Linux网络概述：
		用户空间								内核空间							硬件
		浏览器 ip SSH 					    	 Sockets							NIC Wireless
		dig ping arp mail						TCP/UDP
												IP ICMP
												Drivers
2、TCP/IP 堆栈
	TCP/IP堆栈，是由许多协议和工具组成的分层网络模型，大部分由IETF规范定义。每一层都必须知道并且只能与自身上方和下方的层进行通信。数据封装在数据包中。
	因此，如果应用程序想要发送数据，它将直接与最高层交互，最高层将添加标头等，并在堆栈中添加。 相反，如果应用程序想要接收数据，它将到达最低层，每个层依次根据它找到的标头信息对其进行处理，并将有效负载传递到上面的层。
	从堆栈底部开始，TCP/IP堆栈的四层如下：
		①	链路层
			该层位于堆栈的最底层，涵盖硬件（以太网、WiFi）和内核驱动程序，并重点关注数据包如何在物理设备之间发送。
		②	网络层
			对于互联网协议（IP），这一层主要关注路由；也就是说，它支持跨网络的机器之间发送数据包。
		③	传输层
			该层控制（虚拟或物理）主机之间的端到端通信，使用传输控制协议（TCP）进行基于会话的可靠通信，使用用户数据报协议（UDP）进行无连接通信。
			它主要处理数据包的传输方式，包括通过端口寻址机器上的各个服务以及数据完整性。此外，Linux支持套接字作为通信端点。
		④	应用层
			该层处理面向用户的工具和应用程序，如Web、SSH和邮件。
	分层意味着一层的报头和有效负载组成了下一层的有效负载。
	Ⅰ	链路层
		在TCP/IP堆栈的链路层中，所有内容都与硬件或接近硬件的内容有关，如字节、线路、电磁波、设备驱动程序和网络接口。这里，会遇到以下术语：
			以太网			一系列使用电线连接机器的网络技术；常用于局域网（LAN）。
			无线网			也称WiFi，一类通信协议和方法，它不使用电线，而是使用一些电磁波来传输数据。
			MAC地址			MAC是媒体访问控制的缩写，是硬件的唯一48位标识符，用于识别机器（准确来说是网络接口）。MAC地址通过组织唯一标识符（OUI）对（接口的）制造商进行编码，通常占据前24位。
			接口			网络接口。可以是物理接口或虚拟（软件）接口【如环回接口 lo）。
		》网络接口控制器【Network interface controller】
		网络接口控制器（NIC）是一项重要的硬件设备，有时称为网络接口卡【网卡】。NIC通过有线标准提供与网络的物理连接。
		一旦成为网络的一部分，网卡会将您想要发送的字节的数字表示形式转换为电或电磁信号。 接收路径的情况则相反，网卡将其接收到的任何物理信号转换为软件可以处理的位和字节。
		传统上，可以使用 ifconfig 命令查询系统上可用的NIC的信息。如：
			# ifconfig
			ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
			        inet 192.168.3.10  netmask 255.255.255.255  broadcast 0.0.0.0
			        inet6 fe80::20c:29ff:fe98:3c14  prefixlen 64  scopeid 0x20<link>
			        ether 00:0c:29:98:3c:14  txqueuelen 1000  (Ethernet)
			        RX packets 39108  bytes 25078557 (23.9 MiB)
			        RX errors 0  dropped 0  overruns 0  frame 0
			        TX packets 14534  bytes 2164695 (2.0 MiB)
			        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
			
			ens36: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
			        inet 192.168.229.128  netmask 255.255.255.0  broadcast 192.168.229.255
			        inet6 fe80::167c:9d1b:7073:761c  prefixlen 64  scopeid 0x20<link>
			        ether 00:0c:29:98:3c:1e  txqueuelen 1000  (Ethernet)
			        RX packets 1809  bytes 340212 (332.2 KiB)
			        RX errors 0  dropped 0  overruns 0  frame 0
			        TX packets 28  bytes 1866 (1.8 KiB)
			        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
			
			lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
			        inet 127.0.0.1  netmask 255.0.0.0
			        inet6 ::1  prefixlen 128  scopeid 0x10<host>
			        loop  txqueuelen 1000  (Local Loopback)
			        RX packets 96  bytes 8160 (7.9 KiB)
			        RX errors 0  dropped 0  overruns 0  frame 0
			        TX packets 96  bytes 8160 (7.9 KiB)
			        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
		对于执行相同操作（查询接口并检查其状态）的更现代方法，请使用 ip 命令。如：
			# ip link show
			1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
			    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
			2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
			    link/ether 00:0c:29:98:3c:14 brd ff:ff:ff:ff:ff:ff
			    altname enp2s1
			3: ens36: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
			    link/ether 00:0c:29:98:3c:1e brd ff:ff:ff:ff:ff:ff
			    altname enp2s4
		对于 ifconfig 和 ip link，可能对 LOWER_IP 或 MULTICAST 等标志的含义感兴趣； 这些记录在 netdevice 手册页【https://www.man7.org/linux/man-pages/man7/netdevice.7.html 】中。
		》地址解析协议【Address Resolution Protocol】
		地址解析协议（ARP）将MAC地址映射到IP地址。从某种意义上说，它桥接了链路层与其之上的层（网络层）。如：
			# arp
			Address                  HWtype  HWaddress           Flags Mask            Iface
			192.168.3.4              ether   0c:54:15:88:17:5b   C                     ens33
			_gateway                 ether   14:51:20:94:4f:87   C                     ens33
		使用 arp 命令显示MAC地址映射到主机名或IP地址的缓存。注意，可以使用 arp -n 来阻止主机名解析并显示IP地址而不是DNS名称。
		或，使用更现代的 ip 命令，如：
			# ip neigh
			192.168.3.4 dev ens33 lladdr 0c:54:15:88:17:5b STALE 
			192.168.3.1 dev ens33 lladdr 14:51:20:94:4f:87 REACHABLE 
		要显示、配置无线设备并对其进行故障排除，需要使用 iw 命令。如：
			# iw dev wlp1s0 info
		收集与路由器和流量相关的信息，如：
			# iw dev wlp1s0 link
	Ⅱ	网络层
		TCP/IP堆栈的第二层，即网络层，负责将数据包从网络上的一台机器路由到另一台机器。网络层的设计假设可用的网络基础设施不可靠，并且参与者（如网络中的节点或它们之间的连接）频繁变化。
		网络层提供尽力传送（即不保证性能）并将每个数据包视为独立的。更高层（通常是传输层）负责解决可靠性问题，包括数据包顺序、重试或交互保证。
		在这一层中，用于在全球范围内唯一地逻辑识别机器的主导协议是互联网协议 (IP)，它有两种类型：IP 版本 4 (IPv4) 和 IP 版本 6 (IPv6)。
		①	IPv4
			IPv4定义了唯一的32位数字，用于标识在TCP/IP通信中充当端点的主机或进程。编写 IPv4 地址的一种方法是将 32 位分成四个用句点分隔的 8 位段【点分十进制】，每个段在 0 到 255 范围内，称为一个八位组（暗示该段涵盖 8 位）。	
			按照RFC791和相关IETF规范中的定义，IP标头具有许多字段，但以下是应该注意的最重要的字段：
				》源地址（32比特）					发送端的IP地址
				》目标地址（32比特）				接收端的IP地址
				》协议（8比特）						有效负载类型（下一个更高层类型），如TCP、UDP或ICMP
				》生存时间，又名TTL（8比特）		允许数据包存在的最长时间
				》服务类型（8比特）					可用于服务质量（QoS)目的
			鉴于互联网是一个网络的网络，区分网络和网络中的单台机器（主机）似乎很自然。 IP 地址范围被分配给网络，并在这些网络内分配给各个主机。
			如今，无类别域间路由（CIDR）【https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing 】是分配IP地址的唯一相关方法。CIDR格式由两部分组成：
				》第一部分表示网络地址。这看起来像一个普通的IP地址【如，10.0.0.0】
				》第二部分定义了地址范围内有多少位（以及IP地址）【如，/24】
			一个完整的CIDR范围示例如：10.0.0.0/24。这里前 24 位（或三个八位字节）代表网络，最后 8 位（总共 32 位减去网络的 24 位）是 256 个主机可用的 IP 地址 (28 )。 
			此 CIDR 范围中的第一个 IP 地址是 10.0.0.0，最后一个 IP 地址是 10.0.0.255。 严格来说，只有 10.0.0.1 到 10.0.0.254 地址可以分配给主机，因为 .0 和 .255 地址是为特殊用途而保留的。 
			此外，可以说网络掩码是 255.255.255.0，因为它是代表网络的前 24 位。
			如果想要进行 CIDR 范围计算，例如确定一个范围内有多少个 IP，可以使用以下方法：
				》在线工具：https://cidr.xyz/ 和 https://www.ipaddressguide.com/cidr
				》命令行工具：mapcidr【https://github.com/projectdiscovery/mapcidr 】 和cidrchk【https://github.com/mhausenblas/cidrchk 】
			一些值得注意的保留IPv4地址：
				》127.0.0.0			该子网是为本地地址保留的，其中最突出的一个是环回地址 127.0.0.1。
				》169.254.0.0/16	这些是链路本地地址，这意味着发送到那里的数据包不应转发到网络的其他部分。一些云供应商（如Amazon Web Services）将其用于特殊服务（元数据）。
				》224.0.0.0/24		这些是为多播【multicast】保留的
			RFC 1918 定义私有IP范围。私有IP范围意味着其中的IP地址在公共互联网上不可路由；因此，在内部分配它们是安全的：
				》10.0.0.0/8		10.0.0.0 ~ 10.255.255.255
				》172.16.0.0/12		172.16.0.0 ~ 172.31.255.255
				》192.168.0.0/16	192.168.0.0 ~ 192.168.255.255
			另一个有趣的 IPv4 地址是 0.0.0.0。 它是一个不可路由的地址，根据上下文具有不同的用例和不同的含义，但从服务器的角度来看，最重要的是 0.0.0.0 指的是机器中存在的所有 IPv4 地址。 
			这是一个很好的方式来表示“监听所有可用的 IP 地址”作为源，直到它变成已知的 IP。
			查询机器中与IP相关的人内容，如：
				# ip addr show
				1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
				    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
				    inet 127.0.0.1/8 scope host lo
				       valid_lft forever preferred_lft forever
				    inet6 ::1/128 scope host 
				       valid_lft forever preferred_lft forever
				2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
				    link/ether 00:0c:29:98:3c:14 brd ff:ff:ff:ff:ff:ff
				    altname enp2s1
				    inet 192.168.3.10/32 scope global noprefixroute ens33
				       valid_lft forever preferred_lft forever
				    inet6 fe80::20c:29ff:fe98:3c14/64 scope link noprefixroute 
				       valid_lft forever preferred_lft forever
			IPv4地址已经耗尽。IPv6可以解决地址耗尽问题。IPv4地址耗尽解决方法【https://networkengineering.stackexchange.com/questions/53935/why-are-ipv4-addresses-running-out 】
		②	IPv6
			互联网协议版本6（IPv6）是一个128位数字，用于标识TCP/IP通信中的端点。这意味着通过IPv6，可以分配大约10^38台单独的机器（设备）。与IPv4不同，IPv6使用十六进制表示【八组、每组16位，用冒号分隔】。
			缩短 IPv6 地址有一些规则，例如删除前导零或通过用两个冒号 (::) 替换连续的零部分来压缩它们。 例如，IPv6 环回地址可以缩写为 ::1（IPv4 变体为 127.0.0.1）。
			与IPv4一样，IPv6也有许多特殊和保留的地址；见APNIC的IPv6地址类型列表【https://www.apnic.net/get-ip/faqs/what-is-an-ip-address/ipv6-address-types/ 】。
			需要注意的是，IPv4 和 IPv6 不兼容。 这意味着从边缘设备（如手机）到路由器再到服务器软件，每个网络参与者都需要内置 IPv6 支持。
		③	互联网控制信息协议【ICMP】
			RFC 792 定义了Internet Control Message Protocol（ICMP），用于较低级别的组件发送错误消息和可用性等操作信息。
			可以通过使用 ping 测试网站的可达性了解ICMP的实际情况，如：
				# ping 163.com
				64 比特，来自 163.com (123.58.180.8): icmp_seq=1 ttl=54 时间=29.9 毫秒
				64 比特，来自 163.com (123.58.180.8): icmp_seq=2 ttl=54 时间=29.2 毫秒
				64 比特，来自 163.com (123.58.180.8): icmp_seq=3 ttl=54 时间=29.6 毫秒
				64 比特，来自 163.com (123.58.180.8): icmp_seq=4 ttl=54 时间=29.8 毫秒
				64 比特，来自 163.com (123.58.180.8): icmp_seq=5 ttl=54 时间=29.3 毫秒
			或者，可以使用gping 同时 ping 多个目标并咋爱命令行上绘制图表。
			注意，有一个适用于 IPv6 的等效工具：恰当地命名为 ping6。
		④	路由【routing】
			Linux中网络堆栈的一部分与路由有关，即根据每个数据包决定将数据包发送到何处。目标可以是同一台计算机桑的进程，也可以是不同计算机上的IP地址。
			iptables 是一个广泛使用的工具，允许操作路由表——如，在某些条件下重新路由数据包或实施防火墙——使用 netfilter 拦截和操作数据包。
			使用 route 可以查询和显示路由信息，如：
				# route -n
				Kernel IP routing table
				Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
				0.0.0.0         192.168.3.1     0.0.0.0         UG    100    0        0 ens33
				0.0.0.0         192.168.229.1   0.0.0.0         UG    101    0        0 ens36
				192.168.3.1     0.0.0.0         255.255.255.255 UH    100    0        0 ens33
				192.168.229.0   0.0.0.0         255.255.255.0   U     101    0        0 ens36
				》字段说明：
					Destination		目标IP地址；0.0.0.0 表示未指定或未知，可能会将其发送到网关。
					Gateway			网关地址，用于不在同一网络上的数据包
					Genmask			使用的子网掩码
					Flags			UG意味着网络是开着的，且是网关
					Iface			数据包将使用的网络接口
			更现代的方法是使用ip命令，如：
				# ip route
				default via 192.168.3.1 dev ens33 proto static metric 100 
				default via 192.168.229.1 dev ens36 proto static metric 101 
				192.168.3.1 dev ens33 proto static scope link metric 100 
				192.168.229.0/24 dev ens36 proto kernel scope link src 192.168.229.128 metric 101 
			可以按如下方式检查连接性，如：
				# traceroute 163.com
	Ⅲ	传输层
		在这一层中，一切都与端点之间通信的性质有关。有面向连接的协议和无连接的协议。可靠性、服务质量和有序交付可能是一个问题。
		现代协议设计（如HTTP/3）尝试着结合功能，如将TCP的部分内容移至更高级别的协议中。
		①	端口
			这一层的一个核心概念是端口。无论该层使用哪种协议，每种协议都需要端口。端口是一个唯一的16位数字，用于标识IP地址上可用的服务。端口区分如下：
				》知名端口（0 ~ 1023）
					这些用于守护进程，如SSH服务器或Web服务器。使用（绑定）其中之一需要提升权限。
				》注册端口（1024 ~ 49151）
					这些端口由互联网号码分配机构（IANA）通过公开记录的流程进行管理。
				》临时端口（49152 ~ 65535）
					无法注册。它们可用于自动分配临时端口（如应用程序连接到Web服务器，则它本身需要一个端口，作为通信的另一个端点）以及专用端口（如公司内部端口）服务。
					可以在 /etc/services 中查看端口和映射，此外，如果不确定，可能需要查阅 TCP 和 UDP 端口号的完整列表【https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers 】。
			如果想查看本地计算机上正在使用的内容，可使用如下命令：
				# nmap -A localhost
				Starting Nmap 7.92 ( https://nmap.org ) at 2023-12-24 06:03 CST
				Nmap scan report for localhost (127.0.0.1)
				Host is up (0.00014s latency).
				Other addresses for localhost (not scanned): ::1
				Not shown: 999 closed tcp ports (reset)
				PORT   STATE SERVICE VERSION
				22/tcp open  ssh     OpenSSH 8.7 (protocol 2.0)
				| ssh-hostkey: 
				|   256 99:75:34:76:84:b5:f3:10:cb:29:dc:18:89:90:46:48 (ECDSA)
				|_  256 10:ec:4f:69:40:48:da:2c:2b:50:ee:f9:26:aa:14:40 (ED25519)
				No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).
				TCP/IP fingerprint:
				OS:SCAN(V=7.92%E=4%D=12/24%OT=22%CT=1%CU=40046%PV=N%DS=0%DC=L%G=Y%TM=
				...
		②	传输控制协议【TCP】
			传输控制协议（TCP）是一种面向连接的传输层协议，许多更高级别的协议都使用该协议，包括HTTP和SSH。它是一种基于会话的协议，可保证数据包按顺序传送并支持在发生错误时重传。
			按照RFC793和相关IETF规范中的定义，TCP标头具有以下最重要的字段：
				》Source Port（16比特）
					发送端使用的端口
				》Destination Port（16比特）
					接收端使用的端口
				》Sequence number（32比特）
					用于管理按顺序发送
				》Acknowledgement number（32比特）
					该数字以及SYN和ACK标志是所谓的TCP/IP三次握手【https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment 】的核心
				》Flags（9比特）
					最重要，包含 SYN（同步）和ACK（确认）比特。
				》Window（16比特）
					接收窗口大小
				》Checksum（16比特）
					TCP头的校验和，用于差错检查
				》Data
					传输的有效负载
			TCP跟踪连接从建立到终止的状态，发送方和接收方都必须协商某些事项，从发送多少数据（TCP窗口大小）到QoS。
			从安全角度来看，TCP没有任何防御机制。换句话说，有效负载以纯文本形式发送，发送方和接收方之间的任何人（并且设计由很多跳【hops】）都可以检查数据包；可通过 Wireshark 和 tshark 检查有效负载的详细信息。
			要启用消息加密，需要使用传输层安全（TLS）协议。
		③	用户数据报协议【UDP】
			用户数据报协议【UDP】是一种无连接传输层协议，允许发送消息（在UDP中称为数据报），而无需进行通信设置（如TCP通过三次握手建立连接）。但它确实支持数据报校验和以确保完整性。
			有许多使用UDP的应用程序级协议，如NTP和DHCP以及DNS。
			RFC768定义了UDP报头格式。它最重要的字段如下：
				》Source port（16比特）
					发送端使用的端口；可选，如果没有，使用0
				》Destination port（16比特）
					接收端使用的端口
				》Length（16比特）
					UDP头部和数据的总长度
				》Checksum（16比特）
					可选地用于差错检查
				》Data
					数据报的有效负载
			UDP 是一个非常简单的协议，需要在其之上工作的更高级别协议来处理TCP自行处理的许多事情。另一方面，UDP的开销非常小，并且可以实现高吞吐量。使用起来非常简单；见 UDP 手册页【https://linux.die.net/man/7/udp 】
		④	套接字【Sockets】
			Linux 提供的高级通信接口是套接字【https://www.man7.org/linux/man-pages/man7/socket.7.html 】。将它们视为通信中的端点，具有独特的标识：由TCP或UDP端口和IP地址组成的元组。
			如果想开发与网络相关的工具或应用程序，可能只会使用套接字，但至少应该知道如何查询它们。 例如，在 Docker 守护进程的上下文中，至少需要了解套接字所需的权限。
			可以shiyong ss【https://www.man7.org/linux/man-pages/man8/ss.8.html 】 命令来显示socket相关信息。如：
				# ss -s
				Total: 128
				TCP:   4 (estab 2, closed 0, orphaned 0, timewait 0)
				
				Transport Total     IP        IPv6
				RAW       2         0         2        
				UDP       0         0         0        
				TCP       4         3         1        
				INET      6         3         3        
				FRAG      0         0         0  
			查看UDP套接字【使用 -u 选项】。如：
				# ss -ulp
				State                  Recv-Q                  Send-Q                               Local Address:Port                                Peer Address:Port                 Process                                     
				UNCONN                 0                       0                                        0.0.0.0:domain                                     0.0.0.0:*                     users:(("dnsmasq",pid=1575,fd=6))                 			UNCONN                 0                       0                                        0.0.0.0:bootps                                     0.0.0.0:*                     users:(("dnsmasq",pid=1575,fd=4))                 			UNCONN                 0                       0                                           [::]:domain                                        [::]:*                     users:(("dnsmasq",pid=1575,fd=8)) 
			》说明：
				-u	限制仅UDP套接字
				-l	选择正在监听的套接字
				-p	显示进程信息
			如果要查看套接字和进程，还可以使用另一个工具【lsof】。如：
				# lsof -c dnsmasq -i udp | head -5
				COMMAND  PID    USER   FD      TYPE DEVICE SIZE/OFF     NODE NAME
				dnsmasq 1590 dnsmasq  cwd       DIR  253,0      250      128 /
				dnsmasq 1590 dnsmasq  rtd       DIR  253,0      250      128 /
				dnsmasq 1590 dnsmasq  txt       REG  253,0   434528 34295227 /usr/sbin/dnsmasq
				dnsmasq 1590 dnsmasq  mem       REG  253,0    53416 34313250 /usr/lib64/libnss_sss.so.2
			》说明：
				-c	按名称选择特定进程
				-i	限制协议类型【如，udp】
3、DNS
	无论是IPv4，还是IPv6，都面临两个挑战：名称比数字更好记、IP地址经常发生变化。因此，简而言之，IP 地址很难记住并且可以更改，而名称（服务器或服务的名称）保持不变。
	解决这个问题的方法是通过 /etc/hosts 在本地（在单台机器的上下文中）维护名称和 IP 地址之间的映射。 网络信息中心 (NIC) 将通过 FTP 与所有参与的主机共享一个名为 HOSTS.TXT 的文件。
	很快人们就发现这种集中式方法无法跟上互联网的发展，于是在 20 世纪 80 年代初，设计了分布式系统。DNS 是互联网上主机和服务的全球性分层命名系统。 虽然有许多相关的 RFC，但最初的 RFC 1034 及其通过 RFC 1035 的实现指南仍然有效。
	DNS使用许多术语，但主要概念如下：
		》Domain name space【域名空间】
			树形结构，使用【.】作为根，每个树节点和叶子包含有关某个空间的信息。从叶子到根的路径上的标签（最大长度为63字节）就是完全限定域名（FQDN）。如，demo.mhausenblas.info，是具有顶级域【.info】的FQDN。
			注意，最右边的【.】（根）通常被省略。
		》Resource records【资源记录】
			域名空间的节点或叶子中的负载。
		》Name servers【名称服务器】
			保存有关域树形结构的信息的服务器程序。如果名称服务器拥有有关空间的完整信息，则称为权威名称服务器。权威信息按区域组织。
		》Resolvers【解析器】
			从名称服务器中提取信息以响应客户端请求的程序。它们是机器本地，并且没有为解析器和客户端之间的交互定义明确的协议。通常有支持解析DNS的库调用。
								Local host					     |	Foreign
					 ——	queries ——→					—— Queries ————>					
				User				Resolver			         |	Foreign name server
					 ←——responses——	  ⬆  |          ←——Responses—|——
								  缓存|	 |引用                   |
									  |	 ⬇						 |
								 Shared database                 |
									  ⬆	 |						 |
								  引用|	 |引用					 |
									  |  ⬇			—— Responses———→
                 Master files ——→  Name server					 |  Foreign resolver
								   	  ↑  |			←—— Queries —|——
								      |  |                       |
									  |	 |						 |
                                      |  |___Maintenance queries-|—→			
									  |							 |  Foreign name server    
									  |_____Maintenance response-|——
	这是DNS系统的完整设置，包括用户程序、解析器和名称服务器【如，RFC1035所述】。在查询过程中，解析器从以下位置开始迭代查询权威名称服务器（NS）：根，或如果支持的化，使用递归查询，其中NS代表解析器查询其它查询。
	》补充：
		尽管它们仍然存在，但通常不会在现代系统中使用 /etc/resolv.conf 中的DNS解析器配置，尤其是在部署DHCP时。
	DNS是一个分层命名系统，其根部有13个根服务器，用于管理顶级域的记录。根目录正下方是顶级域（TLD）：
		①	Infrastructure top-level domain【基础设施顶级域名】
			由IANA代表IETF管理，包括 example 和 localhost。
		②	Generic top-level domains（gTLD）【通用顶级域名】
			通用顶级域名由三个或以上字符，如 .org 或 .com
		③	Country-code top-level domains（ccTLD）【国家代码顶级域名】
			用于分配了两个字母ISO 国家/地区代码【https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2 】的国家或地区
		④	Sponsored top-level domains（sTLD）【赞助顶级域名】
			用于指定和执行限制使用TLD资格的规则的私人机构或组织，如 .aero 和 .gov
	Ⅰ	DNS 记录
		名称服务器管理捕获类型、有效负载和其他字段的记录，包括生存时间（TTL）、记录应被丢弃的时间段等。可以将FQDN视为节点的地址，将资源记录（RR）视为有效负载，即节点中的数据。
		DNS具有多种记录类型【https://en.wikipedia.org/wiki/List_of_DNS_record_types 】，重要的记录类型如下：
			》A 记录（RFC 1035）和 AAAA 记录（RFC 3596）
				IPv4 和 IPv6 地址记录；通常用于将主机名映射到主机的IP地址。
			》CNAME 记录（RFC 1035）
				名称服务器记录委托DNS区域使用权威名称服务器
			》PTR 记录（RFC 1035）
				用于执行反向DNS查找的指针记录；与A记录相反
			》SRV 记录（RFC 2782）
				服务定位器记录。它们是一种通用的发现机制，而不是硬编码的（如传统上用于邮件交换的 MX 记录类型的情况）。
			》TXT 记录（RFC 1035）
				文字记录。这些最初适用于任意人类可读的文本，现在这些记录通常在与安全相关的DNS扩展的上下文中包含机器可读的数据。
			还有以星号（*）开头的通配符记录【如，*.mhausenblas.info】。
		DNS记录以文本形式表示在区域文件【https://en.wikipedia.org/wiki/Zone_file 】中，名称服务器读入该区域文件并使其成为其数据库的一部分。示例如下：
			$ORIGIN example.com.															# 该区域文件在命名空间中的开头
			$TTL 3600																		# 所有未定义自己的TTL的RR的默认过期时间（单位：秒）
			@			SOA nse.example.com. nsmaster.example.com. (
								1234567890 ; serial number
								21600      ; refresh after 6 hours
								3600       ; retry after 1 hour
								604800     ; expire after 1 week
								3600 )     ; minimum TTL of 1 hour
			example.com.   IN NS nse													    # 该域名的名称服务器		
			example.com.   IN MX 10 mail.example.com.										# 该域名的邮件服务器
			example.com.   IN A     1.2.3.4													# 该域名的IPv地址
			nse            IN A     5.6.7.8													# 名称服务器的IPv4地址
			www            IN CNAME example.com.											# 使 www.example.com 成为该域【example.com】的别名
			mail           IN A     9.0.0.9													# 邮件服务器的IPv4地址
	Ⅱ	DNS 查询
		可以使用 host 命令查询 本地（和全局）名称，将其解析为IP地址，反之依然，如：
			# host -a localhost				# 查询本地IP地址
			# host miggi.info				# 查询 FQDN
			# host 185.199.110.153			# 通过IP地址反向查询 FQDN
		查询DNS记录的更强大方法是使用 dig 命令，如：
			# dig 163.com
			
			; <<>> DiG 9.16.23-RH <<>> 163.com
			;; global options: +cmd
			;; Got answer:
			;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 40578
			;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 7, ADDITIONAL: 8
			
			;; QUESTION SECTION:
			;163.com.                       IN      A
			
			;; ANSWER SECTION:																# DNS A 记录
			163.com.                600     IN      A       123.58.180.8
			163.com.                600     IN      A       123.58.180.7
			
			;; AUTHORITY SECTION:															# 权威的域名服务器
			163.com.                402     IN      NS      ns5.nease.net.
			163.com.                402     IN      NS      ns2.166.com.
			163.com.                402     IN      NS      ns3.nease.net.
			163.com.                402     IN      NS      ns8.166.com.
			163.com.                402     IN      NS      ns1.nease.net.
			163.com.                402     IN      NS      ns6.nease.net.
			163.com.                402     IN      NS      ns4.nease.net.
			
			;; ADDITIONAL SECTION:
			ns1.nease.net.          479     IN      A       42.186.35.222
			ns5.nease.net.          232     IN      A       103.71.201.3
			ns2.166.com.            354     IN      A       103.71.201.3
			ns3.nease.net.          222     IN      A       103.72.12.150
			ns8.166.com.            539     IN      A       18.182.82.158
			ns8.166.com.            539     IN      A       44.228.163.69
			ns4.nease.net.          117     IN      A       103.72.12.151
			ns6.nease.net.          52      IN      A       54.228.156.72
			
			;; Query time: 6 msec
			;; SERVER: 192.168.3.1#53(192.168.3.1)
			;; WHEN: Sun Dec 24 20:46:43 CST 2023
			;; MSG SIZE  rcvd: 324
		除了 dig 命令之外，还有其他可用命令，特别是 dog 和 nslookup。
		》补充：
			DNS是一个具有许多移动部件的分布式数据库。在调试与DNS相关的问题时，考虑记录的TTL，以及存在许多缓存，从应用程序和解析器的本地缓存，再到和名称服务器之间的任何缓存。
		SRV记录类型，并且它充当通用发现机制。因此，社区没有在RFC中为新服务定义新记录类型，而是提出了一种通用方法来解决任何即将退出的服务类型。RFC 2782中的描述的此机制解释了如何使用SRV记录通过DNS传达服务的IP地址和端口。
		查看有哪些聊天服务（具体来说，XMPP）可用：
			# dig +short _xmpp-client._tcp.gmail.com. SRV
		使用带有短选项的 dig 命令可仅显示相关答案的部分。_xmpp-client._tcp 部分是 RFC 2782 规定的格式，该命令末尾的 SRV 指定感兴趣的记录类型。
4、应用层网络
	Ⅰ	Web
		web 具有三个核心组件：
			》Uniform Resource Locator是（URL）【统一资源定位器】
				最初按照 RFC 1738 以及一些更新和相关 RFC。 URL 定义了网络上资源的身份和位置。 资源可以是静态页面或动态生成内容的进程。
			》Hypertext Transfer Protocol（HTTP）【超文本传输协议】
				HTTP定义了应用程序协议以及如何与通过URL提供的内容进行交互。根据 v1.1 的RFC 2616，但也有更现代的版本，如 RFC 7540中定义的HTTP/2和HTTP/3草案。HTTP 的核心概念是：
				①	HTTP 方法【】
					包括用于读取操作的GET和用于写入操作的POST，这些定义了类似CRUD的接口。
				②	资源名
					这决定了如何形成URL。
				③	HTTP 状态码
					2xx范围表示成功，3xx表示重定向，4xx表示客户端错误，5xx表示服务器错误
			》Hyper Text Markup language（HTML）
				HTML 最初是 W3C 规范，现在是通过 WHATWG 提供的现行标准。 超文本标记允许定义页面元素，例如标题或输入。
		URI（URL的通用版本）是如何构造的（根据RFC3986)以及它如何映射到HTTP URL的，如下所示：
				michaelh:12345678@http://example.com:4242/this/is/the/way?orisit=really#anther
				\_____/  \______/ \__/  \_______________/ \_____________/ \__________/ \____/
				 user      pwd    scheme  authority           path           query     fragment
		URI的组成如下：
			①	用户名和密码（可选）
				这些组件最初用于基本身份验证，不应再使用。相反，对于HTTP，应该使用适当的身份验证机制以及HTTPS来进行线路加密。
			②	scheme
				指定URL方案，是定义其含义的IETF规范。对于HTTP，该方案为http，它实际上是HTTP规范系列，如RFC2616。
			③	authority
				分层命名部分。对于HTTP，这是：
					》Hostname		要么是一个DNS FQDN，要么是一个IP地址。
					》Port			默认为80
			④	path
				用于进一步资源详细信息的特定于方案的部分。
			⑤	query 和 fragement（可选）
				前者出现在？之后用于非分层数据（如，表达标签或表单数据），后者出现在#后面，表示辅助资源（在HTML的上下文中，这可能是一个section）。
		可以通过 curl 命令（一个强大且流行的工具来于任何类型的URL交互）获取web 服务器的内容。curl 选项说明如下：
				选项	长格式					描述和用法
				-v		--verbose				详细输出，用于调试
				-s		--silent				安静模式：不显示进度表或错误消息
				-L		--location				运行页面重定向
				-o		--output				默认情况下，内容会输出到标准输出；如果想直接将其存储在文件中，通过此选项指定
				-m		--max-time				等待操作执行的最长晒你（单位：秒）
				-I		--head					仅获取标头（注意：并非每个HTTP服务器都支持路径的HEAD方法）
				-k		--insecure				默认情况下，HTTPS调用经过验证。使用此选项可以忽略不可能的情况下的错误。
		如果 curl 不可用，还可以使用 wget，虽然比较有限，但对于简单的 HTTP 相关交互来说已经足够了。
	Ⅱ	Secure Shell
		Secure Shell (SSH) 是一种加密网络协议，用于在不安全的网络上安全地提供网络服务。 例如，作为 telnet 的替代品，您可以使用 ssh 登录远程计算机，并在（虚拟）计算机之间安全地移动数据。
		使用SSH登录远程主机，如：
			$ ssh \
				-i ~/.ssh/lml.pem \				# 使用身份文件，而不是密码。明确提供该文件是一种很好的做法。
				ec2-user@192.168.3.5 			
		一些常规SSH使用技巧：
			①	SSH 服务器应禁用密码认证【PasswordAuthentication】。这样会强制用户创建密钥对，并将公钥共享给服务端【将其添加到 ~/.ssh/authorized_keys文件】
			②	使用 ssh -tt 强制分配伪tty
			③	当ssh 到服务器时，使用 export TERM=xterm ，以防出现显示问题。
			④	为客户端的ssh 会话设置超时。以每个客户为基础【通常使用 ~/.ssh/config】，设置 ServerAliveInterval 和 ServerAliveCountMax 。
			⑤	如果遇到问题，并且已经排除了密钥的本地权限问题，那么可以尝试使用 -v 选项启动 ssh，提供有关幕后情况的详细信息（另外，尝试多个实例 v 的，例如 -vvv 以获得更细粒度的调试信息）。
		SSH 不仅供人类直接使用，而且还用作底层的构建块，例如在文件传输工具中。
	Ⅲ	文件传输
		涉及网络的一项非常常见的任务是传输文件。 可以从本地计算机到云中的服务器或从本地网络中的另一台计算机执行此操作。要在远程系统之间进行复制，可以使用scp【在SSH之上工作】。如：
			# scp copyme ec2-user@abc.com:/home/ec2-user/
		使用rsync同步文件比scp方便快捷得多。 在底层，rsync 默认使用 SSH。如：
			# rsync -avz ~/data mh9@:abc.com:
	Ⅳ	网络文件系统
		一种得到广泛支持和使用的通过网络从中央位置共享文件的方法是通过网络文件系统 (NFS)，该系统最初由 Sun Microsystems 在 20 世纪 80 年代初开发。 它根据 RFC 7530 和其他相关 IETF 规范进行了多次迭代，并且非常稳定。
		许多云提供商（例如 AWS 和 Azure）现在都提供 NFS 作为服务。 这是一种很好的方式，可以为需要大量存储空间的应用程序提供大量空间，其外观和感觉几乎就像本地附加存储一样。 
		然而，对于媒体应用程序，网络附加存储 (NAS) 【https://olinux.net/open-source-linux-nas-servers/ 】设置可能是更好的选择。
5、高级网络主题
	Ⅰ	whois
		whois【】是whois目录服务的客户端，可用于查找注册和用户信息。如，想找出ietf.org域背后的人（注意，可以想域注册商付费将该信息保密），可执行以下操作：
			# whois ietf.org
			Domain Name: ietf.org
			Registry Domain ID: 73d0271a0fc745c3b8b632a5032ae75a-LROR
			Registrar WHOIS Server: http://whois.cloudflare.com
			Registrar URL: http://www.cloudflare.com
			Updated Date: 2023-06-26T01:01:27Z
			Creation Date: 1995-03-11T05:00:00Z
			Registry Expiry Date: 2026-03-12T05:00:00Z
			Registrar: CloudFlare, Inc.
			Registrar IANA ID: 1910
			[...]
	Ⅱ	Dynamic Host Configuration Protocol【动态主机配置协议】
		动态主机配置协议 (DHCP) 是一种网络协议，可自动为主机分配 IP 地址。 这是一种客户端/服务器设置，无需手动配置网络设备。
		可以使用dhcpdump扫描DHCP数据包【本地网络中的设备需要加入】，如

	Ⅲ	Network Time Protocol【网络时间协议】
		网络时间协议 (NTP) 用于通过网络同步计算机的时钟。 例如，使用 ntpq 命令（一个标准 NTP 查询程序），可以进行显式时间服务器查询，如下所示：
			# ntpq -p
	Ⅳ	Wireshark 和 tshark
		如果想要进行低级网络流量分析（即想要准确查看堆栈中的数据包），可以使用命令行工具 tshark 或其基于GUI的版本 wireshark 。如：
			# tshark -i ens33 tcp
	Ⅴ	其他高级工具
		可能会发现许多有用的高级网络相关工具，包括但不限于以下工具：
			socat
				建立两个双向字节流并启用端点之间的数据传输
			geoiplookup
				允许映射一个IP到地理区域
			Tunnels
				VPN 和其他站点到站点网络解决方案的易于使用的替代方案。 通过 inlets 等工具启用。
扩展
	Ⅰ	TCP/IP stack
		Understanding Linux Network Internals by Christian Benvenuti (O’Reilly) 		【https://www.oreilly.com/library/view/understanding-linux-network/0596002556/ 】
		“A Protocol for Packet Network Intercommunication”								【https://www.cs.princeton.edu/courses/archive/fall06/cos561/papers/cerf74.pdf 】
		DHCP server setup webpage														【https://wiki.debian.org/DHCP_Server 】
		“Hello IPv6: A Minimal Tutorial for IPv4 Users”									【https://metebalci.com/blog/hello-ipv6/ 】
		“Understanding IPv6—7 Part Series”												【https://www.networkingwithfish.com/understanding-ipv6-7-part-series/ 】
		Collection of IPv6 articles by Johannes Weber									【https://weberblog.net/ipv6/ 】
		Iljitsch van Beijnum’s BGP Expert website										【https://www.bgpexpert.com/ 】
		“Everything You Ever Wanted to Know About UDP Sockets but Were Afraid to Ask”	【https://blog.cloudflare.com/everything-you-ever-wanted-to-know-about-udp-sockets-but-were-afraid-to-ask-part-1/ 】
	Ⅲ	DNS
		“An Introduction to DNS Terminology, Components, and Concepts”					【https://www.digitalocean.com/community/tutorials/an-introduction-to-dns-terminology-components-and-concepts 】
		“How to Install and Configure DNS Server in Linux”								【https://www.thegeekstuff.com/2014/01/install-dns-server/ 】
		“Anatomy of a Linux DNS Lookup”													【https://zwischenzugs.com/2018/06/08/anatomy-of-a-linux-dns-lookup-part-i/ 】
		“TLDs—Putting the .fun in the Top of the DNS”									【https://www.netmeister.org/blog/tlds.html 】
	Ⅳ	Application layer and advanced networking
		“SSH Tunneling Explained”														【https://goteleport.com/blog/ssh-tunneling-explained/ 】
		Everything curl																	【https://curl.se/book.html 】
		“What Is DHCP and How to Configure DHCP Server in Linux”						【https://linuxconfig.org/what-is-dhcp-and-how-to-configure-dhcp-server-in-linux 】
		“How to Install and Configure Linux NTP Server and Client”						【https://www.thegeekstuff.com/2014/06/linux-ntp-server-client/ 】
		NFS wiki																		【https://linux-nfs.org/wiki/index.php/Main_Page 【
		“Use Wireshark at the Linux Command Line with TShark”							【https://opensource.com/article/20/1/wireshark-linux-tshark ]
		“Getting Started with socat”													【https://www.redhat.com/sysadmin/getting-started-socat 】
		“Geomapping Network Traffic”													【https://xn--blgg-hra.no/2015/10/geomapping-network-traffic/ 】
	

Observability
	有关可观察性的最佳视觉概述可能来自表演大师布伦丹·格雷格（Brendan Gregg）。在他的Linux Performance 站点【https://www.brendangregg.com/linuxperf.html 】，有丰富的可用移动部件和工具。		
1、基础
	Ⅰ	可观测性策略
		在可观察性背景下，一种广泛建立的策略是OODA循环（观察-定向-决定-行动）。它提供了一种结构化的方法来测试基于观察到的数据的假设并对其采取行动——也就是说，一种从信号中获得可操作的见解的方法。
		例如，假设应用程序速度很慢。进一步假设有多种可能的原因（内存不足、CPU 周期太少、网络 I/O 不足等）。首先，希望能够测量每种资源的消耗。 然后，将单独更改每个资源分配（保持其他资源分配不变）并衡量结果。
		为应用程序提供更多 RAM 后性能是否会提高？ 如果是这样，可能已经找到原因了。如果没有，将继续使用不同的资源，始终测量消耗并尝试将观察到的对情况的影响联系起来。
	Ⅱ	术语
		可观测性空间中有一系列术语，但并非所有术语都有正式定义。 此外，如果您查看的是单台计算机或处于网络（分布式）设置中，含义可能会略有不同：
		①	可观测性【Observerability】
			通过测量外部信息来评估系统（如Linux）的内部状态，通常是为了对其采取行动。如，如果注意到系统反应缓慢，并测量了可用的主内存量，可能会发现某个特定的应用程序占用了全部内存，可能会决定终止它以纠正这种情况。
		②	信号类型【Signal Type】
			表示和发出有关系统状态的信息的方式不同，可以通过符号方式（有效负载是文本，如日志）或数字（如指标）或其组合。
		③	源【Sources】
			生成可能不同类型的信号。来源可以是Linux操作系统或应用程序。
		④	目标【Destination】
			消费、存储和进一步处理信号的地方。将公开用户界面（GUI、TUI或CLI）的目标成为前端。
		⑤	遥测【Telemetry】
			从源提取信号并将信号传输（或路由、运输）到目的地的过程，通常使用代理来收集和发送信号。
	Ⅲ	信号类型
		信号是传达系统状态以进行进一步处理或解释的方式。 总的来说，区分文本有效负载（最适合人类搜索和解释）和数字有效负载（对机器和处理后的人类都有好处）。三种基本且常见的信号类型是：日志、指标和跟踪。
		①	日志【logs】
			日志是每个系统在某种程度上都会生成的基本信号类型。 日志是具有文本负载的离散事件，供人类使用。 通常，这些事件带有时间戳。 
			理想情况下，日志的结构应为日志消息的每个部分定义明确的含义。 该含义可能通过正式模式来表达，以便可以自动执行验证。
			虽然自动化日志内容很困难（鉴于其文本性质），但日志对人类仍然非常有用，因此它们可能会在一段时间内保持主导信号类型，日志是最重要的信号类型（就我们的考虑而言）。
		②	Metrics【指标】
			指标（通常是定期）采样的数值数据点，形成时间序列。各个数据点可以具有维度或标识元数据形式的附加上下文。通常，不会直接使用原始指标；相反，可以使用某种聚合或图形表示，或者在满足特定条件时收到通知。
			指标对于操作任务和故障排除都非常有用，可以回答诸如应用程序完成了多少事务或某个操作花费了多长时间（在过去 X 分钟内）之类的问题。
			指标类型如下：
				》Counter		计数器的值只能增加（除了将计数器重置为零之外）。 计数器指标的一个示例是一段时间内由服务处理的请求总数或通过接口发送的字节数。
				》Guages		仪表值可以上升或下降。例如，可以测量当前可用的总体主内存或正在运行的进程数。	
				》Histograms	构建值分布的复杂方法。使用存储桶【buckets】，直方图可以评估数据的整体结构。它们还可用于做出灵活的陈述（如50%或90%的值落入某个范围）
		③	Traces【跟踪】
			跟踪是运行时信息的动态集合（如，有关进程使用的系统调用的信息，或内核中针对给定原因的事件序列的信息）。跟踪通常不仅用于调试，还用于性能评估。
2、日志
	日志是具有文本有效负载的离散事件（集合），并针对人类使用进行了优化。
		①	Discrete events【离散事件】
			考虑代码库上下文中的离散事件。希望使用（原子）日志项来共享有关代码中发生的情况的信息。例如，发出一条日志行，表明数据库连接已成功建立。另一个日志项可能是由于文件丢失而标记错误。
			保持日志消息的范围小而具体，以便使用该消息的人更容易找到代码中的相应位置。
		②	文本负载
			日志消息的有效负载具有文本性质。
	从结构上看，总体而言，日志包括以下内容：
		①	日志项、消息或行的集合		捕获有关离散事件的信息。
		②	元数据或上下文				可以以每条消息为基础，也可以以全局范围（如整个日志文件）为基础
		③	如何解释单个日志消息的格式	定义日志的部分和含义。如，面向行、空格分隔的消息或JSON模式
	常用日志格式如下：
		格式						说明
		事件格式				由ArcSight开发； 用于设备、安全用例
		日志格式				用于Web服务器；
		Graylog扩展日志格式		由Graylog开发；改进系统日志【Syslog】
		Syslog					用于操作系统，应用程序，设备
		嵌入指标格式			由Amazon开发（日志和指标）
	为了避免日志开销（实现快速查找和占用空间小），可以使用日志轮转【如，通过logrotate】。称为数据温度的高级概念也可能很有用，可以将较旧的日志文件移动到更便宜且速度较慢的存储（附加磁盘、S3 存储桶、Glacier）。
	为了表明日志项的重要性或预期目标使用者，日志通常会定义级别（例如，用于开发的 DEBUG、用于正常状态的 INFO 或用于可能需要人工干预的意外情况的 ERROR）。
	Linux的中央日志目录是/var/log。实时使用日志（即发生时）的一种常见模式是跟踪日志； 也就是说，会在添加新日志行时观察日志的末尾。如：
		# tail -f /var/log/syslog
	如果想查看某个进程的日志输出，同时将其存储在文件中，可使用 tee 命令，如：
		# someprocess | tee -a some.log
	使用 -a 选项追加日志到日志文件，否则将被截断。
	Ⅰ	syslog
		syslog是一系列源的日志记录标准，从内核到守护进程再到用户空间。他植根于网络环境，如今该协议包含RFC 5424中定义的文本格式以及部署场景和安全注意事项。
		RFC 5424中定义的syslog格式具有以下标头字段（最常用的是TS和HN）：
			①	PRI		设施/严重性【facility/severity】消息
			②	VER		syslog协议数字（通常被忽略，因为它只能是1）
			③	TS		包含使用ISO8601格式生成消息的时间按
			④	HN		标识发送消息的机器
			⑤	APP		标识发送消息的应用程序（或设备）
			⑥	PID		标识发送消息的进程
			⑦	MID		可选的消息ID
		该格式还包括结构化数据，它是结构化（基于键/值）列表中的有效负载，其中每个元素都以 [] 为界。
		通常，会使用syslogd二进制文件来进行日志管理。随着时间的推移，应该注意其他可用的选项：
			①	syslog-ng
				一个增强的日志守护程序，可以将其用作 syslogd 的直接替代品，此外还支持 TLS、基于内容的过滤以及登录到 PostgreSQL 和 MongoDB 等数据库。
			②	rsyslog
				扩展了 syslog 协议，也可以与 systemd 一起使用。
		syslog 系列协议和工具仍然存在并广泛使用。 随着 systemd 成为 init 系统事实上的标准并在每个主要 Linux 发行版中使用，然而，有一种新的日志记录方法： systemd 日志。
	Ⅱ	journalctl
		systemd生态系统中负责日志管理的一个组件是journalctl。与syslog和迄今为止使用其他系统相比，journalctl使用二进制格式来存储日志项。这允许更快的访问和更好的存储空间。
		如果在不带参数的情况下启动journalctl，，它会将自己呈现为所有日志的交互式分页器。要限制时间范围，可以使用如下命令，如：
			$ journalctl --since "3 hours ago"
			$ journalctl --since "2021-09-26 15:30:00" --until "2021-09-26 18:30:00"
		可以将输出限制为特定的systemd 单元【如，abc.service】。如：
			$ journalctl -u abc.service
		journalctl有一种强大的方法来格式化日志项的输出。使用--output（或-o）参数，可以针对特定用例优化输出。如：
			cat		短格式，没有时间戳或源
			short	默认，模拟syslog输出
			json	每行一个JSON格式的条目（用于自动化）
		可以使用 -f 获得与 tail -f 相同的跟踪日志形式。如：
			$ journalctl -f
3、监控
	监控是出于多种原因捕获系统和应用程序指标。在监控过程中最常执行的两类活动如下：
		》跟踪一个或多个指标（随着时间的推移）
		》根据条件发出警报
	使用 uptime 命令显示一些基本指标【如系统运行的时间、内存使用情况等】：
		# uptime
		 23:02:05 up  8:19,  2 users,  load average: 0.03, 0.01, 0.06
	使用 free 命令监控一些基本的内存利用率，如：
		# free -h
    		           total        used        free      shared  buff/cache   available
		Mem:           3.5Gi       505Mi       3.0Gi       9.0Mi       298Mi       3.0Gi
		Swap:          2.0Gi          0B       2.0Gi
	查看内存使用情况的一种更复杂的方法是使用 vmstat（virtual memory stats）命令，如【1 表示每秒打印一个新的摘要行】：
		# vmstat 1
		procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
		 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
		 1  0      0 3112368   2708 303108    0    0     4     1   72   89  0  1 99  0  0
		 0  0      0 3112368   2708 303148    0    0     0     0  166  182  0  0 99  1  0
		 0  0      0 3112368   2708 303148    0    0     0     0  135  176  0  1 99  0  0
		》输出说明：
			r		表示正在运行或等待CPU的进程数（应小于或等于拥有的CPU数）
			free	可用内存（单位：KB）
			in		每秒中断数
			cs		每秒上下文切换的次数
			us ~ st	跨用户空间、内核、空闲等的总CPU时间的百分比
	要查看某个操作需要多长时间，可以使用 time 命令。如：
		# time (ls -R /etc 2&> /dev/null)

		real    0m0.004s					# 花费的总（wall clock）时间（除了性能之外没有什么用处）
		user    0m0.000s					# ls 本身在CPU（用户空间）上花费了多长时间）
		sys     0m0.004s					# ls等待Linux做某事的时间（内核空间）
	如果对操作花费的时间感兴趣，则取 user 和 sys 的总和是一个很好的近似值，并且两者的比率可以很好地了解它在哪里花费了大部分执行时间。
	Ⅰ	设备I/O和网络接口
		使用 iostat 可以监控I/O设备，如：
			# iostat -z --human
			Linux 5.14.0-352.el9.x86_64 (localhost.localdomain)     2023年12月25日  _x86_64_        (1 CPU)
			
			avg-cpu:  %user   %nice %system %iowait  %steal   %idle
			           0.0%    0.0%    1.0%    0.0%    0.0%   98.9%
			
			Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd
			dm-0              0.52        15.4k         9.5k         0.0k     471.6M     290.6M       0.0k
			dm-1              0.84         1.5k         2.0k         0.0k      44.7M      60.0M       0.0k
			sda               0.71        17.2k        11.5k         0.0k     525.5M     352.6M       0.0k
			sr0               0.00         0.1k         0.0k         0.0k       2.0M       0.0k       0.0k
			sr1               0.00         0.1k         0.0k         0.0k       2.0M       0.0k       0.0k
		》输出说明：
			tps		设备每秒的传输（I/O请求）数
			read	数据量
			wrtn	写入数据量
		使用 ss 命令的网络接口可以转储套接字统计信息。如【列出TCP和UDP套接字以及进程ID】：
			# ss -atup
			Netid            State             Recv-Q            Send-Q                           Local Address:Port                          Peer Address:Port              Process                                                
			udp              ESTAB             0                 0                            192.168.3.17%ens33:bootpc                         192.168.3.1:bootps             users:(("NetworkManager",pid=787,fd=26))             
			udp              UNCONN            0                 0                                     127.0.0.1:323                                0.0.0.0:*                  users:(("chronyd",pid=730,fd=5))                     
			udp              UNCONN            0                 0                                         [::1]:323                                   [::]:*                  users:(("chronyd",pid=730,fd=6))                     
			tcp              LISTEN            0                 5                                       0.0.0.0:irdmi                              0.0.0.0:*                  users:(("python3",pid=1464,fd=3))                   
			tcp              LISTEN            0                 128                                     0.0.0.0:ssh                                0.0.0.0:*                  users:(("sshd",pid=812,fd=3))                        
			tcp              ESTAB             0                 0                                  192.168.3.17:ssh                            192.168.3.4:60048              users:(("sshd",pid=1470,fd=4),("sshd",pid=1466,fd=4))
			tcp              ESTAB             0                 0                                  192.168.3.17:ssh                            192.168.3.4:58590              users:(("sshd",pid=992,fd=4),("sshd",pid=978,fd=4))  
			tcp              LISTEN            0                 128                                        [::]:ssh                                   [::]:*                  users:(("sshd",pid=812,fd=4))
		》选项说明：
			-a			选择所有【包含正在监听和没有正在监听的套接字】
			-t			选择TCP
			-u			选择UDP
			-p			显示使用套接字的进程
		》输出说明：
			Stat		套接字状态，其中ESTAB表示TCP连接已建立
			Recv-Q		排队等待接收的数据
			Send-Q		排队等待传输的数据
		收集和显示接口统计信息的一种过时方法是使用 netstat。例如，如果想要持续更新 TCP 和 UDP 视图，包括进程 ID 并使用 IP 地址而不是 FQDN，则可以使用 netstat -ctulpn。
		lsof【list open files】，是一个具有许多用法的多功能工具。如【显示在网络连接上下文使用lsof】：
			# lsof -i TCP:1-1024
			COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
			sshd     812 root    3u  IPv4  23813      0t0  TCP *:ssh (LISTEN)
			sshd     812 root    4u  IPv6  23822      0t0  TCP *:ssh (LISTEN)
			sshd     978 root    4u  IPv4  29531      0t0  TCP localhost.localdomain:ssh->192.168.3.4:58590 (ESTABLISHED)
			sshd     992 root    4u  IPv4  29531      0t0  TCP localhost.localdomain:ssh->192.168.3.4:58590 (ESTABLISHED)
			sshd    1466 root    4u  IPv4  33596      0t0  TCP localhost.localdomain:ssh->192.168.3.4:60048 (ESTABLISHED)
			sshd    1470 root    4u  IPv4  33596      0t0  TCP localhost.localdomain:ssh->192.168.3.4:60048 (ESTABLISHED)
		这里列出特权TCP端口（需要root权限）。
		lsof的另一个使用示例是以进程为中心的视图【如，知道进程的PID，可以使用lsof跟踪文件描述符，I/O等】：
			# lsof -p 5299
		还有更多用于（性能）监控的工具可用，例如 sar（涵盖一系列计数器，非常适合脚本）和 perf.
	Ⅱ	集成性能监视器
		集成性能监视器提供以下功能：
			》支持多资源类型（CPU，RAM，I/O）
			》交互式排序和过滤（按进程、用户、资源）
			》实时更新并深入了解进程组甚至cgroup和命名空间等详细信息
		如 top 命令，其输出包含：
			①	系统摘要
			②	任务统计
			③	CPU使用统计（用户、内核等，与vmstat输出相同）
			④	动态进程列表，包括每个进程级别的详细信息；与ps aux输出相似。
		top 命令重要的key 如下：
			？	列出帮助（包含key映射）
			V	在进程树视图之间切换
			m	通过内存使用排序
			p	通过CPU消耗排序
			k	发送一个信号
			q	退出
		虽然 top 几乎可以在任何环境中使用，但还有许多可用的替代方案，包括以下内容：
			htop
				增量 top 改进，比 top 更快并且具有更好的用户界面。
			atop
				一个强大的top 替代方案。除了CPU和内存之外，还详细介绍了I/O和网络统计等资源。
			below
				这是一个相对较新的工具，尤其值得注意的是，它支持cgroup v2。其他工具不理解cgroup，因此仅提供全局资源视图。
		还有许多其他可用的集成监控工具，这些工具超出了基本来源或专门针对某些用例。这些包括但不限于以下内容：
			》glances		强大的混合体，涵盖除常用资源之外的设备			【https://nicolargo.github.io/glances/ 】
			》guider		集成的性能分析器，允许显示一系列指标并绘制图表	【https://github.com/iipeace/guider 】
			》neoss			用于网络流量监控；提供良好 TUI de ss 替代平		【https://github.com/PabloLec/neoss 】
			》mtr			用于网络流量监控；traceroute 的更强大替代方案	【https://www.bitwizard.nl/mtr/ 】
	Ⅲ	Instrumentation
4、Advanced Observability


Advanced Topics
1、进程间通信
	在Linux中有一长串可用的进程间通信（IPC）【https://en.wikipedia.org/wiki/Inter-process_communication 】选项。范围从管道到套接字再到共享内存。
	IPC使进程能通信、同步活动和共享数据。如，Docker 守护进程使用可配置的套接字来管理容器。
	Ⅰ	信号【signal】
		信号【https://www.man7.org/linux/man-pages/man7/signal.7.html 】最初是作为内核向用户空间进程通知事件的一种方式而开发的。将信号视为发送到进程的异步通知。
		有许多可用的信号【man 7 signal】。并且大多数信号都带有默认操作，如停止或终止进程。
		对于大多数信号，可以定义自定义处理程序，而不是让Linux继续执行默认操作。如，当想要执行一些清理工作或只是忽略某些信号时，这非常有用。常用信号如下：
			信号			含义						默认动作						处理选项				组合键
			SIGHUP		告知守护进程重读其配置文件		终止进程					nohup 或自定义处理器		N/A
			SIGINT		用户从键盘中断					终止进程					自定义处理器				Ctrl+C
			SIGQUIT		用户从键盘退出					core dump 或 终止进程		自定义处理器				Ctrl+\
			SIGKILL		杀死信号						终止进程					不能被处理					N/A
			SIGSTOP		停止进程						停止进程					不能被处理					N/A
			SIGTSTP		用户从键盘导致停止				停止进程					自定义处理器				Ctrl+Z
			SIGTERM		优雅的终止						终止进程					自定义处理器				N/A
		还有一些没有定义含义的信号（SIGUSER1 he SIGUSER2），如果双方都同意信号的语义，进程可以使用它们相互通信，发送异步通知。
		向进程发送信号的一种典型方法是 kill 命令（其默认行为导致进程终止）。还可以使用 trap 处理信号，这允许在shell环境中定义自定义处理程序，如：
			# trap "echo abcdef" SIGINT
			# trap
			trap -- 'echo abcdef' SIGINT
		这样可通过 Ctrl+C 告诉Linux在默认操作（终止）之前执行 echo abcdef【注意 sleep 不会触发echo abcdef】
	Ⅱ	命名管道【named pipes】
		管道【|】将一个进程的stdout与另一个进程的stdin连接来将数据从一个进程传递到另一个进程——这些管道为未命名管道。命名管道是可以为其分配自定义名称的管道。
		就像未命名管道一样，命名管道与普通文件I/O（打开、写入等）一起工作，并提供先进先出（FIFO）传送。与未命名管道不同，命名管道的生命周期并不限于它所使用的进程。
		从技术上讲，命名管道是管道的包装器，使用pipelinefs 伪文件系统。使用 mkfifo 创建命名管道，如：
			# mkfifo examplepipe
			# ls -l examplepipe
`			prw-r--r--. 1 root root 0 12月 26 02:58 examplepipe
			# while true; do echo "x" > examplepipe; sleep 5; done &			# 使用循环将 x 发布到管道中【注意，除非其他进程从examplepipe读取数据，否则管道将被阻塞。无法再对其进行写入】
[			1] 2432
			# while true; do cat < examplepipe; sleep 5; done &					# 启动第二个进程，循环从管道中读取数据。
			[2] 2434
			x
			x
		命名管道很容易使用。由于其设计，看起来就像普通文件一样。但它们也有局限性，因为它们只支持一个方向和一个消费者。
	Ⅲ	Unix 域套接字【UNIX Domain Sockets】【https://en.wikipedia.org/wiki/Unix_domain_socket 】
		除了网络环境中的套接字。还有其他类型的套接字专门在单台机器的上下文中工作，其中一种称为UNIX域套接字：它们是双向的、多路通信端点。这意味着可以有多个消费者。
		域套接字分为三种类型【https://www.man7.org/linux/man-pages/man7/unix.7.html 】：面向流的（SOCK_STREAM）、面向数据报的（SOCK_DGRAM）和顺序数据包（SOCK_SEQPACKET）。
		寻址基于文件系统路径名。不需要IP地址和端口，简单的文件路径就足够了。
		通常，会以编程方式使用域套接字。但是，可能会发现处于需要对系统进行故障排除并希望使用命令行中的 socat【https://copyconstruct.medium.com/socat-29453e9fc8a6 】工具与套接字手动交互的情况。

x
x




														
		
		


	
		
	
	

		

			






				



		





			
			

			




	

			


					
					




		




	

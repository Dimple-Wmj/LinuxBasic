Managing Users and Groups
	Linux包含两种用户：人类用户和系统用户。每个用户都有一个独一的身份（UID）和至少一个组标识（GID）。所有用户都有一个主要组，并且可能是多个组的成员。
	每个用户都有一个家目录（位于/home目录下，一般以用户名命名）。用户可能属于多个组，这种额外的组关系叫作附加组。组中的用户拥有该组的所有权限。权限控制对文件和命令的访问，是系统安全的基础。
	系统用户代表系统服务和进程。系统用户需要用户帐户来控制其权限，并且在 /home 中没有登录名或目录。
	人类用户分为两类：根用户或超级用户，拥有一切权力，可以在系统上执行任何操作。所有其他用户称为普通或非特权用户。普通用户被授予足够的权限来管理自己的文件并运行允许普通用户使用它们的命令。
	普通用户可以被授予有限或完整的 root 权限。
	【/etc/passwd】包含系统上的所有用户，【/etc/group】包含所有组。
	Linux 附带了许多用于管理用户和组的命令：
		①	useradd			添加新用户
		②	groupadd		添加新组
		③	userdel			删除用户
		④	groupdel		删除组
		⑤	usermod			对现有用户进行更改
		⑥	passwd			创建和更改用户密码
	这些是 Shadow Password Suite 的一部分，/etc/login.defs 是其主要配置文件。
	在 Shadow Password Suite 出现之前，所有相关文件都必须单独编辑，有多个密码管理命令，并且散列密码存储在 /etc/passwd 和 /etc/group 中。 这两个文件必须是全世界可读的，因此在其中存储密码（即使它们经过哈希处理）也会带来麻烦。 
	将散列密码重新定位到影子文件 /etc/shadow 和 /etc/gshadow（这些文件只能由 root 访问）中，增加了一层强大的保护。 Shadow Password Suite 的使用寿命证明了其设计和编码的出色程度。
1、用户UID和GID
	①	使用不带任何选项的【id】命令，可以查看当前用户的UID和GID。
		# id
		用户id=0(root) 组id=0(root) 组=0(root) 上下文=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
	②	显示指定用户的UID和GID
		# id miggi
		用户id=1000(miggi) 组id=1000(miggi) 组=1000(miggi)
	③	查看有效身份ID
		id -un
	》扩展
		在Linux上有三种类型的用户：真实 UID/GID、有效 UID/GID、保存的 UID/GID。
		真实 ID 是创建用户时为用户分配的UID和GID。即【id】命令显示的UID和GID。
		有效 ID 是用于运行需要与启动该进程的用户不同的权限的进行的UID【如，运行passwd时，有效ID是root】。
		保存的ID由需要提升权限（通常是root权限）的进程使用。当进程需要执行需要较少权限时，可以暂时切换到非特权用户ID。将有效UID更改为较低的权限值，并将原来的有效UID保存到SUID中，保存用户ID。当进程再次需要提升权限时，会更改为SUID。
	》id选项说明：
		-u		显示有效UID号
		-g		显示有效GID号
		-G		显示所有组ID
		-n		打印名称而不是数字。可与 -u 、-g 和 -G 组合使用。
		-r		显示真实ID。可与 -u 、-g 和 -G 组合使用。
2、使用 useradd 创建人类用户
	大多数 Linux 发行版中都包含 useradd 命令，并且可以根据您的要求进行配置。 不同 Linux 发行版的默认配置各不相同。
	①	创建新用户
		useradd test1
	②	查看新用户ID，即家目录
		id test1
		用户id=1001(test1) 组id=1001(test1) 组=1001(test1)
		s -a /home/test1
		.  ..  .bash_logout  .bash_profile  .bashrc
	③	设置用户密码
		passwd test1
		创建用户密码后，可以选择强制用户在首次登录时重置密码：
		passwd -e test1
	新建的用户会附加到【/etc/passwd】中。
	》useradd 用法
		useradd [选项] 登录名
		useradd -D
		useradd -D [选项]
	》useradd 选项
		    --badname                 do not check for bad names
		-b, --base-dir BASE_DIR       新账户的主目录的基目录
		    --btrfs-subvolume-home    use BTRFS subvolume for home directory
		-c, --comment COMMENT         新账户的 GECOS 字段
		-d, --home-dir HOME_DIR       新账户的主目录
		-D, --defaults                显示或更改默认的 useradd 配置
		-e, --expiredate EXPIRE_DATE  新账户的过期日期
		-f, --inactive INACTIVE       新账户的密码不活动期
		-g, --gid GROUP               新账户主组的名称或 ID
		-G, --groups GROUPS           新账户的附加组列表
		-h, --help                    显示此帮助信息并退出
		-k, --skel SKEL_DIR           使用此目录作为骨架目录
		-K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值
		-l, --no-log-init             不要将此用户添加到最近登录和登录失败数据库
		-m, --create-home             创建用户的主目录
		-M, --no-create-home          不创建用户的主目录
		-N, --no-user-group           不创建同名的组
		-o, --non-unique              允许使用重复的 UID 创建用户
		-p, --password PASSWORD       加密后的新账户密码
		-r, --system                  创建一个系统账户
		-R, --root CHROOT_DIR         chroot 到的目录
		-P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files
		-s, --shell SHELL             新账户的登录 shell
		-u, --uid UID                 新账户的用户 ID
		-U, --user-group              创建与用户同名的组
		-Z, --selinux-user SEUSER     为 SELinux 用户映射使用指定 SEUSER
	》扩展
		所有新用户在设置密码前均处于非活动状态。为用户创建的第一个组，无论是用户私有组还是所有用户的公共组，都是其主要组。 用户分配到的所有其他组都是补充组。
		创建用户时添加附加组【这些组必须已存在】（-G, --groups）
			useradd -G group1,group2, group3 test1
		创建用户时设置 GECOS 字段
			useradd -G group1,group2,group3 -c 'Test 1,,,,' test1
		四个逗号定义五个字段：全名、房间号、工作电话、家庭电话和其他。 很久以前，这被称为 GECOS 数据。 GECOS是通用电气综合运营管理器的缩写，是一种大型机操作系统。
		可以在这些字段中输入任何文本字符串，也可以不输入任何内容，但包含用户的全名很有用。见【/etc/passwd】中的 GECOS 字段。
		useradd与多个配置文件关联。
		man 8 useradd
		man 5 login.defs
		/etc/default/useradd
		/etc/skel
		/etc/login.defs
3、使用useradd创建系统用户
	创建系统用户【没有主目录、没有登录shell，UID编号在系统用户UID范围内】：
		useradd -rs /bin/false service1
	》选项说明：
		-r		创建一个具有系统用户正确数字范围内真实ID的系统用户
		-s		指定登录shell
	》扩展
		在过去，大多数服务都是以【nobody】用户身份运行的。 现在，服务拥有自己的唯一用户是一种常见的做法，因为这比拥有多个服务的【nobody】用户提供了更强的安全性。很少需要创建系统用户，因为服务在安装时应该创建自己的唯一用户。
		始终为【nobody】用户分配 UID 65534 和 GID 65534。
4、更改 useradd 默认设置
	useradd配置分布在多个配置文件中：/etc/default/useradd、/etc/login.defs 和 /etc/skel 目录中的文件。显示 useradd 的默认配置：
		# useradd -D
			GROUP=100
			HOME=/home
			INACTIVE=-1
			EXPIRE=
			SHELL=/bin/bash
			SKEL=/etc/skel
			CREATE_MAIL_SPOOL=yes
		GROUP=100		为所有新用户设置一个默认的共享组【该组必须存在】。并且 /etc/login.defs 中要有【USERGROUPS_ENAB no】设置。
						通过在 /etc/login.defs 中设置【USERGROUPS_ENAB yes】设置私有用户组，并且要注释掉 /etc/default/useradd 中的【GROUP】。
		HOME=			设置所有新用户主目录的默认目录。默认为 /home 。
		IINACTIVE=-1	设置密码过期后直到账户被锁定的天数。【0】将在密码过期后立即禁用账户，【-1】将禁用锁定账户。
		EXPIRE=			设置账户过期日期【格式为：YYYY-MM-DD】。【EXPIRE=empty】意味着账号将不会过期。
		SEHLL=/bin/bash	设置默认的命令shell。
		SKEL=/etc/skel	设置要自动分发给新用户的文件的位置。大多数Linux将其放置在 /etc/skel 。这些文件包括【.bash_logout】、【.bash_profile】或【.profile】、【.bashrc】以及希望新用户拥有的任何其他文件。
						可以编辑这些文件以满足要求。SKEl 是 skelton 的缩写。
		CREATE_MAIL_SPOOL=yes	是旧时代的遗物，应该设置为 yes，因为可能有一些遗留流程仍然需要它。
	/etc/login.defs 中的以下值与用户创建默认值相关：
		USERGROUPS_ENAB	yes	启用私有用户组
		CREATE_HOME yes		配置 useradd 自动创建用户主目录。
	》扩展
		UID 编号范围在【/etc/login.defs】中定义。每个 UID 必须是唯一的，因此用户帐户创建命令会从此文件中定义的范围分配 UID。 
		通常，人类 UID 从 1000 开始，由 useradd 自动分配。可以使用 -u 选项覆盖此设置，但必须选择遵循配置的编号方案的未使用的编号。
		首次登录时强制更改密码是一种简单的预防措施，可防止原始密码在从管理员传递给用户时可能落入坏人之手。
5、使用 groupadd 创建用户组和系统组。
	①	创建用户组
		groupadd musicians
	②	创建系统组【-r】
		groupadd -r service1
	系统组和用户组的不同之处在于分配给它们的UID和GID编号范围。这是在 /etc/login.defs 中为 groupadd 和 useradd 定义的。如：
		# Min/max values for automatic uid selection in useradd(8)
		#
		UID_MIN 1000
		UID_MAX 60000
		# System accounts
		SYS_UID_MIN 201
		SYS_UID_MAX 999
		# Extra per user uids
		SUB_UID_MIN 100000
		SUB_UID_MAX 600100000
		SUB_UID_COUNT 65536
		#
		# Min/max values for automatic gid selection in groupadd(8)
		#
		GID_MIN 1000
		GID_MAX 60000
		# System accounts
		SYS_GID_MIN 201
		SYS_GID_MAX 999
		# Extra per user group ids
		SUB_GID_MIN 100000
		SUB_GID_MAX 600100000
		SUB_GID_COUNT 65536
	GID 编号由 groupadd 根据 /etc/login.defs 中定义的编号范围自动管理。可以使用 -g 选项覆盖此设置，但选择的 GID 必须在定义的范围内，并且不得已被使用。
6、使用 usermod 将用户添加到组
	①	将用户【duchess】添加到指定组【musicians】
		usermod -aG musicians duchess
	②	将用户【duchess】添加到多个组
		usermod -aG musicians,composers,stagehands duchess
	另外，也可以直接编辑 /etc/group 文件，将用户名放在指定组中。当列出多个组成员时，列表必须以逗号分隔，名称之间不能有空格。如：
		musicians:x:900:stash,madmax,duchess
	》注意：
		如果单独使用【-G】（没有指定【-a】），则用户将从所有现有组中移除，并替换为新组。
		当更改已登录用户的组成员身份时，用户必须注销然后重新登录才能激活更改。 有多种解决方法可以在不注销的情况下激活新的组分配，但它们都有局限性，例如仅限于当前 shell。 登录时会枚举组，因此最可靠的解决方案是注销并重新登录。
7、检查密码文件完整性
	【pwck】检查 /etc/passwd 和 /etc/shadow 的完整性，【grpck】检查 /etc/group 和 /etc/gshadow。
	不会编辑 /etc/shadow 或 /etc/gshadow 。但会编辑 /etc/passwd 和 /etc/group。
8、禁用用户账号
	要暂时停用账号，使用【passwd】命令禁用用户的密码。如：
		passwd -l stash
	解锁用户账号。如：
		passwd -u stash
	锁定【lock】账号不会阻止用户通过不同的身份验证方法（如SSH密钥）登录。要完全禁用用户，使用 usermod 命令。如：
		usermod --expiredate 1 stash
	当用户尝试登录时，会看到“您的帐户已过期；恢复帐户：
		usermod --expiredate -1 stash
	另一种禁用账号的方法是在 /etc/passwd 中将用户的密码字段【x】替换为【*】。
		stash:*:1009:1009:Stash Cat,,,:/home/stash:/bin/bash
	通过用【x】替换【*】来重新启用账号。
9、使用 userdel 删除用户
	①	从【/etc/passwd】中删除用户【stash】、【stash】的主要组和所有组成员身份以及shadow文件。
		userdel stash
		如果【stash】属于一个共享主用户组，则该组将不会被删除。
	②	使用【-r】选项删除用户主目录及其包含的内容和邮件池【mail spool】
		usedel -r stash
10、使用【su】成为root
	可以使用【su】名称切换到root用户【需要root密码】。如：
		su -l
	【-l】选项调用root用户的环境，更改root的主目录并加载root的环境变量。省略【-l】以保留当前的环境。
	》su 使用说明
		用法：
			su [选项] [-] [<用户> [<参数>...]]
			将有效用户ID和组ID更改为<用户>的有效用户ID和组ID。仅仅 - 就意味着 -l。 如果未给出 <user>，则假定为 root。
		选项：
			-m, -p, --preserve-environment		不重置环境变量
			-w,	--whitelist-environment <list>	不重置指定变量
			-g,	--group <组>					指定主组
			-G,	--supp-group <组>				指定附加组
			- ,	-l,	--login						使 shell 成为登录 shell
				-c, --command <命令>			使用 -c 向 shell 传递一条命令
					--session-command <命令>	使用 -c 向 shell 传递一条命令，而不创建新会话
			-f,	--fast							向 shell 传递 -f 选项（csh或tcsh）
			-s, --shell <shell>             	若 /etc/shells 允许，运行<shell>
			-P, --pty							创建一个新的伪中断
11、使用 sudo 授予有限的 root 权限
	sudo 比 su 更安全，因为它向特定用户授予执行特定任务的有限 root 权限、记录活动，并在有限的时间内（默认为 15 分钟）缓存用户的密码。 15 分钟后，用户必须再次向 sudo 提供密码。缓存持续时间是可配置的。 
	sudo 保护 root 的密码，因为 sudo 用户使用自己的密码。
	【/etc/sudoers】是其配置文件，应该使用特殊命令【visudo】编辑它。这将使用默认文本编辑器打开 /etc/sudoers，可以查看和编辑默认配置。
	》配置说明【root ALL=(ALL) ALL】
		root	用户字段。该字段保存任何单个用户、用户别名或系统组
		ALL=	主机字段。ALL表示任何地方法的任何主机，或可以使用主机别名，或单个主机
		(ALL)	可选用户字段。(ALL)表示一个或多个用户可以像其他用户一样运行命令，或可以指定某些用户。
		ALL		命令字段。ALL表示不受限制，可以指定允许的命令列表。
	》配置示例
		%sudo ALL=(ALL) ALL	添加到 sudo 组的任何用户都将获得完整的 sudo 权限，就像 root 一样。百分号表示 %sudo 是 /etc/group 中的组，而不是 /etc/sudoers 中配置的组。
		stash server1 = /bin/rpm, /usr/bin/yum, /usr/bin/dnf	# 用户名、本地计算机的主机名、以逗号分隔的允许命令列表
		# 如果允许的命令过长，可以创建一些命令别名。如
		Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum, /usr/bin/dnf
		Cmnd_Alias SYSTEM = /usr/bin/systemctl start, /usr/bin/systemctl stop, /usr/bin/sytemctl reload, /usr/bin/systemctl restart, /usr/bin/systemctl status,
		/usr/bin/systemctl enable, /usr/bin/systemctl disable, /usr/bin/systemctl mask, /usr/bin/systemctl unmask
		stash server1 = SOFTWARE, SYSTEM
		# 创建组【非/etc/group组】
		User_Alias JRADMIN = stash, madmax
		JRADMIN server1 = SOFTWARE, SYSTEM
		# 可以创建一个Host_Alias来授予用户在多态计算机上的sudo权限。
		Host_Alias SERVERS = server1, server2, server3
		JRADMIN SERVERS = SOFTWARE, SYSTEM
	》注意事项
		不要过分相信将用户限制为一组特定的命令。 许多日常应用程序都提供了通过 shell 转义进行权限升级的方法，并且您的用户可以获得完全的 root 权限。
		①	通过 awk 直接切换到root用户
			如果给予用户【awk】的root权限。则用户可通过如下命令直接切换到【root】用户。
				sudo awk 'BEGIN {system("/bin/bash")}'
			这样普通用户【如duchess】将拥有完整的root权限。
		②	less的 shell 转义
				sudo less /etc/systctl.conf
			通过键入【!sh】，进行 shell 转义。
		跟踪可以提供 shell 转义的应用程序极其困难。如果希望监视 sudo 用户，journalctl会记录所有内容。
	在某些 Linux 中，例如 Fedora，wheel 组是默认的 sudo 组。 检查 /etc/sudoers 文件以了解发行版如何配置它。还可以创建自己的 sudo 组，并将其命名为想要的任何名称。
	【/etc/sudoers】文件仅控制本地计算机上的用户。包括其他计算机（如 SERVERS 别名）允许您在多台计算机上共享单个配置文件。sudo忽略本地计算机上不存在的任何项目，如主机或用户。
12、延长 sudo 密码超时
	在大多数 Linux 发行版上，sudo 会默认缓存密码 15 分钟。 15 分钟后，必须再次输入密码。 当有很多工作要做时，厌倦了必须频繁输入密码，可以将缓存间隔设置得更长。
	通过 visudo 编辑【/etc/sudoers】中得 timestamp_timeout 配置。如：
		Defaults timestamp_timeout=60
	如果将其设置为0， sudo 会在每次使用它都要求密码。如果设置为负数【如，-1】，密码将不会过期。
13、创建单独的 sudoers 配置
	可以在 /etc/sudoers.d 中创建单独的配置。如：
		cd /etc/sudoers.d/
		sudo visudo -f stash
	这会创建【stash】文件。只需输入与 /etc/sudoers 中的条目不同的配置项，而不是复制整个文件。这是管理多个用户的一个很好的功能。 不要管理一个大的配置文件，而是将其分解为较小的每个用户文件。
14、将 sudo 更改为不询问 Root 密码
	有些Linux发行版（如openSUSE）要求在使用sudo提权时输入root用户的密码。
	要设置 sudo 用户总是询问用户自己的密码，编辑【/etc/sudoers】文件并注释以下两行：
		visudo
		# Defaults targetpw
		# ALL ALL=(ALL) ALL
	在 openSUSE 和 Fedora 中，通过将 sudo 用户添加到 /etc/group 中的wheel组来创建具有完全root权限的用户。
	保存更改并关闭文件后，更改立即生效。


Managing Files and Directories
	Linux 提供了强大的基本控制来访问具有可配置权限的文件和目录。每个文件和目录都有三级所有权，包括用户、组和其他；以及多级访问，包括读、写和执行。可以保护个人文件并控制谁有权访问它们。
	每个文件都有三种所有权：所有者、所属组和其他用户。其中所有者是单一用户、所属组是单一组。
	每个文件都有流中权限模式——读、写和执行，以及三种特殊模式：sticky bit、setuid和setgid。
	文件权限控制哪些用户可以创建、读取、编辑或删除文件，以及哪些用户可以执行命令。特殊模式控制谁可以移动、删除或重命名文件，以及谁可以以提升的权限执行命令。 
	目录权限控制哪些用户可以编辑或进入目录，以及哪些用户可以读取、编辑、添加或删除目录中的文件。 
	注意：基本的 Linux 安全原则是使用最少的必要权限来完成工作。
	在 Linux 系统上，root 用户（也称为超级用户）拥有至高无上的权力。root 几乎可以执行任何操作，包括编辑和删除其他用户的文件、进入任何目录以及运行任何命令。普通用户或非特权用户可以使用 sudo 或 su 命令暂时取得 root 权限。
	每个用户都有一个唯一的标识（UID），并且至少属于一个组。组中的每个用户共享该组的权限。
		# stat --format="%a:%A:%U:%G" /etc
		755:drwxr-xr-x:root:root
	命令输出以两种形式显示目录的模式或权限集：755:drwxr-xr-x。 755是八进制表示法，drwxr-xr-x是符号表示法。 这是表达同一模式的两种不同方式。
	root:root是所有者和所属组。文件和目录可以有不同所有者和所属组。
	除了读、写和执行权限外，文件还有三种特殊权限模式：sticky bit、setuid和setgid。
	setuid和setgid模式将用户和组权限提升到文件所有者和所属组相同的权限。这些仅在特殊情况下使用，并且要非常谨慎地使用，因为权限升级是一个潜在的安全风险。
	sticky bit【粘性位】可防止除文件所有者或具有root权限的任何人之外的其他人删除、重命名或移动目录中不属于它们的文件。
1、创建文件和目录
	使用 mkdir 命令创建目录。如，在当前目录下创建子目录：
		mkdir -v presentations
	使用 -p 选项递归创建目录，如：
		mkdir -p presentations/2023/august
	创建目录的同时设置目录权限：
		mkdir -m 0700 /home/miggi/dog-memes
	使用 touch 命令创建新文件：
		touch /home/miggi/test.txt
	使用 tree 命令查看目录结构：
		# tree -L 1 /home/miggi
		/home/miggi
		├── github_passwd.txt
		└── LinuxBasic

		1 directory, 1 file
	》扩展
		man 1 mkdir
		man 1 touch
		man 1 yes
		man 1 tree
2、批量创建文件
	通过大括号扩展【Brace Expansion】，可以批量创建一系列类似的文件。如：
		touch file{00..99}
		touch file{00..99..2}
	使用 yes 命令快速填充文件。如：
		yes This is a test file | head -c 5MB > testfile.txt
	通过 for 循环快速填充多个文件。如：
		for i in {00..99}; do
			yes This is a test file | head -c 5MB > file$i
		done
3、相对路径和绝对路径
	绝对路径总是以根【/】开始，如/boot和/etc。相对路径是相对于当前工作目录的，且没有前导斜杠【/】。某些应用程序和命令需要相对路径； 例如，rsync include 和 exclude 列表使用与要复制的目录相关的文件路径。
4、删除文件和目录
	使用 rm 命令删除文件和目录，但请谨慎使用。删除单一文件，输出详情：
		rm -v test.ogg
	使用 -i 选项在删除前进行确认：
		rm -iv test.ogg
	使用 -r 选项递归删除目录和其所有文件和子目录。如：
		rm -rvi rehearsals
	使用 -f 强制删除。
5、复制、移动和重命名文件和目录
	使用 cp 命令进行复制，使用 mv 命令移动或重命名。复制当前目录中的的文件到指定目录：
		cp -v test1.txt test2.txt ~/subdir
	使用 -r 递归复制目录中的文件和子目录：
		cp -rv ~/music/songs2 /shared/archives
	-r 仅复制目录及其文件。使用 --parents 选项保留父目录。如，复制song2和其内容，同时保留文件路径【/duchess/music/songs2】：
		cp -rv --parents /duchess/music/song2 shows/
	duchess 和 music 的其他内容不会复制，仅songs2和其内容被复制。
	移动文件到其他目录：
		mv -v test.ogg solo.flac ~/songs2/
	》扩展
		Ⅰ	cp
			①	用法
				cp [选项]... [-T] 源文件 目标文件
				cp [选项]... 源文件... 目录
				cp [选项]... -t 目录 源文件...
				将指定<源文件>复制至<目标文件>，或将多个<源文件>复制至<目标目录>。
			②	选项
				-a, --archive                 	等于-dR --preserve=all
				      --attributes-only 		仅复制属性而不复制数据      
					  --backup[=CONTROL         为每个已存在的目标文件创建备份
				  -b                            类似--backup 但不接受参数
				      --copy-contents           在递归处理是复制特殊文件内容
				  -d                            等于--no-dereference --preserve=links
				  -f, --force                  	如果有已存在的目标文件且无法打开，则将其删除并重试（该选项在与 -n 选项同时使用时将被忽略）
				  -i, --interactive            	覆盖前询问（使前面的 -n 选项失效）
				  -H                           	跟随源文件中的命令行符号链接
				  -l, --link                   	硬链接文件以代替复制
				  -L, --dereference            	总是跟随源文件中的符号链接
				  -n, --no-clobber              不要覆盖已存在的文件(使前面的 -i 选项失效)
				  -P, --no-dereference          不跟随源文件中的符号链接
				  -p                            等于--preserve=模式,所有权,时间戳
				      --preserve[=属性列表      保持指定的属性(默认：模式,所有权,时间戳)，如果可能保持附加属性：上下文、链接、xattr 等
				      --sno-preserve=属性列表   不保留指定的文件属性
				      --parents                 复制前在目标目录创建来源文件路径中的所有目录
				  -R, -r, --recursive           递归复制目录及其子目录内的所有内容
				      --reflink[=WHEN]          控制克隆/CoW 副本。请查看下面的内如。
				      --remove-destination      尝试打开目标文件前先删除已存在的目的地文件 (相对于 --force 选项)
				      --sparse=WHEN             控制创建稀疏文件的方式
				      --strip-trailing-slashes  删除参数中所有源文件/目录末端的斜杠
				  -s, --symbolic-link           只创建符号链接而不复制文件
				  -S, --suffix=后缀             自行指定备份文件的后缀
				  -t,  --target-directory=目录  将所有参数指定的源文件/目录复制至目标目录
				  -T, --no-target-directory     将目标目录视作普通文件
				  -u, --update                  只在源文件比目标文件新，或目标文件不存在时才进行复制
				  -v, --verbose         		显示详细的进行步骤
				  -x, --one-file-system 		不跨越文件系统进行操作
				  -Z                           	设置目标文件的 SELinux 安全上下文为默认类型
				      --context[=上下文]       	类似 -Z；如果指定了上下文，则将 SELinux 或 SMACK 安全上下文设置为指定值
		Ⅱ	mv
			①	用法
				mv [选项]... 源文件 目标文件
				mv [选项]... -T 源文件... 目录
				mv [选项]... -t 目录 源文件...
			②	选项
				      --backup[=CONTROL]       为每个已存在的目标文件创建备份
				  -b                           类似--backup 但不接受参数
				  -f, --force                  覆盖前不询问
				  -i, --interactive            覆盖前询问
				  -n, --no-clobber             不覆盖已存在文件
				如果指定了-i、-f、-n 中的多个，仅最后一个生效。
				      --strip-trailing-slashes 去掉每个源文件参数尾部的斜线
				  -S, --suffix=SUFFIX          替换常用的备份文件后缀
				  -t, --target-directory=目录  将所有<源文件>移动至指定的<目录>中
				  -T, --no-target-directory    将参数中所有<目标文件>部分视为普通文件
				  -u, --update                 仅在<源文件>比目标文件更新，或者目标文件
				                               不存在时进行移动操作
				  -v, --verbose                对正在发生的操作给出解释
				  -Z, --context                将目标文件的 SELinux 安全上下文设置为默认类型
6、使用 chmod 设置文件属性
	有两种方式设置文件属性：
		①	数字形式	八进制表示法有四个字段，可能最长使用最后三个字段【所有者权限、所属组权限和其他人权限】，很少使用第一个字段【保留，用于特殊模式】
						r（4）、w（2）、x（1）；setuid（4）、setgid（2）、sticky bit（1）
		②	符号形式	有四组用户【所有者（u）、所属组（g）、其他（o）和所有（a）】。有三种设置方式【=、+、-】。权限符号包括：rwxXst。权限值也可ugo表示。
	Ⅰ	使用数字形式修改权限
		①	设置文件权限
			chmod -v 0600 file.txt
		②	设置目录权限【目录必须设置可执行位】（使用cd命令或文件管理器进入目录是必要的）
			chmod -v 0770 /shared
			使用 -R 选项将相同的权限应用于目录的现有内容：
			chmod -R 0775 /shared
			将目录及其现有内容限制为目录所有者。目录中的文件和目录可能有不同的所有者和权限，但组和其他人仍然无法访问。
			chmod 0700 /shared
			常见的权限集合是给予所有者和组相同的权限【如读、写权限】，并排除其他：
			chmod 0770 /shared
		③	针对特殊用例使用特殊模式
			特殊模式是粘性位【sticky bit】、setuid 和 setgid。 
			粘滞位应用于包含多个用户拥有的文件的目录，以防止用户移动、重命名或删除不属于他们的文件：
			chmod -v 1770 /home/duchess/shared
			setuid应用于可执行文件【二进制文件】，以将运行该命令的任何用户提升到与所有者相同的权限：
			chmod -v 4750 backup-script
			将setgid应用于目录，以便该目录中所有新创建的文件都被分配到与该目录的所属组相同的组中：
			chmod -v 2770 /home/duchess/shared
			setgid 也可以应用于文件，将用户的有效组更改为与文件所有者相同的组。
			setgid 和 setuid 有可能为入侵者或不值得信任的用户创建安全漏洞。最佳实践是仅当无法想出更安全的方法来完成想做的事情时才使用它们，例如使用组分配或 sudo。 
			setuid 对于可执行文件很有用。 setgid 对于目录和文件很有用。
			sticky bit仅用于目录。
			粘性位的一个更具描述性的名称是限制删除位。 该位可防止非特权用户删除或重命名目录中的文件，除非他们拥有该文件。
			setgid表示设置组用户标识，setuid表示设置用户标识。 这些用于将非特权用户的权限提升到与用户或组所有者相同的权限。如普通用户可以使用 passwd 命令修改其自身的密码。
				stat --format=%a:%A:%U:%G /usr/bin/passwd
		④	移除特殊模式
			删除特殊模式与设置有点不同，需要使用额外的前导零。如：
			chmod -v 00770 backup.sh
			或使用前导等号替换前导零：
			chmod -v =770 backup.sh
	Ⅱ	使用符号形式修改权限
		符号形式有三种运算符：+、-和=。可以使用【u】标志更改文件所有者权限，使用【g】更改所属组权限，使用【o】更改其他人权限和【a】更改所有人权限。
			+	添加指定权限
			-	从现有权限中减去指定权限
			=	添加指定的新权限，同时减去没有列出的任何权限
		①	给所属组和其他人添加写权限：
			chmod g+w,o+w file.txt
		②	减去所属组和其他人的写权限：
			chmod go-w file.txt
		③	常见的权限集是赋予所有者和所属组相同的权限【如，读写】，同时排除其他人的权限：
			chmod -v r=rw,g=rw,o-r file.txt
		④	命令和脚本需要可执行权限，给文件所有者添加执行权限：
			chmod -v u+x file.sh
		⑤	【=】运算符对于覆盖现有权限很有用：
			chmod -v u=rw,g=rw,o=r file.txt
		可靠地使用 chmod 符号表示法的关键是始终明确并注意现有权限。添加和减去现有权限（除了使用 = 运算符，它会覆盖），并指定 u、g、o 或 a。
		符号表示法有 10 个值，未设置的值（表示没有权限）用破折号表示。如：
			# stat --format="%a:%A:%U:%G" /home/miggi/
			700:drwx------:miggi:miggi
		第一个是文件类型【如，d】其余九个值分为三个三元组，每个三元组中的三个值代表读、写和执行。
		⑥	使用符号形式设置特殊模式
			特殊模式是：sticky bit、setuid、setgid。这些都在可执行字段中设置。
			》sticky bit应用于包含多个用户拥有的文件的目录，以防止非所有者移动、重命名或删除文件：
			chmod o+t /shared/stickydir
			》对目录应用 setgid，可以将目录中所有新创建的文件设置到该目录相同的组中。这是在共享目录中强制执行正确所有权的一个好技巧：
			chmod g+s /shared
			》在可执行文件【二进制文件】上设置 setuid 允许非root用户运行可执行文件：
			chmod u+s backup-script
		Mode 		User 	Group 	Other
		Read 		r 		r 		r
		Write 		w 		w 		w
		Execute 	x 		x 		x
		setuid 		s
		setgid 				s
		Sticky bit 					t	
	Ⅲ	使用 chmod 批量设置文件权限
		chmod 支持对文件列表进行操作。还可以使用 find 命令和 shell 通配符来选择要更改的文件。
		chmod -v 444 file1 file2 file3
		使用 -R 选项【递归】设置目录及其包含的文件和子目录权限：
		chmod -vR 755 /shared
		使用通配符批量设置文件权限：
		chmod -v 644 *.txt
		使用 find 命令设置当前目录中文件的权限：
		find . -type f -exec chmod -v 660 {} \;
		修改属于特定用户【用户ID或用户名】的所有文件的权限：
		sudo find / -user madmax -exec chmod -v 660 {} \;
		sudo find / -user 1007 -exec chmod -v 660 {} \;
		》扩展
			man 1 chmod
			man 1 find
7、使用 chown 设置文件和目录的所有者
	使用 chown【change owner】命令更改文件所有者。基本命令格式是【chown user:group filename】。可以仅更改所有者【chown user: filename】；也可以仅更改文件所属组【chown :group filename】。
	更改文件所有者需要root权限：
		sudo chown -v madmax: song.wav
	更改文件所属组：
		sudo chown -v :composers song.sav
	更改文件所有者和所属组：
		sudo chown stash:stash song.wav
	需要root权限才能更改不属于自己的文件并将我呢见所有权转移给其他用户。当同时属于原始组和新组时，无需root权限即可更改文件所属组到新组。
	当仅更改文件所有者，冒号是可选的；当更改所属组时，冒号是必需的。
8、使用 chown 批量更改文件所有权
	chown 支持对文件列表进行操作。还可以使用 find 命令和 shell 通配符来列出要更改的文件。
	使用 chown 批量更改文件所有权，文件列表用逗号分隔：
		sudo chown -v madmax:share file1 file2 file3
	使用通配符【*】：
		sudo chown -v :share *.txt
	使用数字UID或用户名将目录中用户的所有文件提供给另一个用户：
		chown -Rv --from duchess stash /shared/compositions
		chown -Rv --from 1001 1005 /shared/compositions
	使用 find 命令遍历整个文件系统或任何目录及其子目录，将一个用户的所有提供给另一个用户：
		sudo find / -user duchess -exec chown -v stash {} \;
		sudo find / -user 1001 -exec chown -v 1005 {} \;
	将用户所有文件的所有权转移给另一个用户或不同的组，对于清理不再在系统上拥有帐户的用户非常有用。
9、使用 umask 设置默认权限
	文件的原始权限是【0666】，目录的原始权限是【0777】。通过umask可控制在新建文件或目录时的默认权限【原始权限 - umask值】。
	运行 umask 命令查看umask值。使用【-S】选项以符号形式显示。如：
		# umask -S
		u=rwx,g=rx,o=rx
	要在当前会话期间临时更改 umask，请按以下方式设置：
		# umask 0022
	通过将【umask 0022】插入到 ~/.bashrc 中来永久设置umask值。
	要设置所有用户的umask值，可将其放在/etc/login.defs中。
10、创建文件和目录的快捷键【软连接和硬链接】
	Linux上有两种连接：软连接和硬链接。软连接可用于文件和目录；硬链接只能用于文件。使用 ln 命令创建连接。
	在当前目录创建到 /files/userstuff 的连接【stuff】：
		ln -s /files/userstuff stuff
	/files/userstuff 是源，stuff是目标【软连接名称】。可以将软连接命名为任何想要的名称，并移动和删除它们，而不会影响其目标。打开软链接时，其行为与打开目标相同。 
	硬链接是文件的副本。 ln 命令默认创建硬链接：
		ln /files/config1.txt myconf.txt
	①	软连接
		软连接更常称为符号连接【symliks】。
		符号链接指向文件和目录。 当符号链接的目标被删除、重命名或移动时，符号链接就会被破坏。 如果创建与已删除文件同名的新文件，即使内容不同，符号链接也会恢复。
		符号连接可跨文件系统。甚至可以创建指向非永久性的文件或目录的符号连接【如USB存储设备或网络共享文件】。当目标更改（重命名、移动或删除）时，符号连接不会更新。需要创建一个新的符号连接并删除旧的符号连接。
		不管理符号连接的权限或所有权，因为只有目标的权限才重要。符号链接示例如下：
		# stat github_passwd.txt
		  文件：github_passwd.txt -> /home/miggi/github_passwd.txt
		  大小：29              块：0          IO 块：4096   符号链接
		设备：fd00h/64768d      Inode：16777990    硬链接：1
		权限：(0777/lrwxrwxrwx)  Uid：(    0/    root)   Gid：(    0/    root)
		环境：unconfined_u:object_r:admin_home_t:s0
	②	硬链接
		文件由inode唯一标识，硬链接指向的是inode，而不是文件名。ls 命令使用【-i】选项显示inode。如：
		# ls -li
		总用量 4
		17800211 -rw-------. 1 root root 807 12月  3 19:24 anaconda-ks.cfg
		16777990 lrwxrwxrwx. 1 root root  29 12月  9 04:58 github_passwd.txt -> /home/miggi/github_passwd.txt
		硬链接总是有效，因为它们直接指向索引节点【inodes】。具有多个硬链接的文件可以移动、重命名和编辑，并且所有硬链接保持同步【都指向同一数据块】。Linux系统上的每个文件都以硬链接开头。
		创建硬链接时，正在为现有数据块创建新文件名。硬链接不能跨文件系统，仅存在于单一文件系统。
		可以根据需要对文件建立任意数量的硬链接，并且它们指向的数据所占用的磁盘空间始终相同，无论它有多少个硬链接。 对比硬链接和制作文件副本：每个副本都使用更多的磁盘空间，每个副本都是独立的，并且副本可以去任何地方。
		在删除所有硬链接之前，文件不会被完全删除。
11、隐藏文件和目录
	通过使用点【.】文件来忽略（隐藏）文件。可使用 ls -a 来显示隐藏文件。
	在任何文件前面加上点【.】都会使其成为隐藏文件。尽管它实际上并不是隐藏的，但会被忽略，直到想查看它为止。 这主要用于用户的主目录通过不显示配置文件来减少混乱。这些是普通文件，可以编辑、删除或执行任何想要的操作。


Backup and Recovery with rsync
	rsync 是一个高效的文件传输程序，其主要目的是保持文件系统彼此同步。 当您使用它进行备份时，它会使本地文件与备份设备保持同步。它快速且高效，因为它仅传输文件中的更改。与许多从不希望删除任何内容的备份软件不同，它甚至会镜像删除。 
	由于这些功能，rsync 成为更新和镜像用户主目录、网站、git 存储库和其他大型复杂文件树的首选工具。
	通过网络使用 rsync 有两种方法：通过 SSH，进行身份验证登录和传输，或者将其作为守护进程运行。 
	使用 SSH 要求用户在需要 rsync 访问的每台计算机上拥有登录帐户。 
	当rsync以守护进程模式运行时，可以使用其内置的身份验证方法来控制访问，以便用户不需要在rsync服务器上登录帐户。
	守护进程模式非常适合LAN备份服务器。通过不受信任的网络访问是不安全的，除非使用VPN。
	如果互联网连接足够强大来处理流量，那么设置远程 rsync 镜像来备份备份是一种常见策略。 但在构建大规模备份基础设施之前，请考虑一下真正需要多少级别的冗余。 异地备份是防止站点发生灾难的保险。
	备份的目的是恢复。 定期测试备份，以避免因备份方法失败而遭受惨痛教训。
1、选择需要备份的文件
	个人文件和系统数据文件是最重要的。以下目录包含配置等文件； Web、FTP 和邮件服务器等服务器的数据文件； 日志文件; 安装在非标准位置的应用程序； 和共享目录，所有这些都应该备份：
		/boot/grub		如果包含任何自定义项【如主题、背景图像或字体】
		/etc			包含系统配置文件
		/home			用户的个人文件
		/mnt			临时文件系统挂载点。如果有要保留的挂载点，要备份此内容
		/opt			对于专有或其他未按标准方式安装的应用程序
		/root			root用户的个人文件
		/srv			服务器数据【如，web、FTP】
		/tmp			保存临时数据，根据需要自动更新或删除。 /tmp 中的一些数据是持久性的，例如用户创建的文件和一些系统服务，应该备份它们。
		/var			存储许多类型的数据，例如日志文件、邮件假脱机、cron 作业和系统服务数据，尽管大多数发行版已迁移到使用 /srv 来提供系统服务。
	如果有任何共享目录、自定义命令和脚本，或者之前未列出的任何数据文件或目录，也要备份它们。
2、从备份中选择要恢复的文件
	重装Linux后，不要恢复 /etc/fstab（该文件配置静态文件系统挂载）。每次安装Linux，所有文件系统都会获得新的UUID（通用唯一标识符）。因此它们不会被识别，并且新安装将会失败。
	恢复/etc中的文件或用户主目录中的点文件。如果要从备份恢复到不同版本或不同 Linux 发行版的新安装，则配置选项或文件位置可能不兼容。 一次恢复一个，这样就可以快速发现任何问题。
4、使用 cp 进行本地备份
	①	cp 用法
		cp [选项]... [-T] 源文件 目标文件
		cp [选项]... 源文件... 目录
		cp [选项]... -t 目录 源文件...
	②	选项
		-a, --archive               等于-dR --preserve=all
		    --attributes-only 		仅复制属性而不复制数据      
			--backup[=CONTROL       为每个已存在的目标文件创建备份
		-b                          类似--backup 但不接受参数
		    --copy-contents         在递归处理是复制特殊文件内容
		-d                          等于--no-dereference --preserve=links
		-f, --force                 如果有已存在的目标文件且无法打开，则将其删除并重试（该选项在与 -n 选项同时使用时将被忽略）
		-i, --interactive           覆盖前询问（使前面的 -n 选项失效）
		-H                          跟随源文件中的命令行符号链接
		-l, --link                  硬链接文件以代替复制
		-L, --dereference           总是跟随源文件中的符号链接
		-n, --no-clobber            不要覆盖已存在的文件(使前面的 -i 选项失效)
		-P, --no-dereference        不跟随源文件中的符号链接
		-p                          等于--preserve=模式,所有权,时间戳
		    --preserve[=属性列表    保持指定的属性(默认：模式,所有权,时间戳)，如果可能保持附加属性：上下文、链接、xattr 等
		    --sno-preserve=属性列表   不保留指定的文件属性
		    --parents                 复制前在目标目录创建来源文件路径中的所有目录
		-R, -r, --recursive           递归复制目录及其子目录内的所有内容
		    --reflink[=WHEN]          控制克隆/CoW 副本。
		    --remove-destination      尝试打开目标文件前先删除已存在的目的地文件 (相对于 --force 选项)
		    --sparse=WHEN             控制创建稀疏文件的方式
		    --strip-trailing-slashes  删除参数中所有源文件/目录末端的斜杠
		-s, --symbolic-link           只创建符号链接而不复制文件
		-S, --suffix=后缀             自行指定备份文件的后缀
		-t,  --target-directory=目录  将所有参数指定的源文件/目录 复制至目标目录
		-T, --no-target-directory     将目标目录视作普通文件
		-u, --update                  只在源文件比目标文件新，或目标文件不存在时才进行复制
		-v, --verbose         		  显示详细的进行步骤
		-x, --one-file-system 		  不跨越文件系统进行操作
		-Z                            设置目标文件的 SELinux 安全上下文为默认类型
		    --context[=上下文]        类似 -Z；如果指定了上下文，则将 SELinux 或 SMACK 安全上下文设置为指定值
	如果要保留文件属性（例如所有权和权限），请使用支持文件属性的 Linux 文件系统（例如 Ext4、XFS 或 Btrfs）格式化备份驱动器（请参阅第 11 章）。 FAT 文件系统不保留所有权或权限。
	密切关注备份运行需要多长时间。 如果它花费的时间比预定的备份间隔长，cron将按计划开始下一次备份，然后就会出现混乱。
5、	使用 rsync 进行本地备份
	rsync 使本地和远程文件系统保持同步。rsync 快速高效，因为它仅传输文件中的更改。备份本地用户主目录：
		rsync -av ~ /media/duchess/2tbdisk/
	可以在空格分隔的列表中指定两个或多个目录以传输到目标目录：
		rsync -av ~/arias ~/overtures /media/duchess/2tbdis/duchess/
	使用 --dry-run 选项安全地测试 rsync 命令，而无需复制任何文件：
		rsync -av --dry-run ~/Music/scores ~/Music/woodwinds /media/duchess/2tbdisk/duchess/
	如果在源目录中删除任何文件，rsync不会从目标目录中删除对应文件，除非使用【--delete】选项：
		rsync -av --delete /home/duchess /media/duchess/2tbdisk/
	如果安装了网络文件系统（如NFS或Samba），使用【-x】选项仅从本地文件系统复制，而不是递归到远程文件系统。
	如果在源中添加尾随的斜杠【如~/、/home/duchess/】，仅复制目录的内容，而不是目录本身。省略尾部的【/】会传输目录及其内容。尾随斜杠仅作用于源目录，不会影响目标目录。
	》扩展【rsync命令】
		①	用法
			本地：
				rsync [选项]... SRC... [DEST]
			通过远程shell访问：
				拉取：
					rsync [选项]... [USER@]HOST:SRC... [DEST]
				推送：
					rsync [选项]... SRC... [USER@]HOST:DEST
			通过rsync守护进程访问：
				拉取：
					rsync [选项]... [USER@]HOST::SRC... [DEST]
					rsync [选项]... rsync://[USER@]HOST[:PORT]/SRC... [DEST]
				推送：
					rsync [选项]... SRC... [USER@]HOST::DEST
					rsync [选项]... SRC... rsync://[USER@]HOST[:PORT]/DEST
		②	选项
			-v, --verbose					增加详情
				--info=FLAGS				细粒度的信息详情 									--debug=FLAGS				细粒度的调试详情
				--stderr=e|a|c				更改标准错误的输出模式（默认：errors） 				-q,	--quiet						抑制非错误消息
				--no-motd					抑制守护进程模式的MOTD
			-c, --checksum					基于校验和跳过，而不是修改时间&大小
			-a, --archive					归档模式；等于 -rlptgoD（没有-H，-A，-X）
				--no-OPTION					关闭隐含选项（如，--no-D）
			-r, -recusive					递归进目录
			-R, --relative					使用相对路径名 										--no-implied-dirs			不发送 --relative 隐含的目录
			-b, --backup					创建备份（见 --suffix & --backup-dir） 				--backup-dir=DIR			将备份制作为基于 DIR 的层次结构
				--suffix					备份后缀（默认 ~ 不带（w/o）--backup-dir）
			-u, --update					跳过接收端较新的文件
				--inplace					就地【in-place】更新目标文件
				--append					将数据附加到较短的文件中
				--append-verify				在文件校验和中追加 w/old 数据
			-d, --dirs						不递归传输目录
				--mkpath					创建目的地的路径组件
			-l, --links						复制符号链接为符号链接 								-L, --copy-links				将符号链接转换为引用文件/目录
				--copy-unsafe-links			仅传输“不安全”的符号链接
				--safe-links				忽略指向树【tree】外部的符号链接 						--munge-links				破环符号链接，使其安全且不可用
			-k, --copy-dirlinks				将符号链接转换为引用目录 							-K, --keep-dirlinks				treat symlinked dir on receiver as dir
			-H, --hard-links				保留硬链接
			-p, --perms						保留权限 											-A, --acls						保留ACLs（隐含--perms）
			-E, --executability				保留可执行性 										-X, --xattrs					保留扩展属性
				--chmod=CHMOD				指定文件权限 											--chown=USER:GROUP			设置文件所有权
			-o, --owner						保留所有者（仅限超级用户） 							-g, --group						保留所属组
				--devices					保留设备文件（仅限超级用户） 							--copy-devices				将设备文件复制为常规文件
				--specials					保留特殊文件 										-D								与 --devices --specials 相同
			-t, --times						保留修改时间 										-U, --atimes					保留访问（使用）时间
				--open-noatime				避免更改打开文件的atime 							-N, --crtimes					保留创建时间
			-O, --omit-dir-times			从 --times 中忽略目录 								-J, --omit-link-times			从 --times 中忽略符号链接
				--super						接收端尝试超级用户活动
				--fake-super				使用 xattrs 存储/恢复特权属性
			-S，--sparse					将空值序列转换为稀疏块
				--preallocate				在写入目标文件前分配它们
				--write-devices				将设备以文件写入（隐含 --inplace）
			-n, --dry-run					不做任何更改，进行试运行
			-W, --write-whole				复制整个文件（不使用 delta-xfer 算法）
				--checksum-choice=STR		选择校验和算法（aka --cc）
			-x, --no-file-system			不要跨越文件系统边界
			-B, --block-size=SIZE 			强制固定的校验和块大小
			-e, --rsh=COMMAND				指定使用的远程shell
				--rsync-path=PROGRAM		指定在远程机器上运行的rsync
				--existing					跳过在接收端新建文件
				--remove-source-files		发送端删除同步文件（非目录）
				--del						--delete-during 的别名 									--delete					从目标目录中删除无关文件
				--delete-before				接收者在传输之前删除									--delete-after				接收端在传输之后删除
				--delete-delay				find deletions during, delete after 					--delete-during				接收端在传输期间删除
				--delete-excluded			从目标目录中删除排除的文件 								--delete-missing-args		从目标中删除缺少的源参数
				--ignore-missing-args		忽略缺少的源参数而不出现错误 							--ignore-errors				即使有错误也删除
				--force						强制目录删除，即使非空
				--max-delete=NUM			不要删除超过NUM个文件
				--max-size=SIZE				不要传输超过SIZE大小的文件								--min-size=SIZE				不要传输小于SIZE大小的文件
				--max-alloc=SIZE			更改与内存分配相关的限制
				--partial					保留部分传输的文件										--partial-dir=DIR			将部分传输文件放到DIR中
				--delay-updates				将所有更新的文件放在最后
			-m, --prune-empty-dirs			从文件列表中删除空目录链
				--numeric-ids				不要按用户/组名映射uid/gid值
				--usermap=STRING			自定义用户名映射 										--groupmap=STRING			自定义组名映射
				--timeout=SECONDS			设置I/O超时【秒】
				--contimeout=SECONDS		设置守护进程连接超时【秒】
			-I, --ignore-times				不要跳过时间和大小匹配的文件
				--size-only					跳过大小匹配的文件
			-@, --modify-window=NUM			设置修改时间比较的精度
			-T, --temp-dir=DIR				在DIR目录中创建临时文件
			-y, --fuzzy						如果没有目标文件，则查找类似文件作为基础
				--compare-dest=DIR			还比较相对于DIR的目标文件
				--copy-dest=DIR				...，还包括未更改文件的副本
				--link-dest=DIR				未更改时，硬链接到DIR中的文件
			-z, --compress					传输时，压缩文件数据
				--compress-choice=STR		选择压缩算法（aka --zc）
				--skip-compress=LIST		跳过LIST列表包含的后缀的文件的压缩
			-C, --cvs-exclude				以与 CVS 相同的方式自动忽略文件
			-f, --file-filter=RULE			添加文件过滤规则【RULE】
			-F								same as --filter='dir-merge /.rsync-filter'
					                        repeated: --filter='- .rsync-filter'
				--exclude=PATTERN			排除匹配模式【PATTERN】的文件 							--exclude-from=FILE			从文件【FILE】中读取排除模式
				--include=PATTERN			包含匹配模式【PATTERN】的文件 							--include-from=FILE			从文件【FILE】中读取包含模式
				--files-from=FILE			从文件【FILE】中读取源文件名列表
			-0, --from0						all *-from/filter files are delimited by 0s
			-s, --protect-args				no space-splitting; wildcard chars only
				--copy-as=USER[:GROUP]		指定复制的用户和可选组
				--address=ADDRESS			将传出套接字的地址绑定到守护进程
				--port=PORT					指定双冒号备用端口号
				--socketopt=OPTIONS			指定自定义TCP选项
				--blocking-io				为远程shell使用阻塞I/O
				--outbuf=N|L|B				将缓冲设置为None、Line或Block
				--stats						提供一些文件传输统计信息
			-8, --8-bit-output				在输出中保留高位字符未转义
			-h, --human-readable			以易读格式输出数字
				--progress					在传输时显示进度
			-P								与 --partial --progress相同
			-i, --itemize-changes			输出所有更新的更改摘要
			-M, --remote-option=OPT			仅发送OPTION到远程端
				--out-format=FORMAT			输出更新使用指定格式【FORMAT】
				--log-file=FILE				将正在做的事情记录到指定的文件【FILE】中
				--password-file=FILE		从文件【FILE】中读取守护进程访问密码
				--early-input=FILE			use FILE for daemon's early exec input
				--list-only					列出文件而不是复制它们
				--bwlimit=RATE				限制套接字I/O带宽
				--stop-after=MINS			MINS 分钟过去后停止 rsync 								--stop-at=y-m-dTh:m			在指定时间点停止rsync
				--write-batch=FILE			将批量更新写入文件【FILE】
				--only-write-batch=FILE		类似于 --write-batch 但不更新【w/o】目标
				--read-batch=FILE			从文件【FILE】读取批量更新
				--protocol=NUM				强制使用较旧的协议版本
				--iconv=CONVERT_SPEC		请求文件名的字符集转换
				--checksum-seed=NUM			设置 块/文件 校验和种子（高级）
			-4, --ipv4						倾向于 IPv4											-6, --ipv6						倾向于 IPv6
6、使用 rsync 通过 SSH 进行安全地远程文件传输
	将文件传输到其他机器上时，rsync 默认使用 SSH。远程主机上必需运行SSH服务器，本机上要有SSH客户端。如：
		rsync -av ~/Music/arias empress@remote.example.com:songs/
	如果目标目录不存在，rsync会创建它。身份验证和传输均通过SSH加密。用户在要将文件传输到地所有计算机上都需要shell账号。
7、从备份中排除文件
	使用 --exclude 选项从源中排除文件。如：
		rsync -av --exclude=lho-perduta.wav ~/Music/arias /media/duchess/2tbdisk/duchess/Music/
	注意，如果源目录中有多个文件与排除的文件同名，则所有这些文件都将被排除。如果不想排除重复项，需要明确指定是哪一个。如：
		rsync -av --exclude=arias/lho-perduta.wav ~/Music/arias /media/duchess/2tbdisk/duchess/Music/
	通过将多个文件括在大括号中来排除多个文件，并用引号和逗号分隔。等号和大括号之间不能有空格。如：
		rsync -av --exclude={"arias/lho-perduta.wav","non-mi-dir.wav","un-bel-di-vedremo.flac"} ~/Music/arias /media/duchess/2tbdisk/duchess/Music/
	排除目录的工作方式与排除文件相同，可以在排除列表中混合文件和目录。如：
		rsync -av --exclude={"soprano/","tenor/","non-mi-dir.wav"} ~/Music/arias /media/duchess/2tbdisk/duchess/Music/
	rsync 传输中的根目录是传输文件的顶级目录【如，~/Music/arias】。rsync检查根目录中的所有文件和目录，并嫁给你它们与排除指令进行比较，rsync称之为“模式”。
	根据根目录中的文件和目录检查模式，从根开始并沿着目录层次结构向下进行。每次匹配模式时，都会将其排除在传输之外。
8、包含指定文件到备份
	--include 操作不同于 --exclude，因为它不真的意味着“包含”，而是“不排除”。它需要两个额外的选项：【--include=*/】和【--exclude='*'】。如：
		rsync -av --include=*/ --include=lho-perduta.wav --exclude='*' ~/Music/arias /media/duchess/2tbdisk/duchess/Music/
	可以传输文件列表。如：
		rsync -av --include=*/ --include={'lho-perduta.wav','non-mi-dir-wav','un-bel-di-vedremo.flac'} --exclude='*' ~/Music/arias /media/duchess/2tbdisk/duchess/Music/
	等号和大括号之间不能有空格，逗号和单引号之间不能有空格。如果源目录中的不同位置有多个同名文件，rsync 将传输所有这些文件。
	使用 -m, --prune-empty-dirs 选项可防止复制空目录。如：
		rsync -avm --cinlude=*/ --include=soprano/lho-perduta.wav --exclude='*' ~/Music/arias /media/duchess/2tbdisk/duchess/Music/
	》说明：
		①	--include=*/		告诉 rsync 遍历整个源目录
		②	--include=[files]	意味着不排除这些文件
		③	--exclude='*'		告诉 rsync 排除所有未包含的内容
	注意：所有文件路径都相对于源目录，而不是系统的根目录。
9、使用包含文件管理包含
	通过 --files-from 选项 指定要包含的文件列表【不必担心以正确的顺序获取它们，也不必担心使用rsync的过滤符号，只需要包含想要的任何文件和目录的简单列表即可】。文件中每一项都必须相对于源目录。如
		# include file list 【include-list.txt】所有项都是相对于源目录【/home/duchess】。
		# 
		/Documents/compositions/jazz/
		/Documents/schedule.odt
		/Videos/concerts/
		.config
		.local
		/Music/courses/bassoon.avi</strong>
		[...]
	rsync -av ~ --files-from ~/include-list.txt duchess@remote.example.com:/backups/
	这是维护要备份的文件和目录列表的最简单方法。 没有排除，没有通配符，只有一个干净易懂的列表。当使用【~】表示主目录时，省略【--files-from】中的等号。
10、使用排除文件管理包含和排除
	排除文件提供了更大的灵活性，并且包含了包含和排除。【每一项都必须从包含源根开始。如：
			# exclude file list
			# 
			# include home directory
			+ /duchess/
			#
			# include .config and .local, exclude all other files
			+ /duchess/.config
			+ /duchess/.local
			- /duches/*
			# 
			# include jazz/, exclude all other files in Documents
			+ /duchess/Documents/
			+ /duchess/Documents/compositions/
			+ /duchess/Documents/compositions/jazz/
			- /duchess/Documents/compositions/*
			- /duchess/Documents/*
			#
			# include schedule.odt, include all .ogg filesin arias/, exclude all other files in Music
			+ /duchess/Music/
			+ /duchess/Music/arias/
			+ /duchess/Music/arias/.odt
			+ /duchess/Music/arias/*.ogg
			- /duchess/Music/arias/*
			- /duchess/Music/*
			#
			# include courses/, exclude all other files in Videos
			+ /duchess/Videos/
			+ /duchess/Videos/courses/
			- /duchess/Videos/*
			# 
			# exclude everything else
			- /duchess/*
		rsync -av ~ --exclude-from=/home/duchess/exclude-list.txt /media/duchess/2tbdisk/
	行与行之间不能有空格，注释 (#) 可用于提醒每个部分的用途以及添加一些空格。在包含的前面加上加号，在排除的前面加上减号。
	包含必须始终放在首位。必须精确定义每个包含/排除。包含必须按其目录层次结构顺序列出，其中包含所有子目录。
11、限制 rsync 带宽使用
	大文件传输会占用大量网络带宽并降低速度。使用 --bwlimit 选项可以限制 rsync 的带宽使用。--bwlimit 单位是 kilobits。如：
		rsync -bwlimit=512 -ave ssh ~/Music/arias empress@laptop:songs/
12、构建 rsyncd 备份服务器
	以守护进程模式运行rsync，这样就可以不需要服务器【备份】上的登录账号，而是使用rsync 自己的访问控制和用户授权来控制对 rsync 归档的访问。
	》注意【仅限 LAN 使用】
		这仅适合 LAN 使用，不适用于不受信任的网络，因为 rsync 守护程序不会加密身份验证或文件传输。 对于加密传输，需要 OpenVPN。
	rsync 必须安装在所有机器上。rsyncd运行在服务器【备份】，客户使用 rsync 命令连接到服务器。
	在备份服务器上，编辑或创建 /etc/rsyncd.conf 以创建 定义归档的 rsync 模块。如：
			# modules
			[backup]
			  path = /backups
			  comment = "server1 public archive"
			  list = yes
			  read only = no
			  use chroot = no
			  uid = 0
			  gid = 0
	创建 /backups 目录，并设置正确的权限【防止任何有权访问服务器的人进行未经授权的访问】。如：
		mkdir -m 0700 /backups
	启动 rsyncd 守护进程：
		①	通过 systemctl
			systemctl start rsyncd.service
		②	通过 rsync 命令
			rsync --daemon
	测试 rsyncd 是否正在侦听和接受连接：
		rsync localhost::
	测试文件备份：
		rsync -av test.txt 192.168.3.12::backup
	》/etc/rsyncd.conf 配置说明
		[backup]		模块名【可以是想要的任何名称】
		path=			定义模块使用的目录
		comment=		简短的描述信息
		list=yes		允许用户查看模块中的文件列表。【no】表示隐藏该模块
		read only=no	允许用户上传文件到服务器
		use chroot=no	覆盖默认的【use chroot = yes】。chroot 是更改根目录，有时称为 chroot 监狱。chroot Jail 是文件系统内的一个独立环境，包含自己的根文件系统、命令、库以及其运行所需的所有其他内容。
						这不是一个安全的环境，尽管它通常被认为是一种安全工具。对于 rsync，手册页将其描述为防止配置错误的有用保护。
						代价是 rsync 被阻止跟踪到 chroot 环境之外的文件的符号链接，并且它使按名称保留 UID 和 GID 变得复杂。
		将 uid 和 gid 设置为0或root。这样可以保留 UID 和 GID，并正确管理权限。
	》扩展
		man 5 rsyncd.conf
13、限制对 rsyncd 模块的访问
	rsyncd 带有自己的简单身份验证和访问控制。创建一个包含用户名/密码的文件，并将身份验证用户和密码文件指令添加到 /etc/rsyncd.conf 中。如：
		①	创建密码文件【/etc/rsyncd-users】
			# rsync-users for server1
			duchess:12345
			madmax:23456
			stash:34567
		②	修改文件权限
			chmod 0600 /etc/rsyncd-users
		③	创建rsyncd 模块
			[duchess_backup]
				path = /backups/duchess
				comment = Duchess's private archive
				list = yes
				use chroot = no
				read only = no
				uid = 0
				gid = 0
				auth users = duchess
				secrets file = /etc/rsyncd-users
				strict mode = yes
		④	创建备份目录
			mkdir -m 0700 /backups/duchess
		⑤	测试登录
			# rsync duchess@localhost::duchess_backup
			Password: 
			drwx------              6 2023/12/11 03:32:21 .
		⑥	同步文件
			$ rsync -av ./test duchess@localhost::duchess_backup
			如果文件传输失败，检查 rsync 日志以了解原因。在systemd Linux上，读取状态输出中的最新日志条目：
			systemctl status rsyncd.service
			在其他Linux发行版中 rsyncd 日志应该在 /var/log中。
	》扩展【为了安全性，在 /etc/rsyncd.conf 中添加以下条目】
		①	hosts allow		列出允许访问 rsyncd 归档的主机
			hosts allow = *.local.net
			hosts allow = 192.168.1.
			所有不允许的主机都会被拒绝，因此不需要主机拒绝指令。
		②	hosts deny	
			如果使用【hosts allow】，通常不需要指定该指令。它对于拒绝访问引起烦恼的特定主机很有用。
			密码文件是明文的，因此必须仅限于超级用户。
14、为rsyncd 创建每日消息
	在纯文本文件【如/etc/rsyncd-motd】中创建每日消息【MOTD】。然后在/etc/rsyncd.conf顶部配置MOTD文件路径。如：
		[global]
			motd file = /etc/rsyncd-motd

	当用户连接 rsyncd 服务器时，将会看到 MOTD 消息。


Managing Disk Partitioning with parted



Secure Remote Access with OpenSSH
	OpenSSH 是安全远程管理的首选工具。 它对会话期间的身份验证和所有流量进行加密，并保证数据传输的完整性。 如果发生某些事情改变了你的数据包，SSH 会告诉你。
	OpenSSH支持大量强加密算法。 所有这些都不受专利限制，因为 OpenSSH 团队竭尽全力确保 OpenSSH 内部不存在任何专利或其他受限制的代码。
	OpenSSH是一套远程传输实用程序：
		sshd		OpenSSH服务器守护程序
		ssh			secure shell的缩写，虽然它并不真正包含 shell，但提供了到远程系统上的命令 shell 的安全通道。
		scp			secure copy，加密文件传输器。
		sftp		安全文件传输协议，提供文件访问。
		ssh-copy-id	用于将公钥安装到远程SSH服务器的 authorized_keys 文件中。
		ssh-keyscan	查找并收集网络上的公共主机密钥，从而省去了手动查找它们的麻烦。
		ssh-keygen	生成和管理身份验证密钥
		ssh-add		将身份添加到身份验证代理，ssh-agent。
	sshfs 在本地 PC 上安装远程文件系统，而 ssh-agent 会记住 SSH 私钥上的密码，以便多个SSH登录时进行自动身份验证。 ssh-agent 绑定到单个登录会话，因此注销或打开另一个终端意味着重新开始。
	OpenSSH支持不同类型 的身份验证：
		①	密码验证【Password authentication】				通过远程Linux登录名和密码进行身份验证。
		②	公钥验证【Public key authentication】			通过个人SSH公钥进行身份验证。【需要创建和分发公钥，并只能从保存对应私钥的计算机登录】
		③	无密码验证【Passphrase-less authentication】	无需密码的公钥身份验证。 这对于脚本和 cron 作业等自动化服务很有用。 任何成功窃取私钥的人都可以轻松伪装成您，因此需要非常保护无密码的私钥。
	身份验证密钥有两种不同的用途：
		①	主机密钥【host keys】	用于计算机身份验证。
		②	公钥【public heys】		用于用户身份验证。
	SSH密钥成对出现，包括私有密钥和公共密钥。传输使用公钥加密并使用私钥解密。可以根据需要安全地分发公钥，同时必须保护私钥并不让其他人拥有。
1、安装OpenSSH Server
	大多数 Linux 发行版默认安装 OpenSSH 客户端，但并不总是安装服务器。 不同的 Linux 发行版以不同的方式打包 OpenSSH，因此请使用包管理器列出适用的 Linux 的包。
	①	安装OpenSSH Server
		yum –y install openssh-server openssh-clients
	②	通过systemctl管理sshd
		systemctl start sshd
		systemctl status sshd
		systemctl reload sshd
		systemctl stop sshd
2、生成新地主机密钥【Host Keys】
	Linux发行版可能不会再安装时自动创建主机密钥，或想要使用替换现有主机密钥，又或者克隆安装虚拟机想要唯一的主机密钥。可以通过【ssh-keygen】生成新的主机密钥。
	有四种不同的密钥：RSA、DSA、ECDSA和ED25519。
	①	删除旧的公钥
		rm /etc/ssh/ssh_host*
	②	创建所有的公钥：
		ssh-keygen -A
	③	扩展
		对于应该使用哪种密钥格式。最简单的做法是使用RSA、ECDSA和ED25519，并避免使用DSA。【删除DSA主机密钥，保留其余三种】。
		RSA是最古老的，它很强大并提供了最大的兼容性。ECDSA 和 ED25519 更新、非常强大且计算成本较低。
3、配置OpenSSH Server
	①	确保服务器的私有主机密钥仅root拥有且只读
		# ls -l /etc/ssh/ssh_host*_key
		-rw-r-----. 1 root ssh_keys  492 12月  3 19:25 /etc/ssh/ssh_host_ecdsa_key
		-rw-r-----. 1 root ssh_keys  387 12月  3 19:25 /etc/ssh/ssh_host_ed25519_key
		-rw-r-----. 1 root ssh_keys 2578 12月  3 19:25 /etc/ssh/ssh_host_rsa_key
	②	确保服务器的公钥由root拥有，其他人只有读权限
		# ls -l /etc/ssh/ssh_host*.pub
		-rw-r--r--. 1 root root 162 12月  3 19:25 /etc/ssh/ssh_host_ecdsa_key.pub
		-rw-r--r--. 1 root root  82 12月  3 19:25 /etc/ssh/ssh_host_ed25519_key.pub
		-rw-r--r--. 1 root root 554 12月  3 19:25 /etc/ssh/ssh_host_rsa_key.pub
	③	修改sshd配置【/etc/ssh/sshd_config】
		取消要使用的和更改的选项注释。
		》在接受登录前检查用户文件和主目录的文件模式和所有权是否正确：
			StrictModes yes		# 如果权限不正确，该设置将不允许登录
		》定义监听地址：
			ListenAddress 192.168.10.15
			ListenAddress 127.16.32.5
		》定义监听端口：
			检查/etc/services查找未使用的端口，使用大于1024的端口号，
			将选择的端口号添加到/etc/services中：
				sshd 2022
				sshd 2023
			sshd监听端口：
				Port 2022
				Port 2023
		》限制仅允许访问指定组【/etc/groups】：
			AllowGroups	webadmins backupadmins	
			# DenyGroups abcd	# 拒绝访问指定组
		》不允许root用户登录：
			PermitRootLogin	no
		》仅允许通过公钥认证登录root用户
			PermitRootLogin prohibit-password
		》禁止所有用户密码登录
			PasswordAuthentication no
		》禁用指定用户登录：
			DenyUsers duchess stash@example.com cagney@192.168.10.5
			# 使用 AllowUsers指定允许登录的用户。DenyUsers优先级高于 AllowUsers 。
		》限制服务器等待用户登录并完成连接的时间长度。 默认值为 120 秒：
			LoginGraceTime 90
		》限制连接失败尝试次数，默认6次：
			MaxAuthTries 4
4、检查配置语法
	通过【sshd -t】命令检查【/etc/ssh/sshd_config】配置文件中的配置是否有语法错误。
5、首次登录
	主机公钥交换仅在第一次登录时发生一次【将服务器的公共主机密钥保存到客户端的~/.ssh/known_hosts文件中】。除非用新密钥替换该密钥，或从~/.ssh/known_hosts文件中将其删除。
	【~/.ssh/known_hosts】文件可以包含任意数量的主机密钥。
	存在主机密钥传输可能被拦截并被伪造密钥替换的风险，这将允许攻击者访问您的系统。可以在键入 yes 之前验证公钥指纹。
6、检索公钥指纹
	在服务器上使用【ssh-keygen】命令以及要查询的主机公钥来检索其指纹。如：
		ssh-keygen -lf /etc/ssh/ssh_host_rsa_key
7、使用公钥验证
	使用公钥验证比密码验证要更强。可以选择使用单个公钥来访问多个主机，或为每个远程主机创建唯一的公钥。
	①	创建新SSH密钥
		ssh-keygen -C "backup server2" -f ~/.ssh/id-server2 -t rsa -b 4096
	②	将新SSH公钥传输到要登录的远程主机：
		ssh-copy-id -i ~/.ssh/id-server2 duchess@server2
	③	使用公钥验证用户
		ssh -i ~/.ssh/id-server2 duchess@server2
	可以使用这个新密钥来访问多个远程主机，或者为每个远程主机创建一个唯一的密钥。 在多台机器上使用相同的密钥很容易使用，但在多台主机上更改却很痛苦。如果唯一密钥被泄露或丢失，只需更换一次。
	应该为创建的SSH密钥设置密码。如果没有密码，任何获得私钥访问权限的人都可以伪装成我们。
	ssh-copy-id 可确保公钥被复制到 正确的位置，即远程主机上的 ~/.ssh/authorized_keys，格式正确且权限正确。 它还确保私钥不会被错误复制。
	》选项说明：
		-C		为密钥添加注释。用于帮助记住密钥是干什么的。
		-f		指定密钥名称。
		-t		指定密钥类型
		-b		指定位【bit】强度，只有【rsa】使用该选项。默认是2048，最大为4096。
		-i		告诉SSH客户端，使用哪个密钥。当有多个密钥时，必须使用该选项。否则SSH客户端会尝试使用所有密钥。这样会出现 “Too many authentication failures” 错误消息。
8、管理多个公钥
	通过【~/.ssh/config】管理多个公钥。这样在通过密钥登录时可不指定密钥。如：
		Host server2
		HostName server2
		User duchess
		  IdentityFile ~/.ssh/id-server2
		  IdentitiesOnly yes
	这样就可通过【ssh server2】来以duchess登录server2了。
	》选项说明：
		Host				定义每个配置的开始，指定用于登录的标签
		HostName			远程主机【可以是主机名、完全限定域名，或IP地址】
		User				远程主机上的用户
		IdentityFile		公钥文件的完整路径
		IdentitiesOnly yes	告诉 ssh 使用 ~/.ssh/config中的配置，或传递命令行，而不是使用其他提供程序（如果有）。
		Port				指定sshd服务监听的端口号
9、更改密码
	使用【ssh-keygen -p】更改指定私钥的密码。如：
		ssh-keygen -p -i ~/.ssh/id-server2
	密码短语不可恢复。 如果丢失了密码，唯一的选择是使用新密码创建新密钥。
10、使用sshfs挂载远程文件系统
	sshfs用于挂载整个远程文件系统，然后就可以像本地文件系统一样访问。安装 sshfs 包，它还应该安装 FUSE（用户空间中的文件系统）。需要一个具有写入权限的本地目录作为挂载点
	①	安装 sshfs
		yum -y install fuse-sshfs
	②	挂载远程目录
		sshfs server2: sshfs/
	③	卸载远程文件系统
		fusermount -u sshfs/
	也可以挂载指定的目录，如：
		sshfs server2:/home/duchess/arias sshfs/
	注意：sshfs不能使用【~】（不支持）
	如果网络连接不可靠。通过【-o reconnect】告诉sshfs在网络中断后自动重连。
11、加密算法
	通过【ssh -Q <query_option>】查询OpenSSH支持的算法。通过【help】选项列出所有支持的算法。如：
		# ssh -Q help
		cipher
		cipher-auth
		compression
		kex
		kex-gss
		key
		key-cert
		key-plain
		key-sig
		mac
		protocol-version
		sig
	列出【sig】签名算法：
		# ssh -Q sig
		ssh-ed25519
		sk-ssh-ed25519@openssh.com
		ssh-rsa
		rsa-sha2-256
		rsa-sha2-512
		ssh-dss
		ecdsa-sha2-nistp256
		ecdsa-sha2-nistp384
		ecdsa-sha2-nistp521
		sk-ecdsa-sha2-nistp256@openssh.com
		webauthn-sk-ecdsa-sha2-nistp256@openssh.com
	》说明
		cipher				列出支持的对称密码
		cipher-auth			列出支持的对称密码，这些密码也支持经过身份验证的加密。
		compression			列出支持的压缩类型
		mac					列出支持的消息完整性代码。 这些可以保护消息的数据完整性和真实性。
		kex					列出密钥交换算法
		kex-gss				列出了GSSAPI（通用安全服务应用程序接口）密钥交换算法
		key					列出密钥类型
		key-cert			列出证书密钥类型
		key-plain			列出非证书密钥类型
		key-sig				列出所有密钥类型和签名算法
		protocol-version	列出支持的SSH协议版本
		sig					列出支持的签名算法
	

Secure Remote Access with OpenVPN
	开放虚拟专用网络 (OpenVPN) 在不同物理位置的两个不同网络之间创建 TLS/SSL 加密连接。这种连接称为加密隧道，这是一种安全的传输方式，可保护连接免受大的不良互联网的影响。OpenVPN依赖于OpenSSL。
1、OpenVPN概述
	VPN 是网络的安全扩展，它使远程工作人员可以使用本地用户拥有的所有相同服务，因此远程用户的体验与实际存在于您所在位置的用户的体验相同。 
	他们可以访问您的本地网络服务器、电子邮件、文件共享、聊天服务器、视频会议应用程序、内部 wiki，以及您与外界隔离且仅对网络内部的用户可用的所有内容。 
	VPN 与 SSH 不同，SSH 可以连接各个计算机。 VPN 将网络和单个主机链接到网络。
	OpenVPN 是一个开源项目，免费的服务器和客户端是 openvpn 软件包，可在所有 Linux 发行版上使用，并可在 OpenVPN Community Downloads【https://openvpn.net/community-downloads/】中下载。 
	商业选项包括 OpenVPN 访问服务器，它是带有附加管理工具和云选项的本地服务器。托管个人计划仅需要安装客户端并提供对 OpenVPN 服务器全球网络的访问。
	真正的 VPN 非常强大，因为它不信任任何人，并且需要经过身份验证的端点，其中服务器和客户端相互进行身份验证。 
	大多数商业 TLS/SSL VPN 不会这样做，而是信任所有客户端，就像购物网站一样。 这更加灵活，允许用户使用任何设备从任何地方登录。 无需安装和配置客户端软件以及复制加密密钥，非常方便。 
	但对于目光短浅的内部网络来说，您最不需要的就是用户从感染了键盘记录器和间谍软件的随机 PC 或智能手机登录，然后受到热烈欢迎进入您的 LAN。
	①	证书颁发机构（CA）
	证书颁发机构 (CA) 是运行 OpenVPN 服务器的最重要部分。 CA 颁发数字证书并证明公钥的所有权。CA 是值得信赖的权威机构，这就是为什么许多站点使用商业 CA 的原因。自签名证书，可以在您的组织内部使用。面向客户的站点应使用商业 CA。 
	使用 CA 可以让您免去在 OpenVPN 服务器上保存客户端证书副本的麻烦； 服务器需要知道的是客户端证书是由您的 CA 进行身份验证的。
	②	SSL与TLS
	安全套接字层（SSL）和传输层安全性（TLS）是加密协议。TLS是从SSL发展而来的。所有版本的SSL均已启用，TLS 1.0 和 TLS 1.1 也是如此。使用 TLS 1.2 或 1.3，并禁用所有其他协议。 由于安全缺陷，旧版本已被弃用。
	③	TUN/TAP
	TUN 和 TAP 设备是虚拟网络接口。 它们内置于 Linux 内核中，无需执行任何操作即可使它们可用。 TUN 设备用于路由网络，TAP 设备用于桥接网络。 您的服务器和客户端配置文件指定要使用哪一个。
2、安装OpenVPN，服务器和客户端
	OpenVPN 网站同时提供社区开源 OpenVPN 和商业 OpenVPN Access Server。 社区 OpenVPN 是免费且开源的。
	在Linux上安装openvpn软件包。尽可能获得最新版本，这提供了服务器和客户端。源tarball和Windows安装程序可从OpenVPN社区下载获取。
	对于用户，可以尝试免费的 OpenVPN 访问客户端，该客户端适用于 Linux、macOS、Android、iOS 和 Windows。 它们专为商业 OpenVPN 访问服务器而设计，也可与社区 OpenVPN 服务器配合使用。
	在 Linux 上，OpenVPN 必须安装在 OpenVPN 服务器和所有客户端上。 OpenVPN 包提供客户端和服务器功能。
	Ubuntu、Fedora 和 openSUSE 包含提供与 NetworkManager 集成的附加软件包，这使得管理、连接和断开 VPN 变得轻松简单。
	NetworkManager-openvpn（Fedora、openSUSE）和 network-manager-openvpn（Ubuntu）将 OpenVPN 与 Network Manager 集成。
	OpenVPN Access Server 是免费下载的，可以同时连接最多两个客户端，而无需购买许可证。 它具有附加功能，例如 Web 管理界面和使用免费 OpenVPN 访问客户端进行自动配置。 
	如果从社区 OpenVPN 开始，然后决定迁移到 OpenVPN Access Server，在社区 OpenVPN 服务器中学到的所有内容也适用于 Access Server。
3、设置简单的连接测试
	
	
Building a Linux Firewall with firewalld
	firewalld 具有很长的功能列表。其中区域是一定信任级别的容器【如，某些区域允许各种方式的传入连接请求，而有些则非常严格】。系统上的每个网络接口只能分配一个区域，一个区域可以分配给多个接口。
	重要网络概念：服务、TCP、UDP、端口转发、伪装【masquerade】、路由和IP寻址。
	传统的Linux防火墙是使用Linux内核中的 netfilter【数据包过滤框架，该框架可过滤传入和传出的网络流量】和 iptables【用于创建和管理规则表以过滤流量的软件】构建。
	现在，iptables 正在被更新的规则管理器所取代，如ufw（Uncomplicated Firewalld），nftables（Netfilter tables）和 firewalld（firewalld daemon）。
	与 iptables 和 nftables 一样，firewalld 使用规则表来管理流量过滤。它提供了一个命令行界面和一个图形界面【firewallconfig】。firewalld 是 iptables 和 nftables 的前端。
	nftables 是对 iptables 的重大改进，旨在成为 firewalld的默认后端，但在某些 Linux 发行版中 iptables仍然是默认的。使用 /etc/firewalld/firewalld.conf 中的 FirewallBackend 选项指定首选后端。
	firewalld 附带了预定义的规则集（成为区域【zones】），适用于不同的用例，如不运行服务的计算机、运行服务的计算机以及同一计算机上不同网络接口的不同区域。可以编辑这些区域以满足要求。
	firewalld 区域管理服务，这些服务是 ssh ，imaps 和 rsync 等常见服务的配置。大多数预定义服务仅包括标准端口分配。可以根据需要编辑这些并创建自定义区域。
	firewalld 与 NetworkManager集成。因此不必担心管理动态连接【如当随身携带笔记本并连接到不同的网络时】。
	》NetworkManager 服务
		自 2004 年以来，NetworkManager 一直是 Linux 的重要组成部分。NetworkManager 取代了一大堆繁琐的网络客户端工具，并管理所有网络接口和网络连接。
firewalld 概述
	Ⅰ	Firewalls 工作方式
	基本原则是拒绝一切，仅在需要时允许。
	网络服务（例如 SSH 服务器）需要打开网络端口以允许远程用户登录。sshd 的默认端口是 TCP 端口 22。可以使用 netstat 命令查看系统上的所有侦听端口。如：
		# netstat -anput | sed '2p;/ssh/!d'
		Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
		tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      855/sshd: /usr/sbin 
		tcp        0     64 192.168.3.12:22         192.168.3.4:58655       ESTABLISHED 1450/sshd: root [pr 
		tcp        0      0 192.168.3.12:22         192.168.3.4:58625       ESTABLISHED 1360/sshd: miggi [p 
		tcp6       0      0 :::22                   :::*                    LISTEN      855/sshd: /usr/sbin	
	有多种方法可以控制哪些TCP/IP数据包可以访问特定的IP地址和端口。大多数服务都有配置选项，仅侦听特定网络接口或IP地址，并接受来自特定地址和地址范围的请求。防火墙添加了额外的控制，最好同时使用这两种控制。
	Ⅱ	网络端口和编号
	Linux系统上有65,536个可能的网络端口，编号为0-65535，其中许多端口是为特定服务保留的。 0 被保留且未使用。可以在 /etc/services 文件中查看。
	官方完整列表见“IANA Service Name and Transport Protocol Port Number Registry”【https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml】
	端口编号的组织方式如下：
		①	0~1023		【well-known ports】。常见服务的系统端口，如FTPS（secure file sharing）、SSH（secure remote login）、NTP（Network Time Protocol）、POP3（email）、HTTPS（encrypted web server）等。
		②	1024~49151	【registerd ports】，用于额外的服务器
		③	49152~65535	【ephemeral ports】，临时端口，也称为私有端口和动态端口。系统可使用它们来完成与远程服务的连接。
	临时端口不是服务的侦听端口。与临时端口的连接是临时的，仅作为对计算机发出的连接请求（如访问网站）的回复而建立。防火墙可阻止临时端口，但将无法访问计算机外部的主机或站点。
1、查询正在运行的防火墙
	大多数Linux上都安装有防火墙，最常见的三个是 iptables（Internet Protocol tables）、ufw（Uncomplicated Firewalld）和 nftables（Netfilter tables）。它们都管理 netfilter 框架上的过滤器规则，该框架是Linux内核的一部分。
	使用 systemd 进行查看：
		①	systemctl status nftables.service
		②	systemctl status firewalld.service
		③	systemctl status ufw.service
	可以删除 ufw 和 nftables，或屏蔽它们以使它们无法启动：
		systemctl stop nftables.service
		systemctl mask nftables.service
		systemctl stop ufw.service
		systemctl mask ufw.service
	最好只运行一个防火墙，除非喜欢解决冲突的防火墙规则。
	》扩展
		https://firewalld.org
2、安装 firewalld
	如果系统上没有firewalld，请安装 firewalld 软件包，并安装 firewallconfig 以获得图形界面。目前，主流的Linux发行版使用相同的包名【firewalld、firewall-config】。如：
	# yum search firewalld
	上次元数据过期检查：1:11:12 前，执行于 2023年12月11日 星期一 18时10分58秒。
=	==================================================================================================== 名称 精准匹配：firewalld ==================================================================================================	firewalld.noarch : A firewall daemon with D-Bus interface providing a dynamic firewall
	firewalld 在安装后是否自动启动，具体取决于 Linux 发行版。 它必须正在运行才能创建和测试规则。
3、查看 firewalld 版本
		# firewall-cmd --version
		1.2.1
	必须运行 firewalld 才能使 firewall-cmd 命令发挥作用。如果它没有运行，将看到“FirewallD is not running”消息。
4、配置 iptables 或 nftables 作为 firewalld 的后端
	编辑 /etc/firewalld/firewalld.conf，添加如下配置：
		FirewallBackend=nftables
	或
		FirewallBackend=iptables
	重启firewalld生效。推荐设置为 nftables。
5、列出所有区域和每个区域管理的所有服务
	①	列出默认区域【zone】：
		# firewall-cmd --get-default-zone
		public
	②	列出所有区域：
		# firewall-cmd --get-zones
		block dmz drop external home internal nm-shared public trusted work
	③	列出活跃区域【当前正在使用的区域】
		# firewall-cmd --get-active-zones
		public
		  interfaces: ens33
	④	列出某个区域的配置
		# firewall-cmd --zone=public --list-all
		public (active)
		  target: default
		  icmp-block-inversion: no
		  interfaces: ens33
		  sources: 
		  services: cockpit dhcpv6-client ssh
		  ports: 
		  protocols: 
		  forward: yes
		  masquerade: no
		  forward-ports: 
		  source-ports: 
		  icmp-blocks: 
		  rich rules:
	⑤	列出所有区域的配置
			# firewall-cmd --list-all-zones
		firewalld 区域定义网络的信任级别。每个区域都包含区域描述和其他项。区域文件采用XML格式，并且必须具有 .xml 文件扩展名【见 /usr/lib/firewalld/zones 中的来源文件】。
		》区域选项：
			target					定义不匹配任何规则的数据包的默认操作。值包含：default、ACCEPT、DROP或REJECT。任何与允许的服务不匹配的数据包都会被【default】target 拒绝，并发送拒绝消息。
									ACCEPT		接受所有未被规则明确阻止的数据包
									DROP		默默地丢弃所有未被明确阻止的数据包
									REJECT		与DROP相似，另外它还会发送拒绝消息
			icmp-block-inversion	反转ICMP请求设置。任何被阻止的请求都会更改为未阻止，未阻止的请求将反转为阻止。通常设置为 no 。
			interface				定义该区域应用到的一个或多个网络接口。每个接口只能绑定一个区域，并且可以在多个接口上使用同一个区域。
			source					指定IP和MAC地址以及IP地址范围【如，可以仅接受来自本地网络、特定主机的数据包，或阻止主机或网络】
			services				该区域管理的服务列表
			ports					该区域管理的端口号列表
			protocols				该区域管理的其他TCP协议【见 /etc/protocols】
			masquerade				yes|no 。Masquerading【伪装】用于共享 IPv4 互联网连接。在除路由器之外的所有主机上将其设置为 no 。
			forward-ports			用于将来自一个端口的数据包转发到另一个端口。
			source-ports			源端口列表
			icmp-blocks				用于列出要阻止的 ICMP 类型。
			rich rules				自定义规则
		》扩展
			https://firewalld.org
			man 5 firewalld.zone
			man 1 firewall-cmd
6、列出和查询服务
	使用 firewall-cmd 命令 进行查询。如：
		# firewall-cmd --get-services
	将输出显示为单列，如：
		# firewall-cmd --get-services | xargs -n1
	firewalld 服务不仅仅是简单的端口寻址。有些服务可能包含多个目标IP地址；有些服务会打开多个监听端口。如：
	# firewall-cmd --info-service rsyncd
	rsyncd
	  ports: 873/tcp 873/udp
	  protocols:
	  source-ports:
	  modules:
	  destination:
	  includes:
	  helpers:
	可以编辑任何预定义的服务以满足要求。当向区域添加服务时，要严格使用列表中显示的名称。可以创建自定义服务；见“Add a Service”【https://firewalld.org/documentation/howto/add-a-service.html】。
7、选择和设置区域
	选择的 firewalld 区域取决于计算机正在运行的服务。如果计算机未运行任何网络服务并且仅需要网络连接，使用 drop 或 block 区域。
	drop 区域的限制最强，它会丢弃所有传入连接请求，并仅允许回复从计算机发起的连接。block 与 drop 类似，只不过它发送拒绝消息。
	其他区域在不同的Linux发行版上的配置不同，需要查看它们在系统上的配置方式，如 work 区域：
		# firewall-cmd --zone=work --list-all
		work
		  target: default
		  icmp-block-inversion: no
		  interfaces: 
		  sources: 
		  services: cockpit dhcpv6-client ssh
		  ports: 
		  protocols: 
		  forward: yes
		  masquerade: no
		  forward-ports: 
		  source-ports: 
		  icmp-blocks: 
		  rich rules: 
	必须绑定一个区域到网络接口。如【将 work 区域分配给 eth0】：
		# firewall-cmd --zone=work --permanent --change-interface=ens33
		The interface is under control of NetworkManager, setting zone to 'work'.
		success
		# firewall-cmd --zone=work --list-interfaces
		ens33
	如果希望在更改永久化之前对其进行测试，省略 --permanent 选项。这将创建一个运行时配置，并且更改会立即应用。当 firewalld 重新启动以及运行 firewall-cmd --reload 时，运行时配置将会丢失。
	将运行时配置更改为永久更改：
		# firewall-cmd --runtime-to-permanent
		success
	将区域绑定到网络接口或重新启动 firewalld 时，无需重新加载 firewalld 配置。默认区域【从最严格到最不严格】：
		①	drop		所有未经请求【unsolicited】的传入网络数据包都会被丢弃，并且没有回复。仅允许对从本计算机发起的连接进行回复的传入数据包。
						当连接到不受信任的网络并且不需要允许访问传入的SSH连接、共享文件或任何其他外部连接请求时，这是最强大的保护。
		②	block		任何传入网络连接都会被拒绝，并显示IPv4的icmp-host-prohibited消息和IPv6的icmp6-adm-prohibited消息。仅允许从系统发起的网络连接。
		③	public		接受传入的dhcpv6-client、ipp、ipp-client、mdns和ssh连接，所有其他连接均被拒绝。
		④	external	这是一个简单的互联网网关，结合了防火墙和简单的路由。仅接受传入的SSH连接，并启用IPv4伪装【masqerading】共享Internet连接。
		⑤	dmz			适用于非企业区内可公开访问的计算机。 仅接受传入的 SSH 连接。 （DMZ 是网络上面向 Internet 的服务器的独立网段。）
		⑥	work		仅接受传入ssh和dhcp6-client连接
		⑦	home		仅接受传入的ssh、mdns samba-client和dhcp6-client连接请求
		⑧	internal	与 home 一样【Only incoming ssh, mdns, samba-client, and dhcpv6-client connection requests are accepted.】
		⑨	trusted		接受所有网络连接请求
8、更改默认 firewalld 区域
	①	查看当前默认区域：
			# firewall-cmd --get-default-zone
			public
	②	将默认区域设置为 drop ：
			# firewall-cmd --set-default-zone drop
			success
		使用此命令无需重新加载 firewalld 配置或重新启动 firewalld。可以使用 NetworkManager 分配区域。 NetworkManager 会将默认区域分配给未明确分配区域的所有连接。
9、自定义 firewalld 区域
	示例【想要使用internal 区域，但默认配置并不完全是想要的】：
		# firewall-cmd --zone=internal --list-all
		internal
		  target: default
		  icmp-block-inversion: no
		  interfaces: 
		  sources: 
		  services: cockpit dhcpv6-client mdns samba-client ssh
		  ports: 
		  protocols: 
		  forward: yes
		  masquerade: no
		  forward-ports: 
		  source-ports: 
		  icmp-blocks: 
		  rich rules: 
	想要移除 samba-client 【没有使用Samba】：
		firewall-cmd --remove-service=samba-client --zone=internal
	正在运行一个小型本地 389 目录服务器，需要添加LDAPS 服务：
		firewall-cmd --add-service=ldaps --zone=internal
	这些是临时更改，重新启动或重新加载配置后将无法保留。但它们会立即应用，以便可以测试。如果测试满足预期，则可以使其永久化：
		firewall-cmd --run-to-permanent
	要放弃更改，不要使用 --run-to-permanent。相反，应使用 --reload 放弃运行时更改并恢复到原始配置。
		firewall-cmd --reload
	》扩展
		--reload			不会中断任何活跃连接
		--complete-reload	完全重新加载 firewalld，包括重载内核模块，和终止活跃连接。当运行时更改非常混乱，想要重新开始，这是一个不错的选择。
10、创建新区域
	创建一个包含区域配置的XML，然后重新加载 firewalld，即可使用。【为本地名称服务创建一个区域，其中DNS和DHCP服务器位于同一台计算机上，并具有SSH访问权限】。配置文件（/etc/firewalld/zones/names.xml）示例如下：
		<?xml version="1.0" encoding="utf-8"?>
		<zone>
			<short>Name Services</short>
			<description>
				DNS and DHCP servers for the local network, IPv4 only.
			</description>
			<service name="dns"/>
			<service name="dhcp"/>
			<service name="ssh"/>
		</zone>
	运行 firewall-cmd --get-zones 命令，新区域不会列出。添加 --permanent 选项以查看 firewalld尚未读取的任何新区域，现在会出现新的 names 区域【区域名称是不带 .xml 扩展的文件名】。
		# firewall-cmd --get-zones 
		block dmz drop external home internal nm-shared public trusted work
		# firewall-cmd --get-zones --permanent
		block dmz drop external home internal names nm-shared public trusted work
	重新加载 firewalld：
		# firewall-cmd --reload
		success
	现在 firewalld 可以读取它。
		# firewall-cmd --get-zones
		block dmz drop external home internal names nm-shared public trusted work
	查看新区域的配置：
		# firewall-cmd --zone=names --list-all
		names
		  target: default
		  icmp-block-inversion: no
		  interfaces: 
		  sources: 
		  services: dhcp dns ssh
		  ports: 
		  protocols: 
		  forward: no
		  masquerade: no
		  forward-ports: 
		  source-ports: 
		  icmp-blocks: 
		  rich rules: 
	参阅 man 5 firewalld.zone 了解配置选项，并查看 /usr/lib/firewalld/zones/ 中预定义区域的源文件作为示例。/etc/firewalld/zones中唯一的文件时用户自定义文件。通过删除 .xml 文件来移除对应区域，然后重新加载 firewalld。
11、允许或阻塞指定端口
	任何未明确允许的端口都会被所有防火墙区域拒绝，但 trusted 区域除外，该区域允许所有端口。修改sshd端口：
	①	从相关区域中移除原始端口【tcp/22】，同时添加新端口【tcp/2022】：
		firewall-cmd --zone=work --remove-port=22/tcp
		firewall-cmd --zone=work --add-prot=2022/tcp
	②	验证配置：
		firewall-cmd --zone=work --list-all
	③	将配置更改为永久：
		firewall-cmd --run-to-permanent
12、使用 Rich Rules 阻止IP地址
	要阻塞确切的IP地址。可以创建一个 rich rule【定义要阻塞的IP地址，target为reject】。如，在 internal 区域中阻塞单一IP地址：
		# firewall-cmd --zone=public --add-rich-rule='rule family="ipv4" source address="192.168.3.5" reject'
	如果不想保留这条规则，运行 firewall-cmd --reload 将其删除。要将其永久化，使用 --run-to-permanent 选项：
		# firewall-cmd --run-to-permanent
	列出区域中的 rich rule：
		# firewall-cmd --zone=public --list-rich-rules
		rule family="ipv4" source address="192.168.3.5" reject
	要删除永久规则，使用 --remove-rich-rule 选项：
		# firewall-cmd --zone=public --remove-rich-rule='rule family="ipv4" source address="192.168.3.5" reject'
	不必完全阻止违规主机。可以将阻止应用于特定服务。如【阻止SSH服务的源地址】：
		# firewall-cmd --add-rich-rule='rule family=ipv4 source address=192.168.3.5 service name=ssh reject'
	可以在一个区域中创建多个rich rule，但要小心避免冲突。
	》扩展
		man 5 firewalld.richlanguage
13、更改区域默认target
	列出当前target：
		# firewall-cmd --list-all
		public (active)
		  target: default
		  icmp-block-inversion: no
		  interfaces: ens33
		  sources: 
		  services: cockpit dhcpv6-client ssh
		  ports: 
		  protocols: 
		  forward: yes
		  masquerade: no
		  forward-ports: 
		  source-ports: 
		  icmp-blocks: 
		  rich rules: 
	将target【default】更改为 REJECT。重启并验证：
		[root@localhost ~]# firewall-cmd --permanent --set-target=REJECT
		success
		[root@localhost ~]# firewall-cmd --reload
		success
		[root@localhost ~]# firewall-cmd --list-all
		public (active)
		  target: %%REJECT%%
		  icmp-block-inversion: no
		  interfaces: ens33
		  sources: 
		  services: cockpit dhcpv6-client ssh
		  ports: 2022/tcp
		  protocols: 
		  forward: yes
		  masquerade: no
		  forward-ports: 
		  source-ports: 
		  icmp-blocks: 
		  rich rules: 
	区域 target 定义了不匹配任何规则的数据包的默认操作。target包含四种值：default、ACCEPT、REJECT、DROP。


Managing Local Name Services with Dnsmasq and the hosts File
	Dnsmasq【https://thekelleys.org.uk/dnsmasq/doc.html】是一款出色的LAN名称服务服务器，包括域名系统（DNS）和动态主机发现协议（DHCP）。Dnsmasq还提供BOOTP、PXE和TFTP，用于从网络服务器进行网络引导和安装操作系统。
	Dnsmasq支持IPv4和IPv6，提供本地DNS缓存，并充当存根解析器【stub resolver】。
	Dnsmasq专为LAN名称服务而设计。它是轻量级的并且配置简单，特别是与占主导地位的DNS服务器 BIND 相比。
	Dnsmasq 和 /etc/hosts 可以很好地协同工作。 Dnsmasq 将 /etc/hosts 中的条目读取到 DNS 中。
	Dnsmasq中的DHCP服务器自动与DNS集成。Dnsmasq为DHCP客户端创建DNS条目所需的做的就是配置DHCP客户端将其主机名发送到DHCP服务器，这是大多数Linux发行版中的默认设置。
	DNS服务器有四种类型：递归解析器、根名称服务器、顶级域（TLD）名称服务器和权威名称服务器。
	递归解析器【recuisive resolvers】应答DNS请求。存根解析器【stub resolver】（如Dnsmasq和systemd-resolved）将其无法应答的任何请求从其缓存转发到上游解析器。
	访问网站时，递归解析器通过查询其他三种类型的 DNS 服务器来查找该网站的 DNS 信息。递归解析器缓存此信息以使其更快可用。 ISP 的名称服务器以及 OpenDNS、Cloudflare 和 Google Public DNS 等服务都是递归解析器。
	根名称服务器有 13 种类型，分布在全球各地，目前有数百个根名称服务器。 根服务器接受来自递归解析器的查询，然后根服务器根据顶级域名将请求定向到适当的 TLD 服务器：.com、.net、.org、.me、.biz、.int 、.biz、.gov、.edu 等。 
	互联网名称与数字地址分配机构（ICANN）负责监督所有这些服务器和域。
	权威名称服务器是域的源记录，由域所有者控制。Dnsmasq可以作为权威名称服务器，但建议使用BIND【见 man 8 dnsmasq】
	》补充
		Linux发行版仍在从旧版resolveconf过渡到NetworkManager和systemd-resolved，后者长期以来一直是Linux上的默认DNS解析器【这给用户带来了一些麻烦，因为不断的变化以及各种发行版以不同的速度进行转换】。
		不需要在Dnsmasq服务器上运行systemd-resolved，因为他将于Dnsmasq竞争以控制系统的存根DNS服务器。
1、简单名称解析【/etc/hosts】
	可以通过 /etc/hosts 文件添加静态名称解析条目。如：
		127.0.0.1 localhost
		::1 localhost ip6-localhost ip6-loopback
		192.168.42.1 host1
		192.168.43.2 hsot2
	/etc/hosts 也管理域名，让局域网拥有一个炫酷的域名【首先输入IP地址，然后输入完全限定域名（FQDN），最后输入主机名】：
		127.0.0.1 localhost
		::1 localhost ip6-localhost ip6-loopback
		192.168.42.1 host1.sqr3l.nut host1
	/etc/hosts 中可以同时拥有共享和私有条目。想要共享的任何内容都必须复制到所有相关主机。主机文件中未复制到其他主机的任何其他内容仅适用于个人。
	注意：127.0.0.1 localhost 和 ::1 localhost ip6-localhost ip6-loopback是必需的。它们被分配给环回设备，这是Linux系统用来与其自身通信的特殊虚拟网络接口。
	环回设备的虚拟网络接口为lo。使用 ip 命令查看：
		# ip addr show dev lo
		1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
		    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
		    inet 127.0.0.1/8 scope host lo
		       valid_lft forever preferred_lft forever
		    inet6 ::1/128 scope host 
		       valid_lft forever preferred_lft forever
	系统不需要物理网络接口即可使环回设备正常工作。使用 hostname 命令确认配置是否正确。检查计算机的主机名：
		# hostname
	查看 FQDN：
		# hostname -f
	查看域名：
		# hostname -d
	/etc/hosts 不能很好地扩展，但对于小型网络来说，它可能是本地 DNS 所需要的全部。
	当运行LAN Dnsmasq服务器时，Dnsmasq服务器上的/etc/hosts中的所有条目都将应用于所有Dnsmasq客户端。Linux有多个DNS管理器，首先读取 /etc/hosts 。该顺序在/etc/nsswitch.conf文件中的主机行设置。如：
		# grep ^hosts /etc/nsswitch.conf
		hosts:      files dns myhostname
	其中 files 是 /etc/hosts。dns 是可用的DNS服务器。应该将 fils dns 首先放在 Dnsmasq 服务器上。
	》扩展
		man 5 hosts
		man 5 nsswitch.conf
3、查找网络中的所有DNS和DHCP服务器
	如果想知道LAN上除了Dnsmasq服务器之外是否还有任何DNS和DHCP服务器。使用nmap探测LAN【如，在本地网络中搜索所有开放的 TCP 端口，并找到开放的 TCP 端口 53，该端口由 DNS 使用。】
		# nmap --open 192.168.3.0/24
		Starting Nmap 7.92 ( https://nmap.org ) at 2023-12-12 19:28 CST
		Nmap scan report for 192.168.3.1
		Host is up (0.0078s latency).
		Not shown: 997 closed tcp ports (reset)
		PORT    STATE SERVICE
		53/tcp  open  domain
		80/tcp  open  http
		443/tcp open  https
		MAC Address: 14:51:20:94:4F:87 (Huawei Device)
	默认，nmap仅查询TCP端口。DNS服务器监听TCP和UDP 53，DHCP监听 UDP 67。查询指定端口【UDP 53 和 67】：
		# nmap -sU -p 53,67 192.168.3.0/24
		Starting Nmap 7.92 ( https://nmap.org ) at 2023-12-12 19:32 CST
		Nmap scan report for 192.168.3.1
		Host is up (0.0028s latency).
		
		PORT   STATE         SERVICE
		53/udp open|filtered domain
		67/udp open|filtered dhcps
		MAC Address: 14:51:20:94:4F:87 (Huawei Device)
	搜索网络中所有打开的TCP和UDP端口：
		# nmap -sU -sT 192.168.3.0/24
	注意：这可能需要一定时间，将获得网络中所有已启动主机上的活动服务的列表，包括在非标准端口上运行的任何服务。
	端口扫描时要非常小心，并且仅在您有权限的网络上使用它。 端口扫描其他网络通常被视为敌对行为，就像正在探测要利用的漏洞一样。多个名称服务器可能会导致冲突。最好了解用户是否正在运行任何服务。
4、安装 Dnsmasq
	①	安装 dnsmasq 包
		dns install dnsmasq
	②	如果Dnsmasq服务器没有静态IP地址，为其指定一个静态IP地址。使用 nmcli 查找活跃连接：
		# nmcli connection show --active
		NAME   UUID                                  TYPE      DEVICE 
		ens33  19c4fb60-d11b-319a-9ca9-2a2d3bdd5749  ethernet  ens33  
		lo     7c3c4bc2-e502-4054-9df0-79f0dc9c3db9  loopback  lo
	③	分配希望DNS服务器使用的静态IP地址，使用NAME来识别正确的连接
		# nmcli con mod "ens33" ipv4.address "192.168.3.10/24" ipv4.gateway "192.168.3.1" ipv4.method "manual"
	④	重启 NetworkManager：
		# systemctl restart NetworkManager.service
	⑤	检查是否正在运行 systemd-resolved.service
		# systemctl status systemd-resolved.service
		》补充
			systemd 在不同Linux中实现方式不同。如，openSUSE Leap 15.2 不适用systemd-resolved.service，因此不必进行任何systemd更改即可启用Dnsmasq来控制LAN DNS。
			Fedora 33 及更改版本和Ubuntu 17.04及更高版本运行systemd-resolved.service，并且应在Dnsmasq服务器上禁用它。
5、让 systemd-resolved 和 NetworkManager 与 Dnsmasq 配合良好
	systemd-resolved 和 NetworkManager 与 Dnsmasq冲突。检查 systemd-resolved.service是否正在运行：
		# systemctl status systmed-resolved.service
	systemd-resolved.service适合为客户端计算机提供stub【存根】DNS解析器，但不适用于DNS服务器，应禁用它：
		# systemctl stop systemd-resolved.service
		# systemctl disable systemd-resolved.service
	查看 /etc/resolve.conf【应该是一个符号连接，由systemd-resolve.service管理】。移除systemd-resolve.service的控制【删除符号连接，并创建同名的resolve.conf文件】。
	现在/etc/resolve.conf】由 NetworManager管理。打开 NetworkManager 配置文件，查看【[main]】部分，设置【dns=none】：
	在 /etc/resolv.conf 中输入 Dnsmasq 服务器的 IPv4 和 IPv6 本地主机地址以及本地域（如果有的话）。如：
		search miggi.nut
		nameserver 12.7.0.0.1
		nameserver ::1
	然后重新启动并配置新的Dnsmasq安装。
	NetworkManager 和 systemd-resolved 在客户端计算机上非常有用。 在 Dnsmasq 服务器上，必须控制 /etc/resolv.conf，并且 Dnsmasq 应该是唯一的存根解析器。
	》扩展
		man 8 systemd-resolved.service
		man 8 networkmanager
6、为 LAN DNS配置Dnsmasq
	在 /etc/hosts中输入的任何主机都需要静态IP地址，Dnsmasq会自动将它们输入到DNS中。至少输入 Dnsmasq 服务器。如：
		127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
		::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
		192.168.3.12 dns-server
		192.168.3.
	重命名默认配置文件【/etc/dnsmasq.conf】，以便可以从新的空文件开始，并使用原始文件作为参考。
	复制以下配置，将第二个listen-address替换为自己服务器的IP地址，并使用自己的域名。 上游名称服务器是 OpenDNS，可以使用任何想要的上游名称服务器。默认情况下，Dnsmasq会查找 /etc/resolv.conf，但明确说明也没有什么坏处：
	新的 /etc/dnamasq.conf 文件内容如下：
		# global options
		resolv-file=/etc/resolv.conf
		domain-needed
		bogus-priv
		expand-hosts
		domain=miggi.nut
		local=/miggi.nut/
		listen-address=127.0.0.1
		listen-address=192.168.3.12

		# upstream name servers
		server=208.67.222.222
		server=208.67.222.202
	进行Dnsmasq 语法检查：
		# dnsmasq --test
		dnsmasq: syntax check OK.
	语法检查器不会发现配置错误，只会发现拼写错误。启动Dnsmasq，如果出现错误则无法启动。重启 dnsmasq.service:
		systemctl restart dnsmasq.service
		systemctl status dnsmasq.service
	在 Dnsmasq 服务器上使用 nslookup 用服务器主机名和FDQN进行测试：
		# nslookup dns-server
		Server:         127.0.0.1
		Address:        127.0.0.1#53
		
		Name:   dns-server.miggi.nut
		Address: 192.168.3.10
	
		# nslookup dns-server.miggi.nut
		Server:         127.0.0.1
		Address:        127.0.0.1#53
		
		Name:   dns-server.miggi.nut
		Address: 192.168.3.10
		
		# nslookup 192.168.3.10
		10.3.168.192.in-addr.arpa       name = dns-server.miggi.nut.
	使用 ss 命令验证监听端口：
		ss -lp "sport = :domain"
	使用 -r 选项可以查看主机名而不是IP地址。
	》说明
		domain-needed		阻止 Dnsmasq 将普通主机名的查询转发到上游名称服务器。如果LAN域域公共域名相同，这可防止对LAN地址的请求泄露到世界各地，并且可能会得到错误的答复。
		bogus-priv			阻止虚假【bogus】的私有反向查找。所有在 /etc/hosts 或 DHCP 租约【release】文件中找不到的私有IP范围的反向查找都将回答“no such domain”，而不是转发到上游。
		expand-hosts		自动添加私有域名到 /etc/hosts 中的普通主机名。
		domain=				本地域名
		local=/[domain]/	告诉 Dnsmasq 直接解析本地域的查询，而不是将它们转发到上游。
7、配置 firewalld 允许 DNS 和 DHCP
	打开 TCP 和 UDP 端口 53【DNS】和 UDP 67【DHCP】。
		firewall-cmd --permanent --add-service=dns
		firewall-cmd --permanent --add-service=dhcp
8、从客户端测试 Dnsmasq服务器
	在局域网中的其他机器上使用 dig 命令通过 Dnsmasqs 服务器查询其他网站【如，baidu】：
		$ dig @192.168.3.10 baidu.com
		
		; <<>> DiG 9.11.36-RedHat-9.11.36-11.el8 <<>> @192.168.3.10 baidu.com
		; (1 server found)
		;; global options: +cmd
		;; Got answer:
		;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 3256
		;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 5, ADDITIONAL: 9
		
		;; QUESTION SECTION:
		;baidu.com.                     IN      A
		
		;; ANSWER SECTION:
		baidu.com.              600     IN      A       39.156.66.10
		baidu.com.              600     IN      A       110.242.68.66
		
		;; AUTHORITY SECTION:
		baidu.com.              557     IN      NS      ns4.baidu.com.
		baidu.com.              557     IN      NS      dns.baidu.com.
		baidu.com.              557     IN      NS      ns7.baidu.com.
		baidu.com.              557     IN      NS      ns2.baidu.com.
		baidu.com.              557     IN      NS      ns3.baidu.com.
		
		;; ADDITIONAL SECTION:
		ns7.baidu.com.          117     IN      A       180.76.76.92
		ns4.baidu.com.          127     IN      A       111.45.3.226
		ns4.baidu.com.          127     IN      A       14.215.178.80
		dns.baidu.com.          369     IN      A       110.242.68.134
		ns2.baidu.com.          79      IN      A       220.181.33.31
		ns3.baidu.com.          563     IN      A       153.3.238.93
		ns3.baidu.com.          563     IN      A       36.155.132.78
		ns7.baidu.com.          117     IN      AAAA    240e:bf:b801:1002:0:ff:b024:26de
		ns7.baidu.com.          117     IN      AAAA    240e:940:603:4:0:ff:b01b:589a
		
		;; Query time: 20 msec
		;; SERVER: 192.168.3.10#53(192.168.3.10)
		;; WHEN: Wed Dec 13 07:25:12 EST 2023
		;; MSG SIZE  rcvd: 317
	》扩展
		man 1 dig
9、使用 Dnsmasq 管理 DHCP
	DNS 正常运行后，就可以设置 DHCP了。在 /etc/dnsmasq.conf 中添加如下行来定义一个单一地址池：
		# DHCP range
		dhcp-range=192.168.3.25,192.168.3.75,12h
		dhcp-lease-max=25
	重启 Dnsmasq：
		# systemctl restart dnsmasq.service
	尝试获取 LAN 计算机上的地址。首先，确保其配置为通过DHCP获取其IP地址：
		nmcli con show --active
		nmcli con show ens33 | grep ipv..method
	重新启动网卡：
		nmcli con down ens33
		nmcli con up ens33
	在 Dnsmasq 服务器上查看日志：
		journalctl -ru dnsmasq
	》说明
		dhcp-range		定义dhcp 可用地址租用范围，和租用时间。此范围不得包括Dnsmasq服务器或任何具有静态IP地址的主机。定义租用时间（以秒、分钟或小时为单位）。默认一小时，最短为两分钟。如果希望租约不过期，不要指定租约时间。
		dhcp-lease-max	定义一次可以有多少个处于活动状态的租约。可以拥有一个较大的可用地址池，然后限制活动租约的数量。
10、通过 DHCP 发布重要服务
	可以通过 DHCP 向 LAN 客户端通告各种服务器（如Internet网关的默认路由、DNS服务器和NTP服务器）以便客户端可以自动使用它们。在 /etc/dnsmasq.conf中配置来通知某些服务：
	①	设置默认路由：
		dhcp-option=3,192.168.229.1
	②	通知 DNS 服务器：
		dhcp-option=6,192.168.229.128
	③	指出本地NTP服务器的路径：
		dhcp-option=42,192.168.229.11
	使用如下命令列出具体服务使用哪些数字：
		# dnsmasq --help dhcp
	dnsmasq --help dhcp 显示已知的DHCPv4配置选项。
11、为子网创建DHCP 区域
	可以任意指定区域名称【如，zone1、zone2】：
		dhcp-range=zone1,192.168.50.20,192.168.50.120
		dhcp-range=zone2,192.168.60.20,192.168.60.50,24h
	为区域指定路由：
		dhcp-option=zone1,3,192.168.50.1
		dhcp-option=zone2,3,192.168.60.1
	为区域指定 DNS 服务器：
		dhcp-option=zone1,6,192.168.1.10
		dhcp-option=zone2,6,192.168.1.10
	为区域指定 NTP 服务器：
		dhcp-option=zone2,42,192.168.60.15
12、从 DHCP 分配静态 IP 地址
	为了尽可能几种IP寻址，可以分配静态IP地址。在 /etc/dnsmasq.conf 使用 dhcp-host 选项。通过主机名识别客户端机器，并从LAN地址块中的分配一个未使用的地址【不必使用通过_dhcp_range=*选项定义的DHCP地址范围作为静态静态】。
	分配一个 192.168.3.0/24 网段的地址给server2：
		dhcp-host=server2,192.168.3.45
	重启 Dnsmasq ，下次 server2 请求地址时，它将收到通过 dhcp-host 选项指定的地址。使用多个 dhcp-host 选项设置多个客户端，每行一个。
	可以使用客户端的MAC地址来代替主机名。
13、配置 DHCP 客户端以实现自动 DNS 条目
	可能希望Dnsmasq自动将DHCP客户端加入DNS。客户端唯一要做的就是将其主机名发送到Dnsmasq的DHCP服务器，这是大多数Linux中的默认设置。假设本地miggi.nut域上的DHCP客户端的主机名为client4。
	client4启动，并从Dnsmasq接收其IP地址和其他网络信息。 Dnsmasq 接收 client4的主机名并将其输入到DNS中。现在网络上的其他主机可以访问client4和client4.miggit.nut。/etc/hosts 中 client4不得有任何重复条目。
	有三种不同的方法可以检查DHCP客户端配置：dhclient.conf、NetworkManager的图形配置工具（nm-connection-editor）和nmcli命令。
	①	查找活跃网络连接
		# nmcli con show --active
		NAME   UUID                                  TYPE      DEVICE
		ens33  f7d0c799-3e8e-3c6a-9256-d5df77b05383  ethernet  ens33 
	②	验证它是否将主机名发送到DHCP服务器
		nmcli connection show ens33 | grep send-hostname
		ipv4.dhcp-send-hostname:                是
		ipv6.dhcp-send-hostname:                是
	③	如果是“否【no】”，运行如下命令将其设置“是【yes】”。之后重新加载配置
		nmcli con mod ens33 ipv4.dhcp-send-hostname yes
		nmcli con mod ens33 ipv6.dhcp-send-hostname yes
		nmcli con reload
14、管理 Dnsmasq 日志
	Dnsmasq 可以选择使用旧版syslog守护进程将其消息发送到选择的文件，而不是journalctl。使用 /etc/dnsmasq.conf 中的 log-facility 选项指定日志文件。如：
		# log file
		log-facility=/var/log/dnsmasq/dnsmasq.log
	日志文件将增长的非常块，除非设置日志轮询【log rotation】。如：
		# /etc/logrotate.d/dnsmasq
		/var/log/dnsmasq/dnsmasq.log {
			missingok
			compress
			rotate 4
			weekly
			create
		}
	使用 logrotate 检查 dnsmasq 日志轮询配置：
		logrotate --debug /et/logrotate.conf
		[...]
		rotating pattern: /var/log/dnsmasq/dnsmasq.log  weekly (4 rotations)
		empty log files are not rotated, old logs are removed
		considering log /var/log/dnsmasq/dnsmasq.log
		Creating new state
		  Now: 2023-12-14 06:06
		  Last rotated at 2023-12-14 06:00
		  log does not need rotating (log has already been rotated
		[...]
15、配置通配符域【wildcard domain】
	如果想要在Dnsmasq中创建通配符域，以便解析对该域的子域的请求，而无需手动将子域添加到DNS中。可以在/etc/dnsmasq.conf文件中使用 address 选项来创建顶级域【top-level domain（TLD）】。如：
		address=/wildcard.net/192.168.1.35
	重启 Dnsmasq，使用nslookup测试：
	# nslookup foo.wildcard.net
	Server:         192.168.229.128
	Address:        192.168.229.128#53
	
	Name:   foo.wildcard.net
	Address: 192.168.1.35
	谨慎使用 DNS 通配符。 当对 Kubernetes 等复杂服务进行开发工作时，通配符非常有用。确保使用的地址范围与 LAN 名称服务器上的范围不同，并且仅适用于 LAN 客户端。


Keeping Time with ntpd, chrony, and timesyncd
	使用 NTP（网络时间协议）可以轻松自动地保持所有主机准确且相同的时间。NTP在Linux上通过ntpd（NTP守护进程）、chrony（ntpd替代平）和systemd的timesyncd来实现。
	ntpd和chrony可以充当LAN时间服务器，而timesyncd是一个更简单的轻量级客户端，没有服务器功能。ntpd和chrony是完整的NTP实现，timesyncd使用SNTP（简单网络时间协议）。
	大多数 Linux 发行版都提供了指向它们维护的时间服务器的默认配置。
	Linux系统上至少有两个计时器。一是主板上的硬件时钟，也称为实时时钟（RTC）。另一个是系统时间，由Linux内核管理。即使计算机关机，RTC也时钟通过主板上的电池或电容器供电。
	当Linux启动时，选择的NTP客户端会从RTC获取时间。然后，在网络可用后，它根据其上游时间服务器校正时间。
	RTC时间是在BIOS/UEFI中设置的。应始终将其设置为UTC（协调世界时），然后Linux内核根据UTC计算所在时区的时间。UTC与格林威治时间（GMT）类似，但并不相同。UTC是时区。UTC和GMT均不会更改夏令时（DST）。
	时区数据来自“IETF.org Timezones【https://www.ietf.org/timezones/】”。随着各国更改夏令时日期、选择退出或重新加入夏令时，这是一个不断变化的目标。大多数Linux将时区数据保存在 /usr/share/zoneinfo/。
	互联网工程任务组 (IETF) 跟踪这些变化并免费提供其数据库。
1、查看当前系统上的NTP客户端
	使用 ps 命令查看系统是否正在运行三个时间同步守护进程【ntpd、chrony、timesyncd】中的任何一个：
		ps ax | grep -w ntp
		ps ax | grep -w chrony
		ps ax | grep -w timesyncd
	如果没有运行其中之一，查看系统是否正在使用timedatectl，它是 systemd 的一部分：
		# timedatectl status
		               Local time: 四 2023-12-14 06:58:55 CST
		           Universal time: 三 2023-12-13 22:58:55 UTC
		                 RTC time: 三 2023-12-13 22:58:55
		                Time zone: Asia/Shanghai (CST, +0800)
		System clock synchronized: yes
		              NTP service: active
		          RTC in local TZ: no
		当前正在使用的NTP 时间守护进程。
		如果法相系统上同时运行了ntpd和chrony，要移除ntpd，因为chrony更新、更快、更可靠。两者同时存在可能会产生冲突。
	》扩展
		timedatectl：Control the system time and date【https://www.freedesktop.org/software/systemd/man/latest/timedatectl.html】
		man 1 ps
2、使用 timesyncd 进行简单时间同步
	使用 systemd-timesyncd 守护进程启用与公共 NTP 服务器的同步，这需要 systemd。检查systemd-timesyncd的状态：
		systemctl status systemd-timesyncd
	使用 timedatectl 启用它，并验证 systemd-timesyncd 是否已启动：
		timedatectl set-ntp true
		systemctl status systemd-timesyncd
	查看 timedatectl 报告：
		timedatectl status
	配置多个公共时间服务器以实现冗余【redundancy】是一个好习惯。编辑 /etc/systemd/timesyncd.conf 添加多个NTP服务器【通过取消注释 NTP 行并输入以空格分隔的公共服务器池列表来添加更多 NTP 服务器】：
		[Time]
		NTP=0.north-american.pool.ntp.org 1.north-american.pool.ntp.org 2.north-american.pool.ntp.org
	》说明
		在原始 /etc/systemd/timesyncd.conf 文件中，带注释的选项记录了默认配置。
		池服务器高度可靠，因为它们是单个池中的多台服务器，而不是单个服务器。为了获得最佳性能，使用所在地区的池服务器，无论是大陆池【https://www.ntppool.org/zone/@】还是国家池，可以通过单击大陆池链接找到它们。
		Linux 发行版可能会配置自己的多个服务器池。如：
			0.opensuse.pool.ntp.org 1.opensuse.pool.ntp.org 2.opensuse.pool.ntp.org
		这很好，不需要更改它，但更多样化的配置通常更可靠。
3、使用 timedatectl 手动设置时间
	使用 timedatectl 可以通过单行命令设置日期，系统时间和TRC时间。如：
		timedatectl set-time "2023-12-14 07:19:00"
	注意：当 system-timesyncd 正在运行时，无法执行此操作。必须停止它：
		systemctl stop system-timesyncd
		# timedatectl set-ntp false
		# timedatectl set-time "2023-12-14 07:28"
		# timedatectl status
		               Local time: 四 2023-12-14 07:28:06 CST
		           Universal time: 三 2023-12-13 23:28:06 UTC
		                 RTC time: 三 2023-12-13 23:28:06
		                Time zone: Asia/Shanghai (CST, +0800)
		System clock synchronized: no
		              NTP service: inactive
		          RTC in local TZ: no
	如果重启 systemd-timesyncd ，将会覆盖手动设置。
	timedatectl 有一小部分命令。如果习惯使用 date 命令设置时间以及其他时间和日期操作，timedatectl 可能看起来很轻量。它的设计很简单，而且仍然可以使用日期和众多选项来完成复杂的任务。
4、使用 chrony 作为 NTP 客户端
	首先，检查 ntpd 是否已安装。如果已安装，将其卸载。如果有 systemd-time，则禁用它。在大多数Linux发行版上，其包名为 chrony。安装后，使用 chronyc 命令检查其状态。如：
		# chronyc activity
		200 OK
		4 sources online
		0 sources offline
		0 sources doing burst (return to online)
		0 sources doing burst (return to offline)
		0 sources with unknown address
	查看 chrony.conf 文件，要么是 /etc/chrony.conf【Fedora】或 /etc/chrony/chrony.conf【Ubuntu】。无需进行太多更改（如果有的话）即可将其用作客户端。 检查 NTP 服务器列表，将在其中看到服务器【server】和池【pool】选项。
	可以指定多个池来提供可靠性。如：
		pool 0.ubuntu.pool.ntp.org iburst
		pool 1.ubuntu.pool.ntp.org iburst
		pool 0.north-america.pool.ntp.org iburst
		pool 1.north-america.pool.ntp.org iburst
		server ntp.domain.lan iburst prefer
	更改配置后，重启chrony。
	》说明
		iburst		表示网络中断后快速同步
		prefer		表示始终使用该服务器【除非它不可用】
	这是客户端设置所需要做的全部工作。chrony 是一个完整的 NTP 实现并且有很多选项；有关完整说明，见 man 5 chrony.conf。
	chrony 比 ntpd 有几个优点。 作为客户端的主要优点是更好地处理中断的网络连接以及在连接恢复时更快地重新同步。
	使用如下命令管理 chronyd：
		systemctl status chronyd
		systemctl start chronyd
		systemctl stop chronyd
		systemctl restart chronyd
	》补充
		chrony【https://chrony-project.org/】
		man 5 chrony.conf
		man 1 chronyc

5、使用 chrony 作为 LAN 时间服务器
	禁用 systemd-timesyncd 和移除 ntpd【如果有】。安装 chrony 包。编辑配置文件【/etc/chrony.conf】。基本配置如下：
		pool 0.north-america.pool.ntp.org iburst
		pool 1.north-america.pool.ntp.org iburst
		pool 2.north-america.pool.ntp.org iburst

		local stratum 10
		allow 192.168.0.0/16
		allow 2001:db8::/56

		driftfile /var/lib/chrony/chrony.drift
		maxupdateskew 100.0
		rtcsync
		logdir /var/log/chrony
		log measurements statistics tracking
		leapsectz right/UTC
		makestep 1 3
	将 chrony 服务器的名称添加到客户端的 chrony.conf 文件中。如：
		server ntp.domain.lan iburst prefer
		pool 1.north-america.pool.ntp.org iburst
		pool 2.north-america.pool.ntp.org iburst
	》说明
		prefer	选项意味着只要该服务器可用，就始终使用该服务器。保留本地时间服务器的原因之一是减少公共时间服务器的负载。使用 prefer 选项，可以将一些公共服务器配置为备份，以防本地服务器不可用，并且不用担心给它们带来负担。
		local stratum 10	配置 chrony继续充当本地 NTP 服务器，即使网络连接已中断，【stratum 10】将服务器安全地置于strata【层】层次结构中，因此它低于正在使用地任何外部 NTP 服务器。允许的值是1~15。
				不要使用小于 10 的数字，使用10以外的数字，以防此配置使第10层广受欢迎。
		allow	定义允许使用 NTP 服务器的网络
		rtcsync	告诉 chrony 让 RTC 与系统时间保持同步
		log		启用日志，定义想要记录日志的事件
	可以在 man 5 chrony.conf 或默认的 chrony.conf中查找其他选项，这些选项通常都有很好的注释。
6、查看 chrony 统计数据
	如果想要调用一些实时事件活动或统计数据，如上游 NTP 服务器、偏移量、偏差、当前与哪个服务器同步以及其他信息。使用 chronyc 命令。tracking 子命令显示已应用的校正量、RTC时间、偏差和其他信息。如：
		# chronyc tracking
		Reference ID    : CA264007 (netfee.ustc.edu.cn)
		Stratum         : 3
		Ref time (UTC)  : Thu Dec 14 17:52:03 2023
		System time     : 0.000604910 seconds fast of NTP time
		Last offset     : +0.000570577 seconds
		RMS offset      : 0.005902512 seconds
		Frequency       : 6.825 ppm fast
		Residual freq   : +0.017 ppm
		Skew            : 0.845 ppm
		Root delay      : 0.026057655 seconds
		Root dispersion : 0.011448450 seconds
		Update interval : 520.5 seconds
		Leap status     : Normal
	列出当前源服务器：
		# chronyc sources
		MS Name/IP address         Stratum Poll Reach LastRx Last sample               
		===============================================================================
		^? ntp.domain.lan                0   6     0     -     +0ns[   +0ns] +/-    0ns
		^? ntp.wdc2.us.leaseweb.net      2   6     1     3    -41ms[  -41ms] +/-  311ms
		^? time.neu.edu.cn               1   6     1     3    +31ms[  +31ms] +/-   60ms
		^? sv1.ggsrv.de                  2   6     1     3   +904us[ +904us] +/-  169ms
		^? stratum2-1.ntp.mow01.ru.>     0   6     0     -     +0ns[   +0ns] +/-    0ns
		^? dns2.synet.edu.cn             1   6     1     3   +854us[ +854us] +/-   33ms
		^? ntp6.flashdance.cx            2   6     1     4   -330us[ -330us] +/-  116ms
		^? tock.ntp.infomaniak.ch        1   6     1     4   +288us[ +288us] +/-  111ms
		^? cn.pool.ntp.org               1   6     1     4  -6089us[-6089us] +/-   30ms
	列出当前的源服务器，并附上说明：
		# chronyc sources -v
		
		  .-- Source mode  '^' = server, '=' = peer, '#' = local clock.
		 / .- Source state '*' = current best, '+' = combined, '-' = not combined,
		| /             'x' = may be in error, '~' = too variable, '?' = unusable.
		||                                                 .- xxxx [ yyyy ] +/- zzzz
		||      Reachability register (octal) -.           |  xxxx = adjusted offset,
		||      Log2(Polling interval) --.      |          |  yyyy = measured offset,
		||                                \     |          |  zzzz = estimated error.
		||                                 |    |           \
		MS Name/IP address         Stratum Poll Reach LastRx Last sample
		===============================================================================
		^? ntp.domain.lan                0   8     0     -     +0ns[   +0ns] +/-    0ns
		^? ntp.wdc2.us.leaseweb.net      2   6     7    32  -3359us[-3359us] +/-  257ms
		^? time.neu.edu.cn               1   6     7    32  +6133us[+6133us] +/-   32ms
		^? sv1.ggsrv.de                  2   6     7    32    -30ms[  -30ms] +/-  158ms
		^? stratum2-1.ntp.mow01.ru.>     2   6     3    34  -5069us[-5069us] +/-   71ms
		^? dns2.synet.edu.cn             1   6     7    33  +8384us[+8384us] +/-   39ms
		^? ntp6.flashdance.cx            2   6     7    34    +10ms[  +10ms] +/-  126ms
		^? tock.ntp.infomaniak.ch        1   6     7    33  +5351us[+5351us] +/-  108ms
		^? cn.pool.ntp.org               1   6     7    34    -57ms[  -57ms] +/-   82ms
	【*】显示系统当前正在与哪个服务器同步。
	》说明
		chrony会针对客户端计算机上的网络延迟和等待时间、间歇性连接以及睡眠和休眠模式进行调整。chrony 始终永远不会停止，即使外部名称服务器不可用，它也能使网络保持同步。
	》补充
		man 1 chronyc
		chrony.tuxfamily.org【https://chrony-project.org/】
7、使用 ntpd 作为 NTP 客户端
	首先，确保 ntpd 是系统上唯一的 NTP 客户端。在大多数Linux发行版上，查找要安装的ntp软件包。在大多数Linux发行版上，ntpd 都带有有用的配置，并在安装后启动。使用 ps 命令检查：
		ps ax | grep -w ntpd
	如果 ntpd没有自动启动，启动它：
		systemctl start ntpd
	ntpd 的配置文件通常是 /etc/ntpd.conf。默认配置应该可以正常工作，无需更改。如果网络有自己的LAN服务器，以下配置将本地服务器设置为主服务器，并将一个Fedora Linux 服务器池作为后备服务器。：
		server ntp.domain.lan iburst prefer
		pool 2.fedora.pool.ntp.org iburst
	可以保留默认配置，这在大多数情况下都可以正常工作。 Linux 发行版通常维护自己的 NTP 服务器池并在默认配置中提供这些服务器池。 
	如果希望替换这些服务器，或添加一些外部公共服务器，请参阅大陆池（contiental pools【https://www.ntppool.org/zone/@】）以获取大陆 NTP 服务器池列表，或使用您所在的国家/地区池（您可以通过单击大陆池链接找到该池）。
	当更改 /etc/ntpd.conf后，重启 ntpd：
		systemctl restart ntpd
		/etc/init.d/ntp restart
	检查它是否与 ntpq 一起工作。 星号【*】表示机器正在与哪个 NTP 服务器同步。
		ntpq -p
	》补充
		man 5 ntp.conf
		man 8 ntpd
		man 8 ntpq
		NTP 文档【https://www.ntp.org/documentation/】
8、使用 ntpd 作为 NTP 服务器
	使用 ntpd 作为 LAN 时间服务器与使用它作为 NTP 客户端类似。配置几乎相同，只是添加了一些访问控制。/etc/ntpd.conf 的完整配置如下：
		driftfile /var/lib/ntp/drift

		restrict default nomodify notrap noquery
		restrict -6 default nomodify notrap nopeer noquery
		restrict 127.0.0.1
		restrict ::1

		pool 0.cn.pool.ntp.org
		pool 1.cn.pool.ntp.org
		pool 2.cn.pool.ntp.org

		leapfile /usr/share/zoneinfo/leap-seconds.list

		statistics clockstats loopstats peerstats
		filegen loopstats file loopstats type day enable
		filegen peerstats file peerstats type day enable
		filegen clockstats file clockstats type day enable
		statsdir /var/log/ntpstats/
	》说明
		driftfile 是 ntpd 跟踪由主板上石英晶体振荡频率波动引起的时间漂移的地方。有以下选择：
		restrict default	拒绝所有内容，仅允许明确允许的内容，并设置默认值。
		nomodify			不允许其他时间服务器对系统进行任何更改。允许查询。
		notrap				禁用远程日志
		nopeer				不允许对等互连。对等服务器相互同步，因此唯一允许提供时间服务的服务器由 server 和 pool 指令指定。
		noquery				不允许远程查询和远程日志记录
		restrict 127.0.0.1	信任 localhost
		restrict ::1		信任 localhost
		statistics 			将选择的统计信息记录到 /var/log/ntpstats/中。这不是必需的，但对于跟踪哪些上游NTP服务器具有最佳性能可能更有趣。
	》扩展
		man 5 ntp.conf
		man 8 ntpd
		man 8 ntpq
		NTP 文档【https://www.ntp.org/documentation/】
9、使用 timedatectl 管理时区
	使用 timedatectl 查看当前时区：
		# timedatectl | grep -i "time zone"
		                Time zone: Asia/Shanghai (CST, +0800)
	列出所有时区：
		# timedatectl list-timezones
	设置时区：
		# timedatectl set-timezone Asia/Shanghai
	更改会立即生效。
	》说明
		当与不同时区的人员合作时，使用UTC来协调会议时间。有多种在线时区转换器，如 Time Zone Converter【https://www.timeanddate.com/worldclock/converter.html】。
		必须使用 timedatectl list-timezones显示的格式【region/city】来设置时区。这是由 ISO 8601 标准定义的，该标准定义了表达时区、时间和日期的明确标准。 该标准使用“降序表示法”，即按顺序从最大值到最小值。
		如，对于时区，顺序是 continent/country/city。US把日期写成“年-日-月”不符合这个标准。“年-月-日”为标准，年份为四位数【YYYY-MM-DD】，时间为【HH:MM:SS】，采用24小时制格式。
	》扩展
		man 1 timedatectl
10、不使用 timedatectl 管理时区
	如果系统没有systemd，可以使用 date 管理时区。如查看当前时区：
		# date
		2023年 12月 15日 星期五 04:18:52 CST
	或，查看 /etc/localtime 链接到哪个文件：
		# ls -l /etc/localtime
		lrwxrwxrwx. 1 root root 35 12月 13 21:40 /etc/localtime -> ../usr/share/zoneinfo/Asia/Shanghai
	/usr/share/zoneinfo 目录包含所有时区。在其子目录中可以查找机器所在区域的时区。通过更改 /etc/local链接到的文件可以更改时区。
		# ls /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
	更改会立即生效。


Troubleshooting Networks
1、使用 ping 测试连接性
	当调试网络问题时，由近到远【这意味着物理距离以及需要跨越的路由器数量】。从本地LAN网段开始，然后如果有多个LAN网段，穿过路由器，进入下一个LAN网段。然后到下一台路由器，依次类推。
	从 ping 开始测试连接性。首先 ping localhost。确认网络接口已启动并正在运行。 如果看到“connect: Network is unreachable”，则表明网络接口存在问题。准备一些备用的 USB 网络接口，以便快速了解接口是否有缺陷。
	对网络接口进行测试后，对主机名进行 ping 操作以测试名称解析，如【在3次 ping 操作后停止】：
		ping -c 3 client4.miggi.nut
	如果返回正确的IP地址，说明名称解析设置正确。如果返回本机地址【如127.0.0.1】，或“Name or service not known”，则DNS配置出了问题。
	当本地DNS修复后，通过主机名 ping 网络主机。如果 ping 失败并显示“Destination Host Unreachable”，尝试 ping 其IP地址。如果成功，检查DNS。如果失败并显示相同的消息，则主机名和地址不正确，或主机已关闭。
	如果无法访问任何外部 IP 地址，则网络接口可能正常，问题出在上游：以太网电缆、无线接入点或交换机。 “Network is unreachable”表示机器未连接到网络。
	当寻找间歇性中断的根源时，将 ping 设置为运行一端时间【如，500次 ping ，间隔 2秒】。这样就不会压垮主机或网络，并将结果输出到文件中：
		# ping -c 500 -i 2 server2 >> server2-ping.txt
		# ping -c 500 -i 2 server | tee server2-ping.txt
	在多宿主主机上，使用 ping -i interface-name 指定要使用的接口。
	》说明
		不要阻止回显请求【echo-request】、回显应答【echo-reply】、超时【time-exceeded】或目标无法到达【destination-unreach】的ping消息。
		在防火墙上阻止所有 ping 消息，这是一个错误，因为许多网络功能至少需要这四个ping消息才能正常运行。
2、使用 fping 和 nmap 分析网络
	如果想生成网络上所有主机和IP地址的列表，并探测MAC地址和开放端口。可以使用 fping 和 nmap 探测 LAN，并记录结果。
	fping 按顺序 ping 某个范围内的所有地址。如 ping 一次子网，报告哪些主机处于活动状态，查询DNS的主机名，并打印摘要：
		fping -c1 -gAds 192.168.3.0/24 2>1 | egrep -v "ICMP|xmt" >> fping.txt
	如下 nmap 示例执行类似的任务，但输出更简洁：
		nmap -sn 192.168.3.0/24 > nmap.txt
	探测网络上的主机是否有开放端口：
		nmap -sS 192.168.3.*
	收集主机及其IP地址的列表：
		nmap -sn 192.168.3.0/24 | grep 'Nmap scan report for' | cut -d' ' -f5,6
	》说明
		nmap有许多用于探测网络的选项。未经许可，请勿探测他人的网络，因为这可能视为探测漏洞的行为。
		运行端口扫描需要一定时间，但组好定期执行此操作以查看网络上发生的情况。仅运行必要的服务并禁用其他所有服务是基本的安全性。
	》扩展
		man 1 nmap
		https://nmap.org
		man 8 fping
		https://fping.org
3、使用 arping
	①	概述
		arping 是一个用于在网络中探测主机的工具。不同于 ping【工作在网络层】，arping工作在数据链路层，使用 ARP 协议。使用它包括向目标主机发送 ARP 请求并等待 ARP 回复。
	②	基本使用
		# arping 192.168.229.153
		ARPING 192.168.229.153 from 192.168.229.128 ens36
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  0.836毫秒
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  1.774毫秒
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  1.523毫秒
		如果不指定任何选项， arping 一直发送 ARP 请求。每行末尾的持续时间是每个ARP请求和回复之间经过的时间。通过，arping 首先发送广播消息。如果它收到 ARP 回复，则会切换到单播【Unicast】。
	③	发送特定数量的 ARP 请求
		可以通过 -c 选项传递所需数量的 ARP 请求。如：
		# arping -c 2 192.168.229.153
		ARPING 192.168.229.153 from 192.168.229.128 ens36
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  1.047毫秒
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  3.071毫秒
		Sent 2 probes (1 broadcast(s))
		Received 2 response(s)
	④	在第一次回复后停止 ARP 请求
		使用 -f 选项，可以判断 arping 一旦收到目的地的第一个回复就停止发送 ARP 请求：
		# arping -f 192.168.229.153
		ARPING 192.168.229.153 from 192.168.229.128 ens36
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  0.984毫秒
		Sent 1 probes (1 broadcast(s))
		Received 1 response(s)
	⑤	一段时间后停止 ARP 请求
		arping 还可以使用 -w 选项在特定时间段后停止发送 ARP 请求：
		# date; arping -w 5 192.168.229.153; date
		2023年 12月 16日 星期六 04:22:19 CST
		ARPING 192.168.229.153 from 192.168.229.128 ens36
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  0.782毫秒
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  3.148毫秒
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  2.631毫秒
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  3.273毫秒
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  3.306毫秒
		Sent 6 probes (1 broadcast(s))
		Received 5 response(s)
		2023年 12月 16日 星期六 04:22:24 CST
		如果同时 -c 和 -w。在这种情况下，arping会继续执行ping操作，当到达到某个选项后会停止ping。
	⑥	指定网络接口
		如果本地主机有多个网络接口，必须使用-I 选项显示指定接口。否则，arping 会出错：
		arping -f -I ens33 192.168.229.153
	⑦	仅发送 MAC 级别的广播【broadcasts】
		通常，arping 首先将 ARP 请求作为MAC广播发送，但，当它收到对广播ARP请求的答复时，它会切换到单播。它开始仅向目标主机发送ARP请求。使用-b选项可以更改此行为并仅发送广播。
		# arping -b -c 2 192.168.229.153
		ARPING 192.168.229.153 from 192.168.229.128 ens36
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  0.854毫秒
		Unicast reply from 192.168.229.153 [00:0C:29:97:76:2E]  1.514毫秒
		Sent 2 probes (2 broadcast(s))
		Received 2 response(s)
	⑧	运行在Unsolicited ARP模式下
		可以使用-U选项来在主动ARP模式下运行arping。主动ARP也称为免费ARP。主动ARP在相邻主机提出请求之前更新相邻主机的ARP表。
		这可能很有用，如，当本地主机的MAC或IP地址因故障转移而更新时。未经请求的ARP将此更改传播到其他主机。在这种情况下预计不会有ARP回复。使用-U选项跟新目的主机的ARP表：
		# arping -U -c 1 192.168.3.15
		arping: bind: 无法指定被请求的地址【可能是由于有多个网卡的原因】
		# arping -U -s 192.168.3.10 -c 1 192.168.3.14
		ARPING 192.168.3.14 from 192.168.3.10 ens33
		Unicast reply from 192.168.3.14 [80:32:53:67:62:18]  6.084毫秒
		Sent 1 probes (1 broadcast(s))
		Received 1 response(s)
		》注意：
			默认情况下，不允许使用未经请求的ARP更新在ARP表中创建新条目。因此，必须将目标主机的arp_accept内核参数设置为1。如：
				sysctl net.ipv4.conf.all.arp_accept # Unsolicited ARP isn't allowed
				net.ipv4.all.arp_accept = 0
				sysctl net.ipv4.conf.all.arp_accept=1 # Now, unsolicited ARP is allowed
	⑨	仅发送 ARP 回复
		arping 使用 -A 选项也会更新目标主机的ARP表。但，它不使用主动ARP，而是使用ARP回复，就像发出ARP请求一样：
		# arping -A -c 1 192.168.3.14
		arping: bind: 无法指定被请求的地址 【可能是由于有多个网卡的原因】
		# arping -A -s 192.168.3.10 -c 1 192.168.3.14
		ARPING 192.168.3.14 from 192.168.3.10 ens33
		Sent 1 probes (1 broadcast(s))
		Received 0 response(s)
	⑩	指定源IP地址
		arping 自动分配ARP数据包中的源IP地址。不过，也可使用 -s 选项手动设置。为了能够使用-s选项设置源IP地址，必须能够绑定不是本机的。
		通常，此功能被禁用。可以通过将net.ipv4.ip_nonlocal_bind 内核参数设置为1来启用它。
		# arping -c 1 -s 192.168.3.20 192.168.3.14
		arping: bind: 无法指定被请求的地址
		# sysctl net.ipv4.ip_nonlocal_bind
		net.ipv4.ip_nonlocal_bind = 0
		# systemctl net.ipv4.ip_nonlocal_bind=1
		# arping -c 1 -s 192.168.3.20 192.168.3.14
		ARPING 192.168.3.14 from 192.168.3.20 ens33
		Unicast reply from 192.168.3.14 [80:32:53:67:62:18]  7.758毫秒
		Sent 1 probes (1 broadcast(s))
		Received 1 response(s)
	⑩ ①	在重复地址检测模式下运行
		将-D选项传递给arping，以在重复地址检测（DAD）模式下运行它。如果网络中的另一台主机正在使用目标IP地址，则arping会检测到此情况并返回1.如果没有重复的IP地址，则返回0。
		# arping -D -c 1 192.168.3.10
		ARPING 192.168.3.10 from 0.0.0.0 ens33
		Unicast reply from 192.168.3.10 [00:0C:29:98:3C:14]  1.079毫秒
		Sent 1 probes (1 broadcast(s))
		Received 1 response(s)
		echo $?
		1
		arping -D -c 1 192.168.3.20
		ARPING 192.168.3.20 from 0.0.0.0 ens33
		Sent 1 probes (1 broadcast(s))
		Received 0 response(s)
		[root@localhost ~]# echo $?
		0
		在DAD模式下，使用arping将源IP地址自动设置为0.0.0.0。
		》注意：前提是源主机只有一个网络接口
	》补充
		arp 是地址解析协议【Address Resolution Protocol】，将IP地址与MAC地址进行匹配。
		当 ping不到主机时，arping可用于查看主机是否已启动。直接阻止ping不是一件好事【因为它对于网络功能至关重要】。如果不禁用网络主机相同通信的能力，则无法阻止arping。
		arp维护MAC地址表，。当网络主机向另一台主机发送数据包时，arp将IPdizhi与MAC地址进行匹配，然后即可将数据包传递出去。
		可以使用像 tcpdump 这样的数据包探针来查看arp探测网络以更新其地址表时的情况。如：
		# tcpdump -pi ens33 arp
		dropped privs to tcpdump
		tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
		listening on ens33, link-type EN10MB (Ethernet), snapshot length 262144 bytes
		05:47:18.434897 ARP, Request who-has 192.168.3.10 tell 192.168.3.4, length 46
		05:47:29.693468 ARP, Request who-has localhost.localdomain (Broadcast) tell 192.168.3.10, length 46
		05:47:29.693484 ARP, Reply localhost.localdomain is-at 00:0c:29:97:76:24 (oui Unknown), length 28
		05:47:29.758858 ARP, Request who-has localhost.localdomain tell 192.168.3.4, length 46
		05:47:29.758905 ARP, Reply localhost.localdomain is-at 00:0c:29:97:76:24 (oui Unknown), length 28
		05:47:30.706911 ARP, Request who-has localhost.localdomain (00:0c:29:97:76:24 (oui Unknown)) tell 192.168.3.10, length 46
		05:47:30.706952 ARP, Reply localhost.localdomain is-at 00:0c:29:97:76:24 (oui Unknown), length 28
		05:47:31.699487 ARP, Request who-has localhost.localdomain (00:0c:29:97:76:24 (oui Unknown)) tell 192.168.3.10, length 46
		05:47:31.699499 ARP, Reply localhost.localdomain is-at 00:0c:29:97:76:24 (oui Unknown), length 28
		05:47:32.698401 ARP, Request who-has localhost.localdomain (00:0c:29:97:76:24 (oui Unknown)) tell 192.168.3.10, length 46
		05:47:32.698434 ARP, Reply localhost.localdomain is-at 00:0c:29:97:76:24 (oui Unknown), length 28
		05:47:33.705699 ARP, Request who-has localhost.localdomain (00:0c:29:97:76:24 (oui Unknown)) tell 192.168.3.10, length 46
		05:47:33.705735 ARP, Reply localhost.localdomain is-at 00:0c:29:97:76:24 (oui Unknown), length 28
		05:47:35.188471 ARP, Request who-has _gateway tell localhost.localdomain, length 28
		05:47:35.190763 ARP, Reply _gateway is-at 14:51:20:94:4f:87 (oui Unknown), length 46
		05:47:40.226238 ARP, Request who-has localhost.localdomain tell _gateway, length 46
		05:47:40.226259 ARP, Reply localhost.localdomain is-at 00:0c:29:97:76:24 (oui Unknown), length 28
		05:47:43.434226 ARP, Request who-has 192.168.3.6 tell 192.168.3.6, length 46
		05:47:43.435449 ARP, Request who-has 192.168.3.6 tell _gateway, length 46
		05:47:45.329655 ARP, Request who-has localhost.localdomain (0c:54:15:88:17:5b (oui Unknown)) tell 192.168.3.4, length 46
		05:47:45.329710 ARP, Reply localhost.localdomain is-at 00:0c:29:97:76:24 (oui Unknown), length 28
		05:48:00.022940 ARP, Request who-has 192.168.3.15 tell 192.168.3.5, length 46
	》扩展
		man 8 arping
4、使用 httping 测试 HTTP 吞吐量【throughput】和延迟【latency】
	》准备：
		rpm包：https://rhel.pkgs.org/8/epel-x86_64/httping-2.5-8.el8.x86_64.rpm.html
	httping测试HTTP服务器的吞吐量和延迟。最简单的测试延迟调用如下：
		# httping -c4 -l -g www.baidu.com
		PING www.baidu.com:443 (/):
		connected to 183.2.172.185:443 (312 bytes), seq=0 time= 40.91 ms 
		connected to 183.2.172.185:443 (312 bytes), seq=1 time= 38.43 ms 
		connected to 183.2.172.185:443 (312 bytes), seq=2 time= 37.01 ms 
		connected to 183.2.172.185:443 (312 bytes), seq=3 time= 48.95 ms 
		--- https://www.baidu.com/ ping statistics ---
		4 connects, 4 ok, 0.00% failed, time 4173ms
		round-trip min/avg/max = 37.0/41.3/48.9 ms
	这并没有告知加载页面需要多长时间，而只是告知服务器响应HEAD请求需要多长时间（单位毫秒），该请求仅获取页面标题而不获取内容。GET（-G）请求获取整个页面：
		# httping -c4 -l -Gg www.baidu.com
		PING www.baidu.com:443 (/):
		connected to 183.2.172.185:443 (1138 bytes), seq=0 time= 43.13 ms 
		connected to 183.2.172.185:443 (853 bytes), seq=1 time= 44.08 ms 
		connected to 183.2.172.185:443 (853 bytes), seq=2 time= 49.22 ms 
		connected to 183.2.172.185:443 (853 bytes), seq=3 time= 44.17 ms 
		--- https://www.baidu.com/ ping statistics ---
		4 connects, 4 ok, 0.00% failed, time 4188ms
		round-trip min/avg/max = 43.1/45.1/49.2 ms
	添加 -r 开关，通过仅解析一次主机名来最大程度地减少DNS延迟：
		# httping -c4 -l -rGg www.baidu.com
		PING www.baidu.com:443 (/):
		connected to 183.2.172.185:443 (1138 bytes), seq=0 time= 34.25 ms 
		connected to 183.2.172.185:443 (871 bytes), seq=1 time= 38.98 ms 
		connected to 183.2.172.185:443 (871 bytes), seq=2 time= 56.38 ms 
		connected to 183.2.172.185:443 (871 bytes), seq=3 time= 43.29 ms 
		--- https://www.baidu.com/ ping statistics ---
		4 connects, 4 ok, 0.00% failed, time 4189ms
		round-trip min/avg/max = 34.2/43.2/56.4 ms
	如果最大限度地减少DNS延迟会产生很大的影响，那么需要检查名称服务器。
	通过在URL后追加端口号来测试指定端口【如，8080】：
		# httping -c4 -l -rGg www.baidu.com:8080
		PING www.baidu.com:8080 (/):
	使用 -s 开关显示返回码：
		# httping -c4 -l -srGg www.baidu.com
		PING www.baidu.com:443 (/):
		connected to 183.2.172.185:443 (1138 bytes), seq=0 time= 32.95 ms 200 OK
		connected to 183.2.172.185:443 (865 bytes), seq=1 time= 33.13 ms 200 OK
		connected to 183.2.172.185:443 (865 bytes), seq=2 time= 32.36 ms 200 OK
		connected to 183.2.172.185:443 (865 bytes), seq=3 time= 38.94 ms 200 OK
		--- https://www.baidu.com/ ping statistics ---
		4 connects, 4 ok, 0.00% failed, time 4147ms
		round-trip min/avg/max = 32.4/34.3/38.9 ms
	》说明
		在一天的不同时间运行多个测试来收集代表用户体验的数据。httping 并不是一个超级复杂的测试程序，可以深入挖掘站点来识别瓶颈。它是一个快速、简单的工具，可用于了解站点的整体性能，并告诉是否需要深入挖掘来诊断性能问题。
	》扩展
		HTTP return codes【https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html】
		man 1 httping
		httping【https://www.vanheusden.com/httping/】
5、使用 mtr 查找有问题的路由器
	使用 mtr （My Traceroute）查找数据包在哪里误入歧途。这在控制的网络上效果更好，因为互联网很大并且路由会变化，但当无法访问某个网站时，它会提供有用的信息。如：
		# mtr -wo LSRABW baidu.com
		Start: 2023-12-16T19:43:38+0800
		HOST: localhost.localdomain Loss%   Snt   Rcv   Avg  Best  Wrst
		  1.|-- _gateway               0.0%    10    10   3.2   2.6   4.5
		  2.|-- TianYi.Home            0.0%    10    10   3.8   3.1   4.8
		  3.|-- 100.64.0.1             0.0%    10    10   5.7   5.1   6.5
		  4.|-- 113.98.87.205         30.0%    10     7   7.9   4.9  16.2
		  5.|-- 58.62.247.65          50.0%    10     5   5.7   5.3   6.3
		  6.|-- 202.97.109.190        20.0%    10     8  36.7  35.4  39.5
		  7.|-- ???                   100.0    10     0   0.0   0.0   0.0
		  8.|-- 219.158.41.21         70.0%    10     3  40.7  39.0  43.2
		  9.|-- 219.158.3.5           70.0%    10     3  40.7  39.6  42.7
		 10.|-- 219.158.11.94         30.0%    10     7  41.7  41.0  43.0
		 11.|-- 110.242.66.166         0.0%    10    10  42.6  41.5  44.3
		 12.|-- 221.194.45.130         0.0%    10    10  41.6  41.0  42.1
		 13.|-- ???                   100.0    10     0   0.0   0.0   0.0
		 14.|-- ???                   100.0    10     0   0.0   0.0   0.0
		 15.|-- ???                   100.0    10     0   0.0   0.0   0.0
		 16.|-- ???                   100.0    10     0   0.0   0.0   0.0
		 17.|-- baidu.com              0.0%    10    10  44.7  43.5  46.2
	其中【Loss%】显示数据包丢失情况。如果mtr发现问题，使用whois 查找域名所有者及其联系信息：
		# whois -H 221.194.45.130
		% [whois.apnic.net]
		% Whois data copyright terms    http://www.apnic.net/db/dbcopyright.html
		
		% Information related to '221.192.0.0 - 221.195.255.255'
		
		% Abuse contact for '221.192.0.0 - 221.195.255.255' is 'zhaoyz3@chinaunicom.cn'
		
		inetnum:        221.192.0.0 - 221.195.255.255
		netname:        UNICOM-HE
		descr:          China Unicom Hebei Province Network
		descr:          China Unicom
		country:        CN
		[...]
	whois 适用于域名、IP地址。-H选项禁用法律术语。
	将 mtr 输出捕获到文件中，并在每个条目的末尾添加日期和时间。如：
		mtr -r -c25 oreilly.com >> mtr.txt && date >> mtr.txt
	》说明：
		mtr -wo LSRABW 限制列数。mtr -w 是报告的宽格式。
		mtr 产生大量流量，因此注意不要运行得太频繁。
	》扩展
		man 8 mtr
		man 1 whois
	


		

		
		
	




		


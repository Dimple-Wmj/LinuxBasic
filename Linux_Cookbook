Managing Users and Groups
	Linux包含两种用户：人类用户和系统用户。每个用户都有一个独一的身份（UID）和至少一个组标识（GID）。所有用户都有一个主要组，并且可能是多个组的成员。
	每个用户都有一个家目录（位于/home目录下，一般以用户名命名）。用户可能属于多个组，这种额外的组关系叫作附加组。组中的用户拥有该组的所有权限。权限控制对文件和命令的访问，是系统安全的基础。
	系统用户代表系统服务和进程。系统用户需要用户帐户来控制其权限，并且在 /home 中没有登录名或目录。
	人类用户分为两类：根用户或超级用户，拥有一切权力，可以在系统上执行任何操作。所有其他用户称为普通或非特权用户。普通用户被授予足够的权限来管理自己的文件并运行允许普通用户使用它们的命令。
	普通用户可以被授予有限或完整的 root 权限。
	【/etc/passwd】包含系统上的所有用户，【/etc/group】包含所有组。
	Linux 附带了许多用于管理用户和组的命令：
		①	useradd			添加新用户
		②	groupadd		添加新组
		③	userdel			删除用户
		④	groupdel		删除组
		⑤	usermod			对现有用户进行更改
		⑥	passwd			创建和更改用户密码
	这些是 Shadow Password Suite 的一部分，/etc/login.defs 是其主要配置文件。
	在 Shadow Password Suite 出现之前，所有相关文件都必须单独编辑，有多个密码管理命令，并且散列密码存储在 /etc/passwd 和 /etc/group 中。 这两个文件必须是全世界可读的，因此在其中存储密码（即使它们经过哈希处理）也会带来麻烦。 
	将散列密码重新定位到影子文件 /etc/shadow 和 /etc/gshadow（这些文件只能由 root 访问）中，增加了一层强大的保护。 Shadow Password Suite 的使用寿命证明了其设计和编码的出色程度。
1、用户UID和GID
	①	使用不带任何选项的【id】命令，可以查看当前用户的UID和GID。
		# id
		用户id=0(root) 组id=0(root) 组=0(root) 上下文=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
	②	显示指定用户的UID和GID
		# id miggi
		用户id=1000(miggi) 组id=1000(miggi) 组=1000(miggi)
	③	查看有效身份ID
		id -un
	》扩展
		在Linux上有三种类型的用户：真实 UID/GID、有效 UID/GID、保存的 UID/GID。
		真实 ID 是创建用户时为用户分配的UID和GID。即【id】命令显示的UID和GID。
		有效 ID 是用于运行需要与启动该进程的用户不同的权限的进行的UID【如，运行passwd时，有效ID是root】。
		保存的ID由需要提升权限（通常是root权限）的进程使用。当进程需要执行需要较少权限时，可以暂时切换到非特权用户ID。将有效UID更改为较低的权限值，并将原来的有效UID保存到SUID中，保存用户ID。当进程再次需要提升权限时，会更改为SUID。
	》id选项说明：
		-u		显示有效UID号
		-g		显示有效GID号
		-G		显示所有组ID
		-n		打印名称而不是数字。可与 -u 、-g 和 -G 组合使用。
		-r		显示真实ID。可与 -u 、-g 和 -G 组合使用。
2、使用 useradd 创建人类用户
	大多数 Linux 发行版中都包含 useradd 命令，并且可以根据您的要求进行配置。 不同 Linux 发行版的默认配置各不相同。
	①	创建新用户
		useradd test1
	②	查看新用户ID，即家目录
		id test1
		用户id=1001(test1) 组id=1001(test1) 组=1001(test1)
		s -a /home/test1
		.  ..  .bash_logout  .bash_profile  .bashrc
	③	设置用户密码
		passwd test1
		创建用户密码后，可以选择强制用户在首次登录时重置密码：
		passwd -e test1
	新建的用户会附加到【/etc/passwd】中。
	》useradd 用法
		useradd [选项] 登录名
		useradd -D
		useradd -D [选项]
	》useradd 选项
		    --badname                 do not check for bad names
		-b, --base-dir BASE_DIR       新账户的主目录的基目录
		    --btrfs-subvolume-home    use BTRFS subvolume for home directory
		-c, --comment COMMENT         新账户的 GECOS 字段
		-d, --home-dir HOME_DIR       新账户的主目录
		-D, --defaults                显示或更改默认的 useradd 配置
		-e, --expiredate EXPIRE_DATE  新账户的过期日期
		-f, --inactive INACTIVE       新账户的密码不活动期
		-g, --gid GROUP               新账户主组的名称或 ID
		-G, --groups GROUPS           新账户的附加组列表
		-h, --help                    显示此帮助信息并退出
		-k, --skel SKEL_DIR           使用此目录作为骨架目录
		-K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值
		-l, --no-log-init             不要将此用户添加到最近登录和登录失败数据库
		-m, --create-home             创建用户的主目录
		-M, --no-create-home          不创建用户的主目录
		-N, --no-user-group           不创建同名的组
		-o, --non-unique              允许使用重复的 UID 创建用户
		-p, --password PASSWORD       加密后的新账户密码
		-r, --system                  创建一个系统账户
		-R, --root CHROOT_DIR         chroot 到的目录
		-P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files
		-s, --shell SHELL             新账户的登录 shell
		-u, --uid UID                 新账户的用户 ID
		-U, --user-group              创建与用户同名的组
		-Z, --selinux-user SEUSER     为 SELinux 用户映射使用指定 SEUSER
	》扩展
		所有新用户在设置密码前均处于非活动状态。为用户创建的第一个组，无论是用户私有组还是所有用户的公共组，都是其主要组。 用户分配到的所有其他组都是补充组。
		创建用户时添加附加组【这些组必须已存在】（-G, --groups）
			useradd -G group1,group2, group3 test1
		创建用户时设置 GECOS 字段
			useradd -G group1,group2,group3 -c 'Test 1,,,,' test1
		四个逗号定义五个字段：全名、房间号、工作电话、家庭电话和其他。 很久以前，这被称为 GECOS 数据。 GECOS是通用电气综合运营管理器的缩写，是一种大型机操作系统。
		可以在这些字段中输入任何文本字符串，也可以不输入任何内容，但包含用户的全名很有用。见【/etc/passwd】中的 GECOS 字段。
		useradd与多个配置文件关联。
		man 8 useradd
		man 5 login.defs
		/etc/default/useradd
		/etc/skel
		/etc/login.defs
3、使用useradd创建系统用户
	创建系统用户【没有主目录、没有登录shell，UID编号在系统用户UID范围内】：
		useradd -rs /bin/false service1
	》选项说明：
		-r		创建一个具有系统用户正确数字范围内真实ID的系统用户
		-s		指定登录shell
	》扩展
		在过去，大多数服务都是以【nobody】用户身份运行的。 现在，服务拥有自己的唯一用户是一种常见的做法，因为这比拥有多个服务的【nobody】用户提供了更强的安全性。很少需要创建系统用户，因为服务在安装时应该创建自己的唯一用户。
		始终为【nobody】用户分配 UID 65534 和 GID 65534。
4、更改 useradd 默认设置
	useradd配置分布在多个配置文件中：/etc/default/useradd、/etc/login.defs 和 /etc/skel 目录中的文件。显示 useradd 的默认配置：
		# useradd -D
			GROUP=100
			HOME=/home
			INACTIVE=-1
			EXPIRE=
			SHELL=/bin/bash
			SKEL=/etc/skel
			CREATE_MAIL_SPOOL=yes
		GROUP=100		为所有新用户设置一个默认的共享组【该组必须存在】。并且 /etc/login.defs 中要有【USERGROUPS_ENAB no】设置。
						通过在 /etc/login.defs 中设置【USERGROUPS_ENAB yes】设置私有用户组，并且要注释掉 /etc/default/useradd 中的【GROUP】。
		HOME=			设置所有新用户主目录的默认目录。默认为 /home 。
		IINACTIVE=-1	设置密码过期后直到账户被锁定的天数。【0】将在密码过期后立即禁用账户，【-1】将禁用锁定账户。
		EXPIRE=			设置账户过期日期【格式为：YYYY-MM-DD】。【EXPIRE=empty】意味着账号将不会过期。
		SEHLL=/bin/bash	设置默认的命令shell。
		SKEL=/etc/skel	设置要自动分发给新用户的文件的位置。大多数Linux将其放置在 /etc/skel 。这些文件包括【.bash_logout】、【.bash_profile】或【.profile】、【.bashrc】以及希望新用户拥有的任何其他文件。
						可以编辑这些文件以满足要求。SKEl 是 skelton 的缩写。
		CREATE_MAIL_SPOOL=yes	是旧时代的遗物，应该设置为 yes，因为可能有一些遗留流程仍然需要它。
	/etc/login.defs 中的以下值与用户创建默认值相关：
		USERGROUPS_ENAB	yes	启用私有用户组
		CREATE_HOME yes		配置 useradd 自动创建用户主目录。
	》扩展
		UID 编号范围在【/etc/login.defs】中定义。每个 UID 必须是唯一的，因此用户帐户创建命令会从此文件中定义的范围分配 UID。 
		通常，人类 UID 从 1000 开始，由 useradd 自动分配。可以使用 -u 选项覆盖此设置，但必须选择遵循配置的编号方案的未使用的编号。
		首次登录时强制更改密码是一种简单的预防措施，可防止原始密码在从管理员传递给用户时可能落入坏人之手。
5、使用 groupadd 创建用户组和系统组。
	①	创建用户组
		groupadd musicians
	②	创建系统组【-r】
		groupadd -r service1
	系统组和用户组的不同之处在于分配给它们的UID和GID编号范围。这是在 /etc/login.defs 中为 groupadd 和 useradd 定义的。如：
		# Min/max values for automatic uid selection in useradd(8)
		#
		UID_MIN 1000
		UID_MAX 60000
		# System accounts
		SYS_UID_MIN 201
		SYS_UID_MAX 999
		# Extra per user uids
		SUB_UID_MIN 100000
		SUB_UID_MAX 600100000
		SUB_UID_COUNT 65536
		#
		# Min/max values for automatic gid selection in groupadd(8)
		#
		GID_MIN 1000
		GID_MAX 60000
		# System accounts
		SYS_GID_MIN 201
		SYS_GID_MAX 999
		# Extra per user group ids
		SUB_GID_MIN 100000
		SUB_GID_MAX 600100000
		SUB_GID_COUNT 65536
	GID 编号由 groupadd 根据 /etc/login.defs 中定义的编号范围自动管理。可以使用 -g 选项覆盖此设置，但选择的 GID 必须在定义的范围内，并且不得已被使用。
6、使用 usermod 将用户添加到组
	①	将用户【duchess】添加到指定组【musicians】
		usermod -aG musicians duchess
	②	将用户【duchess】添加到多个组
		usermod -aG musicians,composers,stagehands duchess
	另外，也可以直接编辑 /etc/group 文件，将用户名放在指定组中。当列出多个组成员时，列表必须以逗号分隔，名称之间不能有空格。如：
		musicians:x:900:stash,madmax,duchess
	》注意：
		如果单独使用【-G】（没有指定【-a】），则用户将从所有现有组中移除，并替换为新组。
		当更改已登录用户的组成员身份时，用户必须注销然后重新登录才能激活更改。 有多种解决方法可以在不注销的情况下激活新的组分配，但它们都有局限性，例如仅限于当前 shell。 登录时会枚举组，因此最可靠的解决方案是注销并重新登录。
7、检查密码文件完整性
	【pwck】检查 /etc/passwd 和 /etc/shadow 的完整性，【grpck】检查 /etc/group 和 /etc/gshadow。
	不会编辑 /etc/shadow 或 /etc/gshadow 。但会编辑 /etc/passwd 和 /etc/group。
8、禁用用户账号
	要暂时停用账号，使用【passwd】命令禁用用户的密码。如：
		passwd -l stash
	解锁用户账号。如：
		passwd -u stash
	锁定【lock】账号不会阻止用户通过不同的身份验证方法（如SSH密钥）登录。要完全禁用用户，使用 usermod 命令。如：
		usermod --expiredate 1 stash
	当用户尝试登录时，会看到“您的帐户已过期；恢复帐户：
		usermod --expiredate -1 stash
	另一种禁用账号的方法是在 /etc/passwd 中将用户的密码字段【x】替换为【*】。
		stash:*:1009:1009:Stash Cat,,,:/home/stash:/bin/bash
	通过用【x】替换【*】来重新启用账号。
9、使用 userdel 删除用户
	①	从【/etc/passwd】中删除用户【stash】、【stash】的主要组和所有组成员身份以及shadow文件。
		userdel stash
		如果【stash】属于一个共享主用户组，则该组将不会被删除。
	②	使用【-r】选项删除用户主目录及其包含的内容和邮件池【mail spool】
		usedel -r stash
10、使用【su】成为root
	可以使用【su】名称切换到root用户【需要root密码】。如：
		su -l
	【-l】选项调用root用户的环境，更改root的主目录并加载root的环境变量。省略【-l】以保留当前的环境。
	》su 使用说明
		用法：
			su [选项] [-] [<用户> [<参数>...]]
			将有效用户ID和组ID更改为<用户>的有效用户ID和组ID。仅仅 - 就意味着 -l。 如果未给出 <user>，则假定为 root。
		选项：
			-m, -p, --preserve-environment		不重置环境变量
			-w,	--whitelist-environment <list>	不重置指定变量
			-g,	--group <组>					指定主组
			-G,	--supp-group <组>				指定附加组
			- ,	-l,	--login						使 shell 成为登录 shell
				-c, --command <命令>			使用 -c 向 shell 传递一条命令
					--session-command <命令>	使用 -c 向 shell 传递一条命令，而不创建新会话
			-f,	--fast							向 shell 传递 -f 选项（csh或tcsh）
			-s, --shell <shell>             	若 /etc/shells 允许，运行<shell>
			-P, --pty							创建一个新的伪中断
11、使用 sudo 授予有限的 root 权限
	sudo 比 su 更安全，因为它向特定用户授予执行特定任务的有限 root 权限、记录活动，并在有限的时间内（默认为 15 分钟）缓存用户的密码。 15 分钟后，用户必须再次向 sudo 提供密码。缓存持续时间是可配置的。 
	sudo 保护 root 的密码，因为 sudo 用户使用自己的密码。
	【/etc/sudoers】是其配置文件，应该使用特殊命令【visudo】编辑它。这将使用默认文本编辑器打开 /etc/sudoers，可以查看和编辑默认配置。
	》配置说明【root ALL=(ALL) ALL】
		root	用户字段。该字段保存任何单个用户、用户别名或系统组
		ALL=	主机字段。ALL表示任何地方法的任何主机，或可以使用主机别名，或单个主机
		(ALL)	可选用户字段。(ALL)表示一个或多个用户可以像其他用户一样运行命令，或可以指定某些用户。
		ALL		命令字段。ALL表示不受限制，可以指定允许的命令列表。
	》配置示例
		%sudo ALL=(ALL) ALL	添加到 sudo 组的任何用户都将获得完整的 sudo 权限，就像 root 一样。百分号表示 %sudo 是 /etc/group 中的组，而不是 /etc/sudoers 中配置的组。
		stash server1 = /bin/rpm, /usr/bin/yum, /usr/bin/dnf	# 用户名、本地计算机的主机名、以逗号分隔的允许命令列表
		# 如果允许的命令过长，可以创建一些命令别名。如
		Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum, /usr/bin/dnf
		Cmnd_Alias SYSTEM = /usr/bin/systemctl start, /usr/bin/systemctl stop, /usr/bin/sytemctl reload, /usr/bin/systemctl restart, /usr/bin/systemctl status,
		/usr/bin/systemctl enable, /usr/bin/systemctl disable, /usr/bin/systemctl mask, /usr/bin/systemctl unmask
		stash server1 = SOFTWARE, SYSTEM
		# 创建组【非/etc/group组】
		User_Alias JRADMIN = stash, madmax
		JRADMIN server1 = SOFTWARE, SYSTEM
		# 可以创建一个Host_Alias来授予用户在多态计算机上的sudo权限。
		Host_Alias SERVERS = server1, server2, server3
		JRADMIN SERVERS = SOFTWARE, SYSTEM
	》注意事项
		不要过分相信将用户限制为一组特定的命令。 许多日常应用程序都提供了通过 shell 转义进行权限升级的方法，并且您的用户可以获得完全的 root 权限。
		①	通过 awk 直接切换到root用户
			如果给予用户【awk】的root权限。则用户可通过如下命令直接切换到【root】用户。
				sudo awk 'BEGIN {system("/bin/bash")}'
			这样普通用户【如duchess】将拥有完整的root权限。
		②	less的 shell 转义
				sudo less /etc/systctl.conf
			通过键入【!sh】，进行 shell 转义。
		跟踪可以提供 shell 转义的应用程序极其困难。如果希望监视 sudo 用户，journalctl会记录所有内容。
	在某些 Linux 中，例如 Fedora，wheel 组是默认的 sudo 组。 检查 /etc/sudoers 文件以了解发行版如何配置它。还可以创建自己的 sudo 组，并将其命名为想要的任何名称。
	【/etc/sudoers】文件仅控制本地计算机上的用户。包括其他计算机（如 SERVERS 别名）允许您在多台计算机上共享单个配置文件。sudo忽略本地计算机上不存在的任何项目，如主机或用户。
12、延长 sudo 密码超时
	在大多数 Linux 发行版上，sudo 会默认缓存密码 15 分钟。 15 分钟后，必须再次输入密码。 当有很多工作要做时，厌倦了必须频繁输入密码，可以将缓存间隔设置得更长。
	通过 visudo 编辑【/etc/sudoers】中得 timestamp_timeout 配置。如：
		Defaults timestamp_timeout=60
	如果将其设置为0， sudo 会在每次使用它都要求密码。如果设置为负数【如，-1】，密码将不会过期。
13、创建单独的 sudoers 配置
	可以在 /etc/sudoers.d 中创建单独的配置。如：
		cd /etc/sudoers.d/
		sudo visudo -f stash
	这会创建【stash】文件。只需输入与 /etc/sudoers 中的条目不同的配置项，而不是复制整个文件。这是管理多个用户的一个很好的功能。 不要管理一个大的配置文件，而是将其分解为较小的每个用户文件。
14、将 sudo 更改为不询问 Root 密码
	有些Linux发行版（如openSUSE）要求在使用sudo提权时输入root用户的密码。
	要设置 sudo 用户总是询问用户自己的密码，编辑【/etc/sudoers】文件并注释以下两行：
		visudo
		# Defaults targetpw
		# ALL ALL=(ALL) ALL
	在 openSUSE 和 Fedora 中，通过将 sudo 用户添加到 /etc/group 中的wheel组来创建具有完全root权限的用户。
	保存更改并关闭文件后，更改立即生效。


Managing Files and Directories
	Linux 提供了强大的基本控制来访问具有可配置权限的文件和目录。每个文件和目录都有三级所有权，包括用户、组和其他；以及多级访问，包括读、写和执行。可以保护个人文件并控制谁有权访问它们。
	每个文件都有三种所有权：所有者、所属组和其他用户。其中所有者是单一用户、所属组是单一组。
	每个文件都有流中权限模式——读、写和执行，以及三种特殊模式：sticky bit、setuid和setgid。
	文件权限控制哪些用户可以创建、读取、编辑或删除文件，以及哪些用户可以执行命令。特殊模式控制谁可以移动、删除或重命名文件，以及谁可以以提升的权限执行命令。 
	目录权限控制哪些用户可以编辑或进入目录，以及哪些用户可以读取、编辑、添加或删除目录中的文件。 
	注意：基本的 Linux 安全原则是使用最少的必要权限来完成工作。
	在 Linux 系统上，root 用户（也称为超级用户）拥有至高无上的权力。root 几乎可以执行任何操作，包括编辑和删除其他用户的文件、进入任何目录以及运行任何命令。普通用户或非特权用户可以使用 sudo 或 su 命令暂时取得 root 权限。
	每个用户都有一个唯一的标识（UID），并且至少属于一个组。组中的每个用户共享该组的权限。
		# stat --format="%a:%A:%U:%G" /etc
		755:drwxr-xr-x:root:root
	命令输出以两种形式显示目录的模式或权限集：755:drwxr-xr-x。 755是八进制表示法，drwxr-xr-x是符号表示法。 这是表达同一模式的两种不同方式。
	root:root是所有者和所属组。文件和目录可以有不同所有者和所属组。
	除了读、写和执行权限外，文件还有三种特殊权限模式：sticky bit、setuid和setgid。
	setuid和setgid模式将用户和组权限提升到文件所有者和所属组相同的权限。这些仅在特殊情况下使用，并且要非常谨慎地使用，因为权限升级是一个潜在的安全风险。
	sticky bit【粘性位】可防止除文件所有者或具有root权限的任何人之外的其他人删除、重命名或移动目录中不属于它们的文件。
1、创建文件和目录
	使用 mkdir 命令创建目录。如，在当前目录下创建子目录：
		mkdir -v presentations
	使用 -p 选项递归创建目录，如：
		mkdir -p presentations/2023/august
	创建目录的同时设置目录权限：
		mkdir -m 0700 /home/miggi/dog-memes
	使用 touch 命令创建新文件：
		touch /home/miggi/test.txt
	使用 tree 命令查看目录结构：
		# tree -L 1 /home/miggi
		/home/miggi
		├── github_passwd.txt
		└── LinuxBasic

		1 directory, 1 file
	》扩展
		man 1 mkdir
		man 1 touch
		man 1 yes
		man 1 tree
2、批量创建文件
	通过大括号扩展【Brace Expansion】，可以批量创建一系列类似的文件。如：
		touch file{00..99}
		touch file{00..99..2}
	使用 yes 命令快速填充文件。如：
		yes This is a test file | head -c 5MB > testfile.txt
	通过 for 循环快速填充多个文件。如：
		for i in {00..99}; do
			yes This is a test file | head -c 5MB > file$i
		done
3、相对路径和绝对路径
	绝对路径总是以根【/】开始，如/boot和/etc。相对路径是相对于当前工作目录的，且没有前导斜杠【/】。某些应用程序和命令需要相对路径； 例如，rsync include 和 exclude 列表使用与要复制的目录相关的文件路径。
4、删除文件和目录
	使用 rm 命令删除文件和目录，但请谨慎使用。删除单一文件，输出详情：
		rm -v test.ogg
	使用 -i 选项在删除前进行确认：
		rm -iv test.ogg
	使用 -r 选项递归删除目录和其所有文件和子目录。如：
		rm -rvi rehearsals
	使用 -f 强制删除。
5、复制、移动和重命名文件和目录
	使用 cp 命令进行复制，使用 mv 命令移动或重命名。复制当前目录中的的文件到指定目录：
		cp -v test1.txt test2.txt ~/subdir
	使用 -r 递归复制目录中的文件和子目录：
		cp -rv ~/music/songs2 /shared/archives
	-r 仅复制目录及其文件。使用 --parents 选项保留父目录。如，复制song2和其内容，同时保留文件路径【/duchess/music/songs2】：
		cp -rv --parents /duchess/music/song2 shows/
	duchess 和 music 的其他内容不会复制，仅songs2和其内容被复制。
	移动文件到其他目录：
		mv -v test.ogg solo.flac ~/songs2/
	》扩展
		Ⅰ	cp
			①	用法
				cp [选项]... [-T] 源文件 目标文件
				cp [选项]... 源文件... 目录
				cp [选项]... -t 目录 源文件...
				将指定<源文件>复制至<目标文件>，或将多个<源文件>复制至<目标目录>。
			②	选项
				-a, --archive                 	等于-dR --preserve=all
				      --attributes-only 		仅复制属性而不复制数据      
					  --backup[=CONTROL         为每个已存在的目标文件创建备份
				  -b                            类似--backup 但不接受参数
				      --copy-contents           在递归处理是复制特殊文件内容
				  -d                            等于--no-dereference --preserve=links
				  -f, --force                  	如果有已存在的目标文件且无法打开，则将其删除并重试（该选项在与 -n 选项同时使用时将被忽略）
				  -i, --interactive            	覆盖前询问（使前面的 -n 选项失效）
				  -H                           	跟随源文件中的命令行符号链接
				  -l, --link                   	硬链接文件以代替复制
				  -L, --dereference            	总是跟随源文件中的符号链接
				  -n, --no-clobber              不要覆盖已存在的文件(使前面的 -i 选项失效)
				  -P, --no-dereference          不跟随源文件中的符号链接
				  -p                            等于--preserve=模式,所有权,时间戳
				      --preserve[=属性列表      保持指定的属性(默认：模式,所有权,时间戳)，如果可能保持附加属性：上下文、链接、xattr 等
				      --sno-preserve=属性列表   不保留指定的文件属性
				      --parents                 复制前在目标目录创建来源文件路径中的所有目录
				  -R, -r, --recursive           递归复制目录及其子目录内的所有内容
				      --reflink[=WHEN]          控制克隆/CoW 副本。请查看下面的内如。
				      --remove-destination      尝试打开目标文件前先删除已存在的目的地文件 (相对于 --force 选项)
				      --sparse=WHEN             控制创建稀疏文件的方式
				      --strip-trailing-slashes  删除参数中所有源文件/目录末端的斜杠
				  -s, --symbolic-link           只创建符号链接而不复制文件
				  -S, --suffix=后缀             自行指定备份文件的后缀
				  -t,  --target-directory=目录  将所有参数指定的源文件/目录复制至目标目录
				  -T, --no-target-directory     将目标目录视作普通文件
				  -u, --update                  只在源文件比目标文件新，或目标文件不存在时才进行复制
				  -v, --verbose         		显示详细的进行步骤
				  -x, --one-file-system 		不跨越文件系统进行操作
				  -Z                           	设置目标文件的 SELinux 安全上下文为默认类型
				      --context[=上下文]       	类似 -Z；如果指定了上下文，则将 SELinux 或 SMACK 安全上下文设置为指定值
		Ⅱ	mv
			①	用法
				mv [选项]... 源文件 目标文件
				mv [选项]... -T 源文件... 目录
				mv [选项]... -t 目录 源文件...
			②	选项
				      --backup[=CONTROL]       为每个已存在的目标文件创建备份
				  -b                           类似--backup 但不接受参数
				  -f, --force                  覆盖前不询问
				  -i, --interactive            覆盖前询问
				  -n, --no-clobber             不覆盖已存在文件
				如果指定了-i、-f、-n 中的多个，仅最后一个生效。
				      --strip-trailing-slashes 去掉每个源文件参数尾部的斜线
				  -S, --suffix=SUFFIX          替换常用的备份文件后缀
				  -t, --target-directory=目录  将所有<源文件>移动至指定的<目录>中
				  -T, --no-target-directory    将参数中所有<目标文件>部分视为普通文件
				  -u, --update                 仅在<源文件>比目标文件更新，或者目标文件
				                               不存在时进行移动操作
				  -v, --verbose                对正在发生的操作给出解释
				  -Z, --context                将目标文件的 SELinux 安全上下文设置为默认类型
6、使用 chmod 设置文件属性
	有两种方式设置文件属性：
		①	数字形式	八进制表示法有四个字段，可能最长使用最后三个字段【所有者权限、所属组权限和其他人权限】，很少使用第一个字段【保留，用于特殊模式】
						r（4）、w（2）、x（1）；setuid（4）、setgid（2）、sticky bit（1）
		②	符号形式	有四组用户【所有者（u）、所属组（g）、其他（o）和所有（a）】。有三种设置方式【=、+、-】。权限符号包括：rwxXst。权限值也可ugo表示。
	Ⅰ	使用数字形式修改权限
		①	设置文件权限
			chmod -v 0600 file.txt
		②	设置目录权限【目录必须设置可执行位】（使用cd命令或文件管理器进入目录是必要的）
			chmod -v 0770 /shared
			使用 -R 选项将相同的权限应用于目录的现有内容：
			chmod -R 0775 /shared
			将目录及其现有内容限制为目录所有者。目录中的文件和目录可能有不同的所有者和权限，但组和其他人仍然无法访问。
			chmod 0700 /shared
			常见的权限集合是给予所有者和组相同的权限【如读、写权限】，并排除其他：
			chmod 0770 /shared
		③	针对特殊用例使用特殊模式
			特殊模式是粘性位【sticky bit】、setuid 和 setgid。 
			粘滞位应用于包含多个用户拥有的文件的目录，以防止用户移动、重命名或删除不属于他们的文件：
			chmod -v 1770 /home/duchess/shared
			setuid应用于可执行文件【二进制文件】，以将运行该命令的任何用户提升到与所有者相同的权限：
			chmod -v 4750 backup-script
			将setgid应用于目录，以便该目录中所有新创建的文件都被分配到与该目录的所属组相同的组中：
			chmod -v 2770 /home/duchess/shared
			setgid 也可以应用于文件，将用户的有效组更改为与文件所有者相同的组。
			setgid 和 setuid 有可能为入侵者或不值得信任的用户创建安全漏洞。最佳实践是仅当无法想出更安全的方法来完成想做的事情时才使用它们，例如使用组分配或 sudo。 
			setuid 对于可执行文件很有用。 setgid 对于目录和文件很有用。
			sticky bit仅用于目录。
			粘性位的一个更具描述性的名称是限制删除位。 该位可防止非特权用户删除或重命名目录中的文件，除非他们拥有该文件。
			setgid表示设置组用户标识，setuid表示设置用户标识。 这些用于将非特权用户的权限提升到与用户或组所有者相同的权限。如普通用户可以使用 passwd 命令修改其自身的密码。
				stat --format=%a:%A:%U:%G /usr/bin/passwd
		④	移除特殊模式
			删除特殊模式与设置有点不同，需要使用额外的前导零。如：
			chmod -v 00770 backup.sh
			或使用前导等号替换前导零：
			chmod -v =770 backup.sh
	Ⅱ	使用符号形式修改权限
		符号形式有三种运算符：+、-和=。可以使用【u】标志更改文件所有者权限，使用【g】更改所属组权限，使用【o】更改其他人权限和【a】更改所有人权限。
			+	添加指定权限
			-	从现有权限中减去指定权限
			=	添加指定的新权限，同时减去没有列出的任何权限
		①	给所属组和其他人添加写权限：
			chmod g+w,o+w file.txt
		②	减去所属组和其他人的写权限：
			chmod go-w file.txt
		③	常见的权限集是赋予所有者和所属组相同的权限【如，读写】，同时排除其他人的权限：
			chmod -v r=rw,g=rw,o-r file.txt
		④	命令和脚本需要可执行权限，给文件所有者添加执行权限：
			chmod -v u+x file.sh
		⑤	【=】运算符对于覆盖现有权限很有用：
			chmod -v u=rw,g=rw,o=r file.txt
		可靠地使用 chmod 符号表示法的关键是始终明确并注意现有权限。添加和减去现有权限（除了使用 = 运算符，它会覆盖），并指定 u、g、o 或 a。
		符号表示法有 10 个值，未设置的值（表示没有权限）用破折号表示。如：
			# stat --format="%a:%A:%U:%G" /home/miggi/
			700:drwx------:miggi:miggi
		第一个是文件类型【如，d】其余九个值分为三个三元组，每个三元组中的三个值代表读、写和执行。
		⑥	使用符号形式设置特殊模式
			特殊模式是：sticky bit、setuid、setgid。这些都在可执行字段中设置。
			》sticky bit应用于包含多个用户拥有的文件的目录，以防止非所有者移动、重命名或删除文件：
			chmod o+t /shared/stickydir
			》对目录应用 setgid，可以将目录中所有新创建的文件设置到该目录相同的组中。这是在共享目录中强制执行正确所有权的一个好技巧：
			chmod g+s /shared
			》在可执行文件【二进制文件】上设置 setuid 允许非root用户运行可执行文件：
			chmod u+s backup-script
		Mode 		User 	Group 	Other
		Read 		r 		r 		r
		Write 		w 		w 		w
		Execute 	x 		x 		x
		setuid 		s
		setgid 				s
		Sticky bit 					t	
	Ⅲ	使用 chmod 批量设置文件权限
		chmod 支持对文件列表进行操作。还可以使用 find 命令和 shell 通配符来选择要更改的文件。
		chmod -v 444 file1 file2 file3
		使用 -R 选项【递归】设置目录及其包含的文件和子目录权限：
		chmod -vR 755 /shared
		使用通配符批量设置文件权限：
		chmod -v 644 *.txt
		使用 find 命令设置当前目录中文件的权限：
		find . -type f -exec chmod -v 660 {} \;
		修改属于特定用户【用户ID或用户名】的所有文件的权限：
		sudo find / -user madmax -exec chmod -v 660 {} \;
		sudo find / -user 1007 -exec chmod -v 660 {} \;
		》扩展
			man 1 chmod
			man 1 find
7、使用 chown 设置文件和目录的所有者
	使用 chown【change owner】命令更改文件所有者。基本命令格式是【chown user:group filename】。可以仅更改所有者【chown user: filename】；也可以仅更改文件所属组【chown :group filename】。
	更改文件所有者需要root权限：
		sudo chown -v madmax: song.wav
	更改文件所属组：
		sudo chown -v :composers song.sav
	更改文件所有者和所属组：
		sudo chown stash:stash song.wav
	需要root权限才能更改不属于自己的文件并将我呢见所有权转移给其他用户。当同时属于原始组和新组时，无需root权限即可更改文件所属组到新组。
	当仅更改文件所有者，冒号是可选的；当更改所属组时，冒号是必需的。
8、使用 chown 批量更改文件所有权
	chown 支持对文件列表进行操作。还可以使用 find 命令和 shell 通配符来列出要更改的文件。
	使用 chown 批量更改文件所有权，文件列表用逗号分隔：
		sudo chown -v madmax:share file1 file2 file3
	使用通配符【*】：
		sudo chown -v :share *.txt
	使用数字UID或用户名将目录中用户的所有文件提供给另一个用户：
		chown -Rv --from duchess stash /shared/compositions
		chown -Rv --from 1001 1005 /shared/compositions
	使用 find 命令遍历整个文件系统或任何目录及其子目录，将一个用户的所有提供给另一个用户：
		sudo find / -user duchess -exec chown -v stash {} \;
		sudo find / -user 1001 -exec chown -v 1005 {} \;
	将用户所有文件的所有权转移给另一个用户或不同的组，对于清理不再在系统上拥有帐户的用户非常有用。
9、使用 umask 设置默认权限
	文件的原始权限是【0666】，目录的原始权限是【0777】。通过umask可控制在新建文件或目录时的默认权限【原始权限 - umask值】。
	运行 umask 命令查看umask值。使用【-S】选项以符号形式显示。如：
		# umask -S
		u=rwx,g=rx,o=rx
	要在当前会话期间临时更改 umask，请按以下方式设置：
		# umask 0022
	通过将【umask 0022】插入到 ~/.bashrc 中来永久设置umask值。
	要设置所有用户的umask值，可将其放在/etc/login.defs中。
10、创建文件和目录的快捷键【软连接和硬链接】
	Linux上有两种连接：软连接和硬链接。软连接可用于文件和目录；硬链接只能用于文件。使用 ln 命令创建连接。
	在当前目录创建到 /files/userstuff 的连接【stuff】：
		ln -s /files/userstuff stuff
	/files/userstuff 是源，stuff是目标【软连接名称】。可以将软连接命名为任何想要的名称，并移动和删除它们，而不会影响其目标。打开软链接时，其行为与打开目标相同。 
	硬链接是文件的副本。 ln 命令默认创建硬链接：
		ln /files/config1.txt myconf.txt
	①	软连接
		软连接更常称为符号连接【symliks】。
		符号链接指向文件和目录。 当符号链接的目标被删除、重命名或移动时，符号链接就会被破坏。 如果创建与已删除文件同名的新文件，即使内容不同，符号链接也会恢复。
		符号连接可跨文件系统。甚至可以创建指向非永久性的文件或目录的符号连接【如USB存储设备或网络共享文件】。当目标更改（重命名、移动或删除）时，符号连接不会更新。需要创建一个新的符号连接并删除旧的符号连接。
		不管理符号连接的权限或所有权，因为只有目标的权限才重要。符号链接示例如下：
		# stat github_passwd.txt
		  文件：github_passwd.txt -> /home/miggi/github_passwd.txt
		  大小：29              块：0          IO 块：4096   符号链接
		设备：fd00h/64768d      Inode：16777990    硬链接：1
		权限：(0777/lrwxrwxrwx)  Uid：(    0/    root)   Gid：(    0/    root)
		环境：unconfined_u:object_r:admin_home_t:s0
	②	硬链接
		文件由inode唯一标识，硬链接指向的是inode，而不是文件名。ls 命令使用【-i】选项显示inode。如：
		# ls -li
		总用量 4
		17800211 -rw-------. 1 root root 807 12月  3 19:24 anaconda-ks.cfg
		16777990 lrwxrwxrwx. 1 root root  29 12月  9 04:58 github_passwd.txt -> /home/miggi/github_passwd.txt
		硬链接总是有效，因为它们直接指向索引节点【inodes】。具有多个硬链接的文件可以移动、重命名和编辑，并且所有硬链接保持同步【都指向同一数据块】。Linux系统上的每个文件都以硬链接开头。
		创建硬链接时，正在为现有数据块创建新文件名。硬链接不能跨文件系统，仅存在于单一文件系统。
		可以根据需要对文件建立任意数量的硬链接，并且它们指向的数据所占用的磁盘空间始终相同，无论它有多少个硬链接。 对比硬链接和制作文件副本：每个副本都使用更多的磁盘空间，每个副本都是独立的，并且副本可以去任何地方。
		在删除所有硬链接之前，文件不会被完全删除。
11、隐藏文件和目录
	通过使用点【.】文件来忽略（隐藏）文件。可使用 ls -a 来显示隐藏文件。
	在任何文件前面加上点【.】都会使其成为隐藏文件。尽管它实际上并不是隐藏的，但会被忽略，直到想查看它为止。 这主要用于用户的主目录通过不显示配置文件来减少混乱。这些是普通文件，可以编辑、删除或执行任何想要的操作。


Backup and Recovery with rsync
	rsync 是一个高效的文件传输程序，其主要目的是保持文件系统彼此同步。 当您使用它进行备份时，它会使本地文件与备份设备保持同步。它快速且高效，因为它仅传输文件中的更改。与许多从不希望删除任何内容的备份软件不同，它甚至会镜像删除。 
	由于这些功能，rsync 成为更新和镜像用户主目录、网站、git 存储库和其他大型复杂文件树的首选工具。
	通过网络使用 rsync 有两种方法：通过 SSH，进行身份验证登录和传输，或者将其作为守护进程运行。 
	使用 SSH 要求用户在需要 rsync 访问的每台计算机上拥有登录帐户。 
	当rsync以守护进程模式运行时，可以使用其内置的身份验证方法来控制访问，以便用户不需要在rsync服务器上登录帐户。
	守护进程模式非常适合LAN备份服务器。通过不受信任的网络访问是不安全的，除非使用VPN。
	如果互联网连接足够强大来处理流量，那么设置远程 rsync 镜像来备份备份是一种常见策略。 但在构建大规模备份基础设施之前，请考虑一下真正需要多少级别的冗余。 异地备份是防止站点发生灾难的保险。
	备份的目的是恢复。 定期测试备份，以避免因备份方法失败而遭受惨痛教训。
1、选择需要备份的文件
	个人文件和系统数据文件是最重要的。以下目录包含配置等文件； Web、FTP 和邮件服务器等服务器的数据文件； 日志文件; 安装在非标准位置的应用程序； 和共享目录，所有这些都应该备份：
		/boot/grub		如果包含任何自定义项【如主题、背景图像或字体】
		/etc			包含系统配置文件
		/home			用户的个人文件
		/mnt			临时文件系统挂载点。如果有要保留的挂载点，要备份此内容
		/opt			对于专有或其他未按标准方式安装的应用程序
		/root			root用户的个人文件
		/srv			服务器数据【如，web、FTP】
		/tmp			保存临时数据，根据需要自动更新或删除。 /tmp 中的一些数据是持久性的，例如用户创建的文件和一些系统服务，应该备份它们。
		/var			存储许多类型的数据，例如日志文件、邮件假脱机、cron 作业和系统服务数据，尽管大多数发行版已迁移到使用 /srv 来提供系统服务。
	如果有任何共享目录、自定义命令和脚本，或者之前未列出的任何数据文件或目录，也要备份它们。
2、从备份中选择要恢复的文件
	重装Linux后，不要恢复 /etc/fstab（该文件配置静态文件系统挂载）。每次安装Linux，所有文件系统都会获得新的UUID（通用唯一标识符）。因此它们不会被识别，并且新安装将会失败。
	恢复/etc中的文件或用户主目录中的点文件。如果要从备份恢复到不同版本或不同 Linux 发行版的新安装，则配置选项或文件位置可能不兼容。 一次恢复一个，这样就可以快速发现任何问题。
4、使用 cp 进行本地备份
	①	cp 用法
		cp [选项]... [-T] 源文件 目标文件
		cp [选项]... 源文件... 目录
		cp [选项]... -t 目录 源文件...
	②	选项
		-a, --archive               等于-dR --preserve=all
		    --attributes-only 		仅复制属性而不复制数据      
			--backup[=CONTROL       为每个已存在的目标文件创建备份
		-b                          类似--backup 但不接受参数
		    --copy-contents         在递归处理是复制特殊文件内容
		-d                          等于--no-dereference --preserve=links
		-f, --force                 如果有已存在的目标文件且无法打开，则将其删除并重试（该选项在与 -n 选项同时使用时将被忽略）
		-i, --interactive           覆盖前询问（使前面的 -n 选项失效）
		-H                          跟随源文件中的命令行符号链接
		-l, --link                  硬链接文件以代替复制
		-L, --dereference           总是跟随源文件中的符号链接
		-n, --no-clobber            不要覆盖已存在的文件(使前面的 -i 选项失效)
		-P, --no-dereference        不跟随源文件中的符号链接
		-p                          等于--preserve=模式,所有权,时间戳
		    --preserve[=属性列表    保持指定的属性(默认：模式,所有权,时间戳)，如果可能保持附加属性：上下文、链接、xattr 等
		    --sno-preserve=属性列表   不保留指定的文件属性
		    --parents                 复制前在目标目录创建来源文件路径中的所有目录
		-R, -r, --recursive           递归复制目录及其子目录内的所有内容
		    --reflink[=WHEN]          控制克隆/CoW 副本。
		    --remove-destination      尝试打开目标文件前先删除已存在的目的地文件 (相对于 --force 选项)
		    --sparse=WHEN             控制创建稀疏文件的方式
		    --strip-trailing-slashes  删除参数中所有源文件/目录末端的斜杠
		-s, --symbolic-link           只创建符号链接而不复制文件
		-S, --suffix=后缀             自行指定备份文件的后缀
		-t,  --target-directory=目录  将所有参数指定的源文件/目录 复制至目标目录
		-T, --no-target-directory     将目标目录视作普通文件
		-u, --update                  只在源文件比目标文件新，或目标文件不存在时才进行复制
		-v, --verbose         		  显示详细的进行步骤
		-x, --one-file-system 		  不跨越文件系统进行操作
		-Z                            设置目标文件的 SELinux 安全上下文为默认类型
		    --context[=上下文]        类似 -Z；如果指定了上下文，则将 SELinux 或 SMACK 安全上下文设置为指定值
	如果要保留文件属性（例如所有权和权限），请使用支持文件属性的 Linux 文件系统（例如 Ext4、XFS 或 Btrfs）格式化备份驱动器（请参阅第 11 章）。 FAT 文件系统不保留所有权或权限。
	密切关注备份运行需要多长时间。 如果它花费的时间比预定的备份间隔长，cron将按计划开始下一次备份，然后就会出现混乱。
5、	使用 rsync 进行本地备份
	



Secure Remote Access with OpenSSH
	OpenSSH 是安全远程管理的首选工具。 它对会话期间的身份验证和所有流量进行加密，并保证数据传输的完整性。 如果发生某些事情改变了你的数据包，SSH 会告诉你。
	OpenSSH支持大量强加密算法。 所有这些都不受专利限制，因为 OpenSSH 团队竭尽全力确保 OpenSSH 内部不存在任何专利或其他受限制的代码。
	OpenSSH是一套远程传输实用程序：
		sshd		OpenSSH服务器守护程序
		ssh			secure shell的缩写，虽然它并不真正包含 shell，但提供了到远程系统上的命令 shell 的安全通道。
		scp			secure copy，加密文件传输器。
		sftp		安全文件传输协议，提供文件访问。
		ssh-copy-id	用于将公钥安装到远程SSH服务器的 authorized_keys 文件中。
		ssh-keyscan	查找并收集网络上的公共主机密钥，从而省去了手动查找它们的麻烦。
		ssh-keygen	生成和管理身份验证密钥
		ssh-add		将身份添加到身份验证代理，ssh-agent。
	sshfs 在本地 PC 上安装远程文件系统，而 ssh-agent 会记住 SSH 私钥上的密码，以便多个SSH登录时进行自动身份验证。 ssh-agent 绑定到单个登录会话，因此注销或打开另一个终端意味着重新开始。
	OpenSSH支持不同类型 的身份验证：
		①	密码验证【Password authentication】				通过远程Linux登录名和密码进行身份验证。
		②	公钥验证【Public key authentication】			通过个人SSH公钥进行身份验证。【需要创建和分发公钥，并只能从保存对应私钥的计算机登录】
		③	无密码验证【Passphrase-less authentication】	无需密码的公钥身份验证。 这对于脚本和 cron 作业等自动化服务很有用。 任何成功窃取私钥的人都可以轻松伪装成您，因此需要非常保护无密码的私钥。
	身份验证密钥有两种不同的用途：
		①	主机密钥【host keys】	用于计算机身份验证。
		②	公钥【public heys】		用于用户身份验证。
	SSH密钥成对出现，包括私有密钥和公共密钥。传输使用公钥加密并使用私钥解密。可以根据需要安全地分发公钥，同时必须保护私钥并不让其他人拥有。
1、安装OpenSSH Server
	大多数 Linux 发行版默认安装 OpenSSH 客户端，但并不总是安装服务器。 不同的 Linux 发行版以不同的方式打包 OpenSSH，因此请使用包管理器列出适用的 Linux 的包。
	①	安装OpenSSH Server
		yum –y install openssh-server openssh-clients
	②	通过systemctl管理sshd
		systemctl start sshd
		systemctl status sshd
		systemctl reload sshd
		systemctl stop sshd
2、生成新地主机密钥【Host Keys】
	Linux发行版可能不会再安装时自动创建主机密钥，或想要使用替换现有主机密钥，又或者克隆安装虚拟机想要唯一的主机密钥。可以通过【ssh-keygen】生成新的主机密钥。
	有四种不同的密钥：RSA、DSA、ECDSA和ED25519。
	①	删除旧的公钥
		rm /etc/ssh/ssh_host*
	②	创建所有的公钥：
		ssh-keygen -A
	③	扩展
		对于应该使用哪种密钥格式。最简单的做法是使用RSA、ECDSA和ED25519，并避免使用DSA。【删除DSA主机密钥，保留其余三种】。
		RSA是最古老的，它很强大并提供了最大的兼容性。ECDSA 和 ED25519 更新、非常强大且计算成本较低。
3、配置OpenSSH Server
	①	确保服务器的私有主机密钥仅root拥有且只读
		# ls -l /etc/ssh/ssh_host*_key
		-rw-r-----. 1 root ssh_keys  492 12月  3 19:25 /etc/ssh/ssh_host_ecdsa_key
		-rw-r-----. 1 root ssh_keys  387 12月  3 19:25 /etc/ssh/ssh_host_ed25519_key
		-rw-r-----. 1 root ssh_keys 2578 12月  3 19:25 /etc/ssh/ssh_host_rsa_key
	②	确保服务器的公钥由root拥有，其他人只有读权限
		# ls -l /etc/ssh/ssh_host*.pub
		-rw-r--r--. 1 root root 162 12月  3 19:25 /etc/ssh/ssh_host_ecdsa_key.pub
		-rw-r--r--. 1 root root  82 12月  3 19:25 /etc/ssh/ssh_host_ed25519_key.pub
		-rw-r--r--. 1 root root 554 12月  3 19:25 /etc/ssh/ssh_host_rsa_key.pub
	③	修改sshd配置【/etc/ssh/sshd_config】
		取消要使用的和更改的选项注释。
		》在接受登录前检查用户文件和主目录的文件模式和所有权是否正确：
			StrictModes yes		# 如果权限不正确，该设置将不允许登录
		》定义监听地址：
			ListenAddress 192.168.10.15
			ListenAddress 127.16.32.5
		》定义监听端口：
			检查/etc/services查找未使用的端口，使用大于1024的端口号，
			将选择的端口号添加到/etc/services中：
				sshd 2022
				sshd 2023
			sshd监听端口：
				Port 2022
				Port 2023
		》限制仅允许访问指定组【/etc/groups】：
			AllowGroups	webadmins backupadmins	
			# DenyGroups abcd	# 拒绝访问指定组
		》不允许root用户登录：
			PermitRootLogin	no
		》仅允许通过公钥认证登录root用户
			PermitRootLogin prohibit-password
		》禁止所有用户密码登录
			PasswordAuthentication no
		》禁用指定用户登录：
			DenyUsers duchess stash@example.com cagney@192.168.10.5
			# 使用 AllowUsers指定允许登录的用户。DenyUsers优先级高于 AllowUsers 。
		》限制服务器等待用户登录并完成连接的时间长度。 默认值为 120 秒：
			LoginGraceTime 90
		》限制连接失败尝试次数，默认6次：
			MaxAuthTries 4
4、检查配置语法
	通过【sshd -t】命令检查【/etc/ssh/sshd_config】配置文件中的配置是否有语法错误。
5、首次登录
	主机公钥交换仅在第一次登录时发生一次【将服务器的公共主机密钥保存到客户端的~/.ssh/known_hosts文件中】。除非用新密钥替换该密钥，或从~/.ssh/known_hosts文件中将其删除。
	【~/.ssh/known_hosts】文件可以包含任意数量的主机密钥。
	存在主机密钥传输可能被拦截并被伪造密钥替换的风险，这将允许攻击者访问您的系统。可以在键入 yes 之前验证公钥指纹。
6、检索公钥指纹
	在服务器上使用【ssh-keygen】命令以及要查询的主机公钥来检索其指纹。如：
		ssh-keygen -lf /etc/ssh/ssh_host_rsa_key
7、使用公钥验证
	使用公钥验证比密码验证要更强。可以选择使用单个公钥来访问多个主机，或为每个远程主机创建唯一的公钥。
	①	创建新SSH密钥
		ssh-keygen -C "backup server2" -f ~/.ssh/id-server2 -t rsa -b 4096
	②	将新SSH公钥传输到要登录的远程主机：
		ssh-copy-id -i ~/.ssh/id-server2 duchess@server2
	③	使用公钥验证用户
		ssh -i ~/.ssh/id-server2 duchess@server2
	可以使用这个新密钥来访问多个远程主机，或者为每个远程主机创建一个唯一的密钥。 在多台机器上使用相同的密钥很容易使用，但在多台主机上更改却很痛苦。如果唯一密钥被泄露或丢失，只需更换一次。
	应该为创建的SSH密钥设置密码。如果没有密码，任何获得私钥访问权限的人都可以伪装成我们。
	ssh-copy-id 可确保公钥被复制到 正确的位置，即远程主机上的 ~/.ssh/authorized_keys，格式正确且权限正确。 它还确保私钥不会被错误复制。
	》选项说明：
		-C		为密钥添加注释。用于帮助记住密钥是干什么的。
		-f		指定密钥名称。
		-t		指定密钥类型
		-b		指定位【bit】强度，只有【rsa】使用该选项。默认是2048，最大为4096。
		-i		告诉SSH客户端，使用哪个密钥。当有多个密钥时，必须使用该选项。否则SSH客户端会尝试使用所有密钥。这样会出现 “Too many authentication failures” 错误消息。
8、管理多个公钥
	通过【~/.ssh/config】管理多个公钥。这样在通过密钥登录时可不指定密钥。如：
		Host server2
		HostName server2
		User duchess
		  IdentityFile ~/.ssh/id-server2
		  IdentitiesOnly yes
	这样就可通过【ssh server2】来以duchess登录server2了。
	》选项说明：
		Host				定义每个配置的开始，指定用于登录的标签
		HostName			远程主机【可以是主机名、完全限定域名，或IP地址】
		User				远程主机上的用户
		IdentityFile		公钥文件的完整路径
		IdentitiesOnly yes	告诉 ssh 使用 ~/.ssh/config中的配置，或传递命令行，而不是使用其他提供程序（如果有）。
		Port				指定sshd服务监听的端口号
9、更改密码
	使用【ssh-keygen -p】更改指定私钥的密码。如：
		ssh-keygen -p -i ~/.ssh/id-server2
	密码短语不可恢复。 如果丢失了密码，唯一的选择是使用新密码创建新密钥。
10、使用sshfs挂载远程文件系统
	sshfs用于挂载整个远程文件系统，然后就可以像本地文件系统一样访问。安装 sshfs 包，它还应该安装 FUSE（用户空间中的文件系统）。需要一个具有写入权限的本地目录作为挂载点
	①	安装 sshfs
		yum -y install fuse-sshfs
	②	挂载远程目录
		sshfs server2: sshfs/
	③	卸载远程文件系统
		fusermount -u sshfs/
	也可以挂载指定的目录，如：
		sshfs server2:/home/duchess/arias sshfs/
	注意：sshfs不能使用【~】（不支持）
	如果网络连接不可靠。通过【-o reconnect】告诉sshfs在网络中断后自动重连。
11、加密算法
	通过【ssh -Q <query_option>】查询OpenSSH支持的算法。通过【help】选项列出所有支持的算法。如：
		# ssh -Q help
		cipher
		cipher-auth
		compression
		kex
		kex-gss
		key
		key-cert
		key-plain
		key-sig
		mac
		protocol-version
		sig
	列出【sig】签名算法：
		# ssh -Q sig
		ssh-ed25519
		sk-ssh-ed25519@openssh.com
		ssh-rsa
		rsa-sha2-256
		rsa-sha2-512
		ssh-dss
		ecdsa-sha2-nistp256
		ecdsa-sha2-nistp384
		ecdsa-sha2-nistp521
		sk-ecdsa-sha2-nistp256@openssh.com
		webauthn-sk-ecdsa-sha2-nistp256@openssh.com
	》说明
		cipher				列出支持的对称密码
		cipher-auth			列出支持的对称密码，这些密码也支持经过身份验证的加密。
		compression			列出支持的压缩类型
		mac					列出支持的消息完整性代码。 这些可以保护消息的数据完整性和真实性。
		kex					列出密钥交换算法
		kex-gss				列出了GSSAPI（通用安全服务应用程序接口）密钥交换算法
		key					列出密钥类型
		key-cert			列出证书密钥类型
		key-plain			列出非证书密钥类型
		key-sig				列出所有密钥类型和签名算法
		protocol-version	列出支持的SSH协议版本
		sig					列出支持的签名算法
	

Secure Remote Access with OpenVPN
	开放虚拟专用网络 (OpenVPN) 在不同物理位置的两个不同网络之间创建 TLS/SSL 加密连接。这种连接称为加密隧道，这是一种安全的传输方式，可保护连接免受大的不良互联网的影响。OpenVPN依赖于OpenSSL。
1、OpenVPN概述
	VPN 是网络的安全扩展，它使远程工作人员可以使用本地用户拥有的所有相同服务，因此远程用户的体验与实际存在于您所在位置的用户的体验相同。 
	他们可以访问您的本地网络服务器、电子邮件、文件共享、聊天服务器、视频会议应用程序、内部 wiki，以及您与外界隔离且仅对网络内部的用户可用的所有内容。 
	VPN 与 SSH 不同，SSH 可以连接各个计算机。 VPN 将网络和单个主机链接到网络。
	OpenVPN 是一个开源项目，免费的服务器和客户端是 openvpn 软件包，可在所有 Linux 发行版上使用，并可在 OpenVPN Community Downloads【https://openvpn.net/community-downloads/】中下载。 
	商业选项包括 OpenVPN 访问服务器，它是带有附加管理工具和云选项的本地服务器。托管个人计划仅需要安装客户端并提供对 OpenVPN 服务器全球网络的访问。
	真正的 VPN 非常强大，因为它不信任任何人，并且需要经过身份验证的端点，其中服务器和客户端相互进行身份验证。 
	大多数商业 TLS/SSL VPN 不会这样做，而是信任所有客户端，就像购物网站一样。 这更加灵活，允许用户使用任何设备从任何地方登录。 无需安装和配置客户端软件以及复制加密密钥，非常方便。 
	但对于目光短浅的内部网络来说，您最不需要的就是用户从感染了键盘记录器和间谍软件的随机 PC 或智能手机登录，然后受到热烈欢迎进入您的 LAN。
	①	证书颁发机构（CA）
	证书颁发机构 (CA) 是运行 OpenVPN 服务器的最重要部分。 CA 颁发数字证书并证明公钥的所有权。CA 是值得信赖的权威机构，这就是为什么许多站点使用商业 CA 的原因。自签名证书，可以在您的组织内部使用。面向客户的站点应使用商业 CA。 
	使用 CA 可以让您免去在 OpenVPN 服务器上保存客户端证书副本的麻烦； 服务器需要知道的是客户端证书是由您的 CA 进行身份验证的。
	②	SSL与TLS
	安全套接字层（SSL）和传输层安全性（TLS）是加密协议。TLS是从SSL发展而来的。所有版本的SSL均已启用，TLS 1.0 和 TLS 1.1 也是如此。使用 TLS 1.2 或 1.3，并禁用所有其他协议。 由于安全缺陷，旧版本已被弃用。
	③	TUN/TAP
	TUN 和 TAP 设备是虚拟网络接口。 它们内置于 Linux 内核中，无需执行任何操作即可使它们可用。 TUN 设备用于路由网络，TAP 设备用于桥接网络。 您的服务器和客户端配置文件指定要使用哪一个。
2、安装OpenVPN，服务器和客户端
	OpenVPN 网站同时提供社区开源 OpenVPN 和商业 OpenVPN Access Server。 社区 OpenVPN 是免费且开源的。
	在Linux上安装openvpn软件包。尽可能获得最新版本，这提供了服务器和客户端。源tarball和Windows安装程序可从OpenVPN社区下载获取。
	对于用户，可以尝试免费的 OpenVPN 访问客户端，该客户端适用于 Linux、macOS、Android、iOS 和 Windows。 它们专为商业 OpenVPN 访问服务器而设计，也可与社区 OpenVPN 服务器配合使用。
	在 Linux 上，OpenVPN 必须安装在 OpenVPN 服务器和所有客户端上。 OpenVPN 包提供客户端和服务器功能。
	Ubuntu、Fedora 和 openSUSE 包含提供与 NetworkManager 集成的附加软件包，这使得管理、连接和断开 VPN 变得轻松简单。
	NetworkManager-openvpn（Fedora、openSUSE）和 network-manager-openvpn（Ubuntu）将 OpenVPN 与 Network Manager 集成。
	OpenVPN Access Server 是免费下载的，可以同时连接最多两个客户端，而无需购买许可证。 它具有附加功能，例如 Web 管理界面和使用免费 OpenVPN 访问客户端进行自动配置。 
	如果从社区 OpenVPN 开始，然后决定迁移到 OpenVPN Access Server，在社区 OpenVPN 服务器中学到的所有内容也适用于 Access Server。
3、设置简单的连接测试
	
	








		

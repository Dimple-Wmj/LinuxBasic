The Big Picture
1、Linux系统中的抽象级别和层次
	Linux操作系统有三个主要的层次：
		hardware	硬件位于底层。硬件包括存储器以及一个或多个中央处理单元（CPU）已执行计算以及从存储器读取和向存储器写入。磁盘和网络接口等设备也是硬件的一部分。
		kernel		内核是第二层。操作系统的核心。内核是驻留在内存中的软件，告诉CPU在哪里寻找下一个任务。作为中介，内核管理硬件（尤其是主内存），并且是硬件和任何正在运行的程序之间的主要接口。
		processes	内核管理的运行中的程序（共同构成了系统的上层），称为用户空间【user space】。（进程更具体术语是用户进程，无论用户是否直接与进程交互。）
	通用Linux系统组织：
		User Processes			Graphical User Interface		Servers		Shell
		Linux Kernel			System Calls	Process Management	Memory Management	Device Drivers
		Hardware				Processor(CPU)	Main Memory(RAM)	Disks	Network Ports
	内核和用户进程的运行方式之间存在一个关键区别：内核在内核模式下运行，用户进程在用户模式下运行。在内核模式下运行的代码可以不受限制地访问处理器和主内存。只有内核可以访问地内存区域称为内核空间。
	用户模式限制对内存子集（通常很小）的访问和安全的CPU操作。用户空间是指用户进程可以访问的主内存部分。如果一个进程出错并崩溃，其后果是有限的。
	理论上，用户进程失控不会对系统的其余部分造成严重损害。 实际上，这取决于您所认为的“严重损害”以及进程的特定特权，因为某些进程被允许比其他进程执行更多操作【如，用户进程是否可以完全破坏磁盘上的数据】。
	》注意：
		Linux内核可以运行内核线程【kernel thread】，类似于进程，但可以访问内核空间【如，kthreadd和kblockd】。
2、硬件：理解主内存
	在计算机系统的所有硬件中，主存储器可能是最重要的。在最原始的形式中，主存只是一个存储一堆0和1的大存储区域。每个0或1的槽称为一个位。这是正在运行的内核和进程所在的位置——它们只是位的大集合。
	外围设备的所有输入和输出都以一堆位的形式流经主存储器。CPU只是内存上的一个操作符；它从内存中读取指令和数据并将数据写回内存。
	通常用“状态”来指代内存、进程、内核和计算机系统的其他部分。严格来说，状态是位的特定排列【如，如果内存中有四位，0110、0001和1011代表三种不同的状态】。
	当考虑到单个进程可以轻松地由内存中的数百万位组成时，在谈论状态时使用抽象术语通常更容易。不是使用位来描述状态，而是描述某件事此时已完成或正在执行的操作。例如，可能会说“进程正在等待输入”或“进程正在执行启动的第 2 阶段”。
	因为通常用抽象术语来指代状态而不是实际的位，所以术语“图像”指的是位的特定物理排列。
3、内核
	内核所做的几乎所有事情都围绕着主内存。内核的任务之一是将内存分成许多分区，并且它必须始终维护有关这些分区的某些状态信息。每个进程都有自己的内存份额，内核必须确保每个进程保留其份额。
	内核负责管理四个通用系统区域的任务：
		①	进程			内核负责确定允许哪些进程使用CPU
		②	内存			内核需要跟踪所有内存——当前分配给特定进程的内存、进程之间可能共享的内存以及空闲的内存。
		③	设备驱动		内核充当硬件（如，磁盘）和进程之间的接口。操作硬件通常是内核的工作。
		④	系统调用和支持	进程通常使用系统调用与内核进行通信
	Ⅰ	进程管理
		进程管理描述进程的启动、暂停、恢复、调度和终止。 启动和终止进程背后的概念相当简单，但描述进程在正常操作过程中如何使用 CPU 则有点复杂。在任何现代操作系统上，许多进程“同时”运行。
		考虑一个具有单核 CPU 的系统。 许多进程可能能够使用 CPU，但在任何给定时间只有一个进程实际上可以使用 CPU。 
		实际上，每个进程都会使用 CPU 一小部分时间，然后暂停； 然后另一个进程使用 CPU 又一小会儿； 然后另一个进程轮流进行，依此类推。 一个进程将 CPU 控制权交给另一个进程的行为称为上下文切换【context switch】。
		每一段时间（称为时间片【time slice】）为进程提供足够的时间来进行大量计算（事实上，进程通常在单个时间片内完成其当前任务）。
		然而，由于切片非常小，人类无法感知它们，并且系统似乎同时运行多个进程（这种能力称为多任务处理【multitasking】）。
		内核负责上下文切换。如：
			①	CPU（实际的硬件）根据内部定时器中断当前进程，切换到内核模式，并将控制权交还给内核。
			②	内核记录CPU和内存的当前状态，这对于恢复刚刚中断的进程至关重要
			③	内核执行前一个时间片期间可能出现的任何任务（如，从输入和输出或I/O操作收集数据）
			④	内核现在已准备好让另一个进程运行。内核分析准备运行的进程列表并选择一个
			⑤	内核为这个新进程准备内存，然后准备CPU
			⑥	内核告诉CPU新进程的时间片将持续多长时间
			⑦	内核将CPU切换到用户模式并将CPU的控制权交给进程
		上下文切换回答了内核何时运行的重要问题【它在上下文切换期间的进程片之间运行】。
		在多CPU系统的情况下，就像大多数当前的机器一样，事情会变得稍微复杂一些，因为内核不需要放弃对其当前CPU的控制来允许进程在不同的CPU上运行。一次可以运行一个以上进程。
		为了最大限度地利用所有可用的CPU，内核通常会执行这些步骤（并且可能使用某些技巧来自己争取更多的CPU时间）。
	Ⅱ	内存管理
		内核必须在上下文切换期间管理内存，这可能是一项复杂的工作。必须满足以下条件：
			①	内核必须在内存中拥有自己的私有区域，用户进程无法访问
			②	每个用户进程都需要自己的内存部分
			③	一个用户进程不能访问另一进程的私有内存
			④	用户进程能共享内存
			⑤	用户进程中的某些内存可以是只读的
			⑥	通过使用磁盘空间作为辅助，系统可以使用比物理内存更多的内存
		现代CPU包含内存管理单元（MMU），它支持称为虚拟内存的内存访问方案。使用虚拟内存时，进程不会通过内存在硬件中的物理位置直接访问内存。相反，内核将每个进程设置为好像自己拥有一整台机器一样。
		当进程访问其某些内存时，MMU会拦截该访问并使用内存地址映射将进程角度的内存位置转换为机器中的实际物理内存位置。内核仍然必须初始化并持续维护和更改此内存地址映射。
		如，在上下文切换期间，内核必须将映射从传出进程更改为传入进程。
		》注意：内存地址映射的实现称为页表。
	Ⅲ	设备驱动和管理
		内核对于设备的作用相对简单。设备通常只能在内核模式下访问，因为不正确的访问可能会使机器崩溃。
		不同的设备很少具有相同的编程接口，即使设备执行相同的任务（如，两个不同的网卡）。因此，设备驱动程序传统上是内核的一部分，它们努力为用户进程提供统一的接口，以简化软件开发人员的工作。
	Ⅳ	系统调用和支持
		还有几种其他类型的内核功能可供用户进程使用。如，系统调用（syscalls）执行用户进程单独无法完成或根本无法完成的特定任务（如，打开、读取和写入文件的行为都涉及系统调用）。
		两种系统调用【fork() 和 exec()】，对于理解进程如何启动很重要：
			①	fork()	当进程调用 fork() 时，内核会创建该进程的几乎相同的副本。
			②	exec()	当进程调用 exec(program) 时，内核加载和启动 program ，替换当前进程。
		除了 init 之外，Linux系统上的所有新用户进程都是通过 fork() 启动的，并且大多数时候，还可以运行 exec() 来启动新程序，而不是运行某个现有进程的副本。
		如，在命令行上执行ls时，在终端窗口内运行的shell会调用fork()创建shell的副本，然后shell的新副本会调用exec(ls)来运行ls。
		》注意：系统调用是进程和内核之间的交互。
		内核还支持具有传统系统调用以外功能的用户进程，其中最常见的是伪设备【pseudodevices】。伪设备对于用户进程来说看起来像设备，但它们纯粹是在软件中实现的。这意味着它们在技术上不需要位于内核中，但它们通常出于实际原因而存在。
		如内核随机数生成器设备（/dev/random）很难通过用户进程安全地实现。
		》注意：从技术上讲，访问伪设备的用户进程必须使用调用调用来打开设备，因此进程无法完全避免系统调用。
4、用户空间
	内核为用户进程分配的主内存称为用户空间。由于进程只是内存中的一个状态（或映像），因此用户空间也指正在运行的进程的整个集合的内存。（可能还听到用于表示用户空间的更非正式术语userland；有时这也意味着在用户空间中运行的程序）。
	Linux系统上的大部分实际操作都发生在用户空间中。尽管从内核的角度来看，所有进程本质上都是平等的，但它们为用户执行不同的任务。用户进程所代表的系统组件类型有一个基本的服务级别（或层）结构。
	基本服务位于最底层（最接近内核），实用服务位于中间，用户接触的应用程序位于顶部。
	底层往往由执行单一、不复杂任务的小组件组成。中间层有较大的组件，例如邮件、打印和数据库服务。最后，顶层组件执行用户通常直接控制的复杂任务。
	组件还使用其他组件。 一般来说，如果一个组件想要使用另一个组件，则第二个组件要么处于相同的服务级别，要么低于该组件。
	此外，对一些用户空间组件进行分类也很困难。服务器组件（例如 Web 和数据库服务器）可以被视为非常高级的应用程序，因为它们的任务通常很复杂，因此您可以将它们放在图 1-3 中的顶层。
	但是，用户应用程序可能依赖这些服务器来执行他们不想自己执行的任务，因此也可以将它们放置在中间级别。
5、用户
	Linux内核支持传统的Unix用户概念。用户是可以运行进程并拥有文件的实体。用户通常与用户名关联。内核并不管理用户名；它通过称为用户ID的简单数字标识符来识别用户。
	用户的存在主要是为了权限和边界。每个用户空间进程都有一个用户所有者，并且进程被称为以所有者身份运行。用户可以终止或修改自己进程的行为（在约定限制内），但不能干扰其他用户的进程。
	此外，用户可以拥有文件并选择是否与其他用户共享它们。
	除了与使用该系统的真实用户相对应的用户之外，Linux 系统通常还有许多用户。root 用户是上述规则的例外，因为 root 可以终止并更改其他用户的进程并访问本地系统上的任何文件。 
	因此，root 被称为超级用户。 能够以 root 身份操作（即具有 root 访问权限）的人是传统 Unix 系统上的管理员。


Basic Commands and Directories Hierarchy
1、The Bourne Shell：/bin/sh
	shell 是 Unix 系统最重要的部分之一。shell是运行命令的程序，就像用户在终端窗口中输入的命令一样。这些命令可以是其他程序或shell的内置功能。
	shell还可以用作小型编程环境。Unix程序员经常将常见任务分解为更小的组件，并使用shell来管理任务并将事物组合在一起。
	系统的许多重要部分实际上都是 shell 脚本，即包含一系列 shell 命令的文本文件。
	有许多不同的 Unix shell，但所有功能都源自 Bourne shell (/bin/sh)，这是贝尔实验室为早期版本的 Unix 开发的标准 shell。每个 Unix 系统都需要一个版本的 Bourne shell 才能正常运行。
	Linux 使用 Bourne shell 的增强版本，称为 bash 或“Bourne-again”shell。 bash shell 是大多数 Linux 发行版上的默认 shell，/bin/sh 通常是 Linux 系统上 bash 的链接。
2、使用 shell
	Ⅰ	Shell 窗口
		登录后，打开shell窗口（通常称为终端）。从Gnome或KDE等GUI中执行此操作的最简单方法是打开终端应用程序，该应用程序会在新窗口中启动shell。
		打开shell后，它应该在顶部显示一个提示【PS1】，通常以 $ 结尾。命令通常以要运行的程序开始，后面可能跟着参数，告诉程序要操作什么以及如何操作。
	Ⅱ	标准输入和标准输出
		Unix进程使用I/O流来读取和写入数据。进程从输入流读取数据并将数据写入输出流。流非常灵活。如，输入流的源可以是文件、设备、终端窗口，甚至是来自另一个进程的输出流。
		当 cat 不指定输入文件名时，cat将从Linux内核提供的标准输入流中读取，而不是从连接到文件的流中读取。在这种情况下，标准输入连接到运行cat的终端。
		在空行上按 Ctrl-D 将停止来自终端的当前标准输入条目，并显示EOF（文件结束）消息（并且通常会终止程序）。不要将其与 Ctrl-C 混淆，后者通常会终止程序，无论其输入或输出如何。
		标准输出类似。内核为每个进程提供一个标准输出流，可以在其中写入其输出。cat始终将其输出写入标准输出。当在终端中运行cat时，标准输出已连接到该终端，可以在其中看到输出。
		标准输入和标准输出通常缩写为stdin和stdout。许多命令的操作方式与cat相同；如果不指定输入文件，命令将从stdin读取。输出有点不同。某些程序（如，cat）仅将输出发送到stdout，但其他程序可以选择将输出直接发送到文件。
		有第三个标准I/O流，叫作标准错误。
		标准流的最佳功能之一是可以轻松地操纵它们来读取和写入终端以外地地方。
3、基本命令
	Ⅰ	ls
		ls 列出目录地内容。默认值是当前目录，可以添加任何目录或文件作为参数，并且有许多有用地选项。
	Ⅱ	cp	
		cp 最简单形式是复制文件，如将file1复制到file2：
			cp file1 file2
		还可以复制文件到另一个目录，并在该目录中保留相同的文件名：
			cp file dir
		要将多个文件复制到名为dir的目录中，使用如下类似操作【复制三个文件】：
			cp file1 file2 file3 dir
	Ⅲ	mv
		mv（移动）的工作方式与 cp 类似。最简单的形式是重命名文件。如将 file1 重命名为 file2：
			mv file1 file2
		也可使用 mv 将文件移动到其他目录，方法与 cp 相同。
	Ⅳ	touch
		touch 可以创建一个文件。如果目标文件已经存在，则 touch 不会更改文件，但会更新文件的修改时间戳。创建空文件：
			touch newfile
	Ⅴ	rm
		rm 命令删除（移除）文件。删除文件后，它通常会从系统中消失，并且通常无法恢复删除，除非从备份中恢复它。
			rm file
	Ⅵ	echo
		echo 命令将其参数打印到标准输出
		echo 命令对于查找shell全局变量（“通配符”，如*）和变量（$HOME）的扩展非常有用。
4、导航目录
	Unix目录层级以 / （也称为根目录）开始。目录分割器是 / 。在root目录中有多个标准子目录。当引用文件或目录时，指定路径或路径名。当路径以 / 开头时，它是完整路径或绝对路径。
	由 .. 标识的路径组件指定目录的父目录。一个点 . 标识当前目录。
	路径不以 / 开始，称为相对路径。
	Ⅰ	cd
		使用 cd 命令更改当前工作目录：
			cd dir
		如果缺少 dir ，shell 回到当前用户家目录。可以使用 ~ 表示家目录。
		cd 是 shell 内置命令。它不能作为单独的程序运行，如果作为子进程运行，它（通常）无法更改其父进程的当前工作目录。
	Ⅱ	mkdir
		mkdir 创建新目录：
			mkdir dir
	Ⅲ	rmdir
		rmdir 删除（空）目录：
			rmdir dir
	Ⅳ	Shell Globbing（“Wildcards”）
		shell 可以将简单模式与文件名和目录名进行匹配，这一过程称为通配符。
			①	*		匹配任意数量的任意字符
			②	?		精确匹配一个任意字符
		shell 将包含glob 的参数与文件名进行匹配，用文件名替换这些参数，然后运行修改后的命令。这种替换称为扩展【shell将所有匹配的文件名替换为简化的表达式】。
		如果没有文件与glob匹配，则bash shell不执行扩展，并且命令使用字面量运行。
		》注意：
			在Linux中，必须使用*来匹配所有文件。在Unix Shell中，*.* 仅匹配名称中包含点（.）字符的文件和目录。
		如果不希望shell在命令中展开glob，将glob括在单引号（''）中。
		》注意：
			shell 在运行命令之前进行扩展，并且只有在那时才执行扩展。如果 * 使其成为命令而不扩展，则shell不会对其执行任何操作。
5、中级命令
	Ⅰ	grep
		grep 命令打印文件或输入流中与表达式匹配的行。grep命令在同时操作多个文件时非常方便，因为它除了匹配行之外还打印文件名。
		grep两种最重要的选择分别是 -i【忽略大小写】、-v【反向匹配】。
		grep 理解正则表达式、基于计算机科学理论的模式，并且在Unix使用程序中非常常见。正则表达式比通配符模式更强大，并且它们具有不同的语法。关于正则表达式，需要记住三件重要的事情：
			①	.*	匹配任意数量字符，包括none（就像通配符中的*）
			②	.+	匹配任意一个或多个字符
			③	.	匹配任意单个字符
	Ⅱ	less
		当文件很大或命令的输出很长并且滚动到屏幕顶部时，less 命令会排上用场。less 是 more 的增强版本。
		当有一个需要筛选大量输出的命令并且想使用less之类的东西来查看输出时，这非常有用。如：
			grep -ie /usr/share/dict/words | less
	Ⅲ	pwd
		pwd（打印工作目录）程序只是输出当前工作目录的名称。
		符号连接有时会覆盖当前工作目录的真实完整路径，使用 pwd -P 可以消除这种混乱。
	Ⅳ	diff
		使用 diff 查看两个文本文件的不同
	Ⅴ	file
		如果不确定文件的格式，可以尝试使用 file 命令。
	Ⅵ	find 和 locate
		查看文件的具体路径。
		locate不是实时搜索文件，而是搜索系统定期构建的索引。使用locate进行搜索比find快得多，但如果要查找的文件比索引新，locate将找不到它。
	Ⅶ	head 和 tail
		head 和 tail 允许快速查看文件或数据流的一部分。
	Ⅷ	sort
		sort 命令快速将文本文件的行按字母数字顺序排列。如果文件的行以数字开头并且想按数字顺序排序，使用 -n 选项。-r 选项反转排序顺序。
6、更改密码和shell
	使用 passwd 命令更改登录密码。使用 chsh 更改登录shell【如，zsh，ksh或tcsh】。
7、点文件
	除非使用 -a 选项，否则 ls 不会列出点文件。此外，明确使用 .* 等模式，否则 shell glob 不匹配点文件。
	》注意：
		可能会遇到 glob 问题。因为 .* 匹配 . 和 ..（当前目录和父目录）。可能希望使用 .[^.]* 或 .??* 等模式来获取除当前目录和父目录之外的所有点文件。
8、环境和 shell 变量
	shell 可以存储临时变量，称为shell变量，其中包含文件字符串的值。shell变量对于跟踪脚本中的值非常有用，并且一些shell变量控制shell的行为方式。
	要将值分配给shell变量，使用等号（=）。如：
		STUFF=blah
	要访问此变量，使用 $STUFF 。
	》注意：分配变量时，不要在 = 两边添加任何空格。
	环境变量就像shell变量，但它不是特定于shell的。Unix系统上的所有进程都有环境变量存储。环境变量和shell变量中间的主要区别在于，操作系统将shell的所有环境变量传递给shell运行的程序，而shell变量无法在运行的命令中访问呢。
	可以使用 export 命令分配环境变量，如：
		STUFF=blah
		export STUFF
	由于子进程从父进程继承环境变量，因此许多程序都会读取它们以进行配合和作为选项。
9、命令路径
	PATH 是一个特殊环境变量，其包含命令路径（或路径），shell在尝试查找命令时搜索的系统目录列表。
	要告诉shell在更多的位置查找程序，更改路径环境变量。如：
		PATH=dir:$PATH
	如果在修改路径时错误输入 $PATH，您可能会意外擦除整个路径。如果发生这种情况，请不要惊慌！ 这种损害不是永久性的；可以启动一个新的shell。要让修改永久生效，将修改写入某个配置文件中【如，~/.bashrc】
10、特殊字符
		Character		Name(s)					Uses
		*				星号					正则表达式，统配符
		.				点号					当前目录，文件/主机名分隔符
		!				叹号					否定，命令历史记录
		|				管道					命令管道
		/				斜杆					目录分隔符，搜索命令
		\				反斜杠					文字、宏（不是目录）
		$				美元					变量，行尾
		'				单引号					字面量字符串
		`				反引号					命令替换
		"				双引号					半字面量【semi-literal】字符串
		^				插入符					否定，行首
		~				波浪号					否定，目录简称
		#				hash，sharp，pound		注释、预处理器、替换
		[]				方括号					范围【ranges】
		{}				大括号、花括号			语句块、范围
		_				下划线					当不需要或不允许空格时，或当自动完成算法感到困惑时，可以使用_作为空格的替代品
11、命令行编辑
	使用 shell 时，可以使用向左和向右箭头编辑命令行，以及使用向上和向下箭头翻阅先前的命令。还有如下命令行快捷键：
		快捷键				动作
		Ctrl-B				向左移动光标
		Ctrl-F				向右移动光标
		Ctrl-P				查看上一条命令（或将光标向上移动）
		Ctrl-N				查看下一条命令（或将光标向下移动）
		Ctrl-A				移动光标到行首
		Ctrl-E				移动光标到行尾
		Ctrl-W				删除前面的单词
		CTRL-U				删除从光标到行首的内容
		Ctrl-K				删除从光标到行尾的内容
		Ctrl-Y				粘贴删除的文本（如，通过Ctrl-U）
12、获取在线帮助
	Linux 系统附带了丰富的文档。对于基本命令，手册页将告诉需要了解的内容。如：
		man ls
	当程序有很多选项时，手册页通常会以某种系统的方式列出选项。要按关键字搜索手册页，使用 -k 选项，如：
		man -k keyword
	如果不太清楚所需命令的名称，这会很有帮助【如，正在寻找对某些内容进行排序的命令】：
		man -k sort
	输出包括手册页名称、手册部分以及手册页所含内容的快速说明。
	手册页通过编号的部分进行引用。当有人引用手册页时，经常将章节编号放在名称旁边的括号中【如，ping(8)】。在线手册部分如下：
		Section		Descripiton
		1			用户命令
		2			内核系统调用
		3			高层Unix编程库文档
		4			设备接口和驱动信息
		5			文件描述（系统配置文件）
		6			游戏
		7			文件格式、约定和编码（ASCII、后缀等）
		8			系统命令和服务
	一些常用术语在多个部分中有许多匹配项的手册页。默认，man 显示它找到的第一页。可以按章节选择手册页。如：
		man 5 passwd
	手册页涵盖了要点，但还有更多方法可以获得在线帮助（除了搜索互联网之外）。如果只是查找命令的某个选项，请尝试输入命令名称，后跟 --help 或 -h（选项因命令而异）。
	可能会得到大量信息（如 ls --help 的情况），或者可能会找到正在寻找的内容。
	手册页还有另一种格式【info，或textinfo】。通常，此文档比典型的手册页更深入，但也可能更复杂。要访问信息手册，使用带有命名命令的info：
		info command
	某些软件包将其可用文档转储到 /usr/share/doc 中，而不考虑在线手册系统（例如 man 或 info）。如果发现在搜索文档，当然还需要搜索互联网，请参阅系统上的此目录。
13、shell 输入和输出
	要将命令的输出发送到文件而不是终端，使用 > 重定向符，如：
		command > file
	如果 file 不存在，则shell会创建该文件。如果 file 存在，shell首先删除（破坏）原始文件（有些shell具有防止破坏的参数）。如可以输入 set -C 以避免在bash中破坏。
	可以使用 >> 重定向符将输出附加到文件，而不是覆盖文件，如：
		command >> file
	这是在执行相关命令序列时在一个地方收集输出的一种便捷方法。
	要将一个命令的标准输出发送到另一个命令的标准输入，使用管道字符（|）。如：
		head /proc/cpuinfo | tr a-z A-Z
	可以根据需要通过任意数量的管道命令发送输出；只需在每个附加命令之前添加另一个管道即可。
	Ⅰ	标准错误
		有时，可能会重定向标准输出，但仍然向终端打印一些呢容。这称为标准错误（stderr）；它是用于诊断和调试的附加输出流。使用 2> 语法可以重定向标准错误。如，将标准输出发送到f并将标准错误发送到e：
			ls /ffffff > f 2> e
		数字2指定shell修改的流ID，流ID 1 是标准输出（默认0），2是标准错误。
		还可以使用 >& 符号将标准错误发送到于stdout相同的位置。如，将标准输出和标准错误发送到名为f的文件：
			ls /fffff > f 2>&1
	Ⅱ	标准输入重定向
		要将文件发送到程序的标准输入，使用 < 运算符：
			head < /proc/cpuinfo
		偶尔会遇到需要此类重定向的程序，但由于大多数 Unix 命令接受文件名作为参数，因此这种情况并不常见。
14、错误消息
	Unix 错误通常会告知到底出了什么问题。
	Ⅰ	Unix 错误消息剖析
		大多数Unix程序生成并报告相同的基本错误消息，但任何两个程序的输出之间可能存在细微差别。如：
			# ls /dsafsda
			ls: cannot access '/dsafsda': No such file or directory
		此消息包含三个组成部分：
			①	程序名称【ls】。有些程序会忽略此识别信息，这在编写shell脚本时可能会很烦人，但这并不是什么大问题。
			②	文件名【/dsafsda】。这是更具体地信息。这里路径有问题
			③	No such file or directory 表明文件名有问题
		排除错误时，始终首先解决第一个错误。 一些程序报告说，在报告许多其他问题之前，它们无法做任何事情。
		不要将错误消息与警告消息混淆。警告通常看起来像错误，但它们包含【warning】。警告通常意味着出现问题，但程序无论如何都会尝试继续运行。要解决警告消息中指出地问题，可能必须先找到一个进程并将其终止，然后再执行其他操作。
	Ⅱ	常用错误
		在Unix程序中遇到的许多错误都是由文件和进程可能出现的问题引起的。其中相当多的错误直接源于内核系统调用遇到的条件，因此，可以通过查看它们来了解内核如何将问题发送回进程。
		①	No such file or directory
			尝试访问不存在的文件。 由于 Unix 文件 I/O 系统不太区分文件和目录，因此此错误消息涵盖了这两种情况。当尝试读取不存在的文件、尝试更改到不存在的目录、尝试写入不存在的目录中的文件等等时，会得到它 。 
			此错误也称为 ENOENT，是“Error NO ENTity”的缩写。
		②	File exists
			在这种情况下，可能尝试创建一个已存在的文件。当尝试创建于文件同名的目录时，这种情况很常见。
		③	Not a directory, Is a directory
			当尝试将文件用作目录或将目录用作文件时，会弹出这些消息。
		④	No space left on device
			磁盘空间不足
		⑤	Permission denied
			当尝试读取或写入无权访问的文件或目录（没有足够的权限）时，会收到此错误。当尝试执行未设置执行位的文件时（即使可以读取该文件），也会出现此错误。
		⑥	Operation not permitted
			当尝试终止不属于自己的进程时，通常会发生这种情况。
		⑦	Segmentation fault, Bus error
			分段错误【segmentation fault】本质上意味着编写刚刚运行的程序的人在某个地方搞砸了。该程序试图访问不允许其访问的内存部分，操作系统将其杀死。
			总线错误【bus error】意味着程序试图以不应该的方式访问某些内存。当遇到这些错误之一时，可能会向程序提供一些它没有预料到的输入。在极少数情况下，可能是内存硬件出现故障。
15、列出和操作进程
	进程是运行中的程序。系统中的每个进程都有一个进程ID（PID）。要快速列出正在运行的进程，只需在命令行上运行ps即可。ps输出字段说明如下：
		①	PID		进程ID
		②	TTY		进程运行的终端设备。
		③	STAT	进程状态——即进程正在做什么以及它的内存驻留在哪里。S表示sleeping、R表示running。
		④	TIME	进程到目前为止已使用的CPU时间量（以分钟和秒为单位）。进程在处理器上运行指令所花费的总时间。由于，进程不会持续运行，因此这于进程启动以来的时间不同。
		⑤	COMMAND	作用于运行程序的命令。进程可以更改此字段的原始值。shell可以执行全局扩展，并且该字段将反应扩展后的命令，而不是在提示符下输入的内容。
	Ⅰ	ps 命令选项
		ps 命令有很多选项。可以用三种不同的风格指定选项：Unix、BSD和GNU。
		BSD风格的最有用选项组合如下：
			①	ps x		显示所有正在运行的进程
			②	ps ax		显示系统上所有进程，不仅仅是当前用户的
			③	ps u		包含进程更详细的信息
			④	ps w		显示完整命令名，而不仅仅是一行中的内容
		可以组合选项，如ps aux 和 ps auxw 。要检查特定进程，将其PID添加到 ps 命令的参数列表中。如，要检查当前shell进程，可使用 ps u $$ （$$ 是一个shell变量，其计算结果为当前shell的PID）。
	Ⅱ	进程终止
		要终止一个进程，给其发送一个信号【signal】——从内核到进程的消息——使用 kill 命令。如：
			kill pid
		信号有多种类型。默认值是TERM，或终止（terminate）。还可以通过添加额外的终止选项来发送不同的信号。如要冻结进程而不是终止它，使用STOP信号。
			kill -STOP pid
		停止的进程仍在内存中，准备从停止的地方继续。使用 CONT 信号再次继续运行该进程。如：
			kill -CONT pid
		》注意：
			使用 CTRL-C终止当前终端中运行的进程与使用 kill 通过 INT （中断）信号结束进程的效果相同。
		内核为大多数进程提供了在接收信号后自行清理的机会（使用信号处理程序机制）。但，某些进程可能会选择非终止操作来响应信号，在尝试处理信号的过程中陷入困境，或干脆忽略它，因此可能会发现进程在尝试终止它后仍在运行。
		如果发生这种情况并且确实需要终止一个进程，终止它的最残酷的方法是使用 KILL 信号。与其他信号不同，KILL 不能被忽略；事实上，操作系统甚至不给该进程机会。内核只是终止进程并强制将其从内存中删除。仅将此方法用作最后的手段。
		不应该随意终止进程，尤其是当不知道它们在做什么时。
		还可以使用数字来表示信号【内核使用数字来表示不同的信号】。运行 kill -l 获取信号编号到名称的映射。
	Ⅲ	任务【job】控制
		shell 支持任务控制，一个通过使用不同按键和命令给程序发送TSTP（类似于 STOP ）和 CONT 信号。这允许暂停并自正在使用的程序之间切换。
		如，可以使用CTRL-Z发送TSTP信号，然后通过输入fg（进入前台）或bg（移至后台）再次启动该程序。
		》注意：
			要查看你是否意外暂停了当前终端上的任何进程，运行 job 命令。
	Ⅳ	后台进程
		通常，当从shell运行Unix命令时，直到程序执行完毕后才会返回shell提示符。可以进程从shell中分离出来，并使用 & 将其置于后台（如使用 gunzip 解压缩大文件）：
			gunzip file.gz &
		shell 应该通过打印新后台进程的 PID 来响应，并且提示符应该立即返回，以便可以继续工作。 如果该过程需要很长时间，它甚至可以在注销后继续运行，如果必须运行一个进行大量数字运算的程序，这会特别方便。 
		如果该过程在注销或关闭终端窗口之前完成，shell 通常会通知，具体取决于设置。
		》注意：
			如果正在远程访问计算机并希望在注销时保持程序运行，可能需要使用 nohup 命令。
		运行后台进程的缺点是它们可能期望使用标准输入（或直接从终端读取）。如果程序在后台尝试从标准输入读取某些内容，它可能会冻结（尝试使用fg将其恢复）或终止。
		此外，如果程序写入标准输出或标准错误，输出可能会出现在终端窗口中，而不考虑那里运行的其他任何内容，这意味着当处理其他事情时可能会得到意外的输出。
		确保后台进程影响其他的最佳方法是重定向其输出（也可能是输入）。
		如果后台进程的虚假输出妨碍您，请了解如何重绘终端窗口的内容。bash shell支持Ctrl-L来重回整个屏幕。如果程序正在从标准输入读取，Ctrl-R通常会重绘当前行，但在错误的时间按下错误的序列可能会陷入比以前更糟糕的情况。
		如，bash提示符下输入Ctrl-R会进入反向isearch模式（按ESC退出）。
17、文件模式和权限
	每个 Unix 文件都有一组权限，决定是否可以读取、写入或运行该文件。 运行 ls -l 显示权限。
	使用 groups 命令可以查看指定用户（默认，当前用户）所属组。
	Ⅰ	修改权限
		使用 chmod 命令修改文件或目录的权限。首先，选择要更改的权限集，然后选择要更改的位（如，添加组【g】和其他【o】读【r】权限：
			chmod g+r file
			chmod o+r file
		一次性完成如下：
			chmod go+r file
		还可以使用数字更改权限，如：
			chmod 644 file
		这称为绝对更改（它一次设置所有权限位）。
		目录也有权限。如果目录是可读的，则可以列出该目录的内容，但只有在该目录可执行的情况下，才能访问该目录中的文件。在大多数情况下，两者都需要。
		可以使用 umask 命令指定一组默认权限。
	Ⅱ	符号连接
		符号链接是指向另一个文件或目录的文件，有效的创建别名。符号链接提供对模糊目录路径的快速访问。要创建从 target 到 linkname 的符号链接，使用 ln -s 命令，如：
			ln -s target linknaame
		linkname 参数是符号链接名称，target 参数是链接指向的文件或目录的路径，-s 标志指定符号链接。
		创建符号链接时不要忘记 -s 选项。 如果没有它，ln 会创建一个硬链接，为单个文件提供额外的真实文件名。 新文件名具有旧文件名的状态； 它直接指向（链接）到文件数据，而不是像符号链接那样指向另一个文件名。
18、打包和压缩文件
	gzip 和 tar 命令用于压缩和打包文件和目录。
	Ⅰ	gzip
		gzip（GNU Zip）程序是当前标准Unix压缩程序之一。以 .gz 结尾的文件是一个GNU Zip 压缩文件。使用gunzip file.gz解压缩 file.gz 并移除后缀；要再次压缩文件，使用 gzip file
	Ⅱ	tar
		gzip 不会创建文件归档；而是打包多个文件和目录到单一文件。使用 tar 创建归档：
			tar cvf archive.tar file1 file2 ...
		由 tar 创建的归档通常有一个 .tar 后缀。必须使用 -f 后跟文件名（磁带驱动器除外）。要使用标准输入或输出，将文件名设置为 - 。
		》解包 .tar 文件
			使用带有 -x 选项的tar 解包 .tar 文件，如：
				tar xvf archive.tar
			可以通过在命令行末尾输入指定文件名来提取归档中的该部分。
		》注意：
			使用提取模式【x】时，tar在提取其内容后不会删除归档的 .tar 文件。
		》使用目录【table-of-contents】模式
			在解压之前，最好使用 t 检查归档的内容。此模式验证归档的基本完整性。如果在解压之前不对其进行测试，则最终可能会将大量混乱的文件转储到当前目录中，这确实很难清理。
			当使用 t 模式检查归档时，验证所有内容都位于合理的目录结构中；也就是说，归档中的所有文件路径名都应以同一目录开头。如果不确定，应创建一个临时目录，切换到该目录，在进行解压。
			解压时，考虑使用 p 选项来保留权限。在提取模式下，使用它来覆盖 umask并获取归档中指定的确切权限。当以超级用户工作时，p选项是默认的。
			如果在以超级用户解压归档时遇到权限和所有权问题，确保等待命令终止并返回shell提示符。虽然可能只想提取归档的一部分，但tar必须贯穿整个过程。并且不能中断该过程，因为它仅在检查整个归档后才设置权限。
	Ⅲ	压缩归档（.tar.gz）
		归档通常是压缩的，文件名以 .tar.gz 结尾。要解压归档，首先处理 .gz ，然后再处理 .tar 。如：
			gunzip file.tar.gz
			tar xvf file.tar
		要创建压缩归档，执行相反的过程【先运行 tar ，再运行 gzip】。
	Ⅳ	zcat
		上面的方法并不是在压缩归档上使用tar的最快或最有效的方法，并且它浪费了磁盘空间和内核I/O时间。更好的方法是将归档和压缩功能与管道结合起来，如：
			zcat file.tar.gz | tar xvf -
		zcat 命令与gunzip -dc 相同。-d 解压缩，-c 将结果发送到标准输出。
		由于zcat的使用非常普遍，Linux自带的tar版本有一个快捷方式。可以使用 -z 选项自动在归档上调用gzip；这既适用于提取归档【x或t模式】，也适用于创建归档【c】。如：
			tar ztvf file.tar.gz
		.tgz 文件与 .tar.gz 文件相同。 该后缀旨在适合 FAT（基于 MS-DOS）文件系统。
	Ⅴ	其他压缩工具
		另外两个压缩程序是 xz 和 bzip2 ，其压缩文件分别以 .xz 和 .bz2 结尾。虽然比 gzip 稍微慢一些，但这些文本文件通常会更紧凑一些。 使用的解压缩程序是 unxz 和 bunzip2。
		大多数 Linux 发行版都附带与 Windows 系统上的 ZIP 存档兼容的 zip 和 unzip 程序。 它们适用于常见的 .zip 文件以及以 .exe 结尾的自解压存档。 
		但如果遇到一个以 .Z 结尾的文件，就发现了一个由压缩程序创建的遗迹，它曾经是 Unix 标准。gunzip 程序可以解压这些文件，但 gzip 不会创建它们。
19、Linux 目录层级结构要点
	文件系统层次结构标准（FHS）【https://refspecs.linuxfoundation.org/fhs.shtml】中概述了 Linux 目录结构的详细信息。
	根目录【/】中最重要的子目录：
		①	/bin	包含可立即运行的程序（也称为可执行文件），包括大多数基本 Unix 命令，例如 ls 和 cp。 /bin 中的大多数程序都是二进制格式，由 C 编译器创建，但有些是现代系统中的 shell 脚本。
		②	/dev	包含设备文件。
		③	/etc	该核心系统配置目录包含用户密码、启动、设备、网络和其他设置文件。
		④	/home	保存普通用户的主（个人）目录。
		⑤	/lib	library的简写，该目录包含可执行文件可以使用的代码的库文件。有两种类型的库：静态库和共享库。/lib 目录应仅包含共享库，但其他 lib 目录（如/usr/lib）包含这两种类型以及其他辅助文件。
		⑥	/proc	通过可浏览的目录和文件提供系统统计信息。Linux上的许多/proc子目录结构都是独特的，但许多其他Linux变体也具有类似的功能。/proc目录包含有关当前正在运行的进程的信息以及一些内核参数。
		⑦	/run	包含特定于系统的运行时数据，包括某些进程ID、套接字文件、状态记录，以及在许多情况下的系统日志记录。在较新的系统上，/var/run 是 /run 的符号链接。
		⑧	/sys	该目录与 /proc 类似，它提供设备和系统接口。
		⑨	/sbin	系统可执行文件的目录。/sbin 目录中的程序与系统管理有关，普通用户的命令路径中通常没有/sbin组件。如果不以root身份运行，这里找到的许多实用程序将无法工作。
		⑩	/tmp	用于存放不太关心的较小临时文件存储区域。任何用户都可以读取和写入 /tmp ，但该用户可能无权访问其他用户的文件。许多程序使用该目录作为工作空间。
					如果某些东西非常重要，请不要将其放在 /tmp 中，因为大多数发行版都会在计算机启动时清除 /tmp，有些发行版甚至会定期删除其旧文件。 
					另外，不要让 /tmp 充满垃圾，因为它的空间通常与关键的东西共享（例如 / 的其余部分）。
		⑩ ①	/usr	该子目录没有用户文件。相反，它包含一个大的目录层次结构，包括Linux系统的大部分内容。/usr中的许多目录名称与根目录【/】中的目录名称相同（如/usr/bin 和/usr/lib），并且它们保存相同类型的文件。
					（根目录不包含完整系统的原因主要是历史原因——在过去，这是为了保持根目录的空间要求较低）
		⑩ ②	/var	可变子目录，程序在其中记录可能随时间变化的信息。系统日志、用户跟踪、缓存以及系统程序创建和管理的其他文件都在这里。（这里有一个/var/tmp目录，系统不会在启动时擦除它）
	Ⅰ	其他根子目录
		①	/boot	包含内核引导加载程序文件。这些文件仅涉及Linux启动过程的第一阶段，不会在此目录中找到有关Linux如何启动其服务的信息。
		②	/media	可移动媒体（如闪存驱动器）的基本连接点
		③	/opt	这里可能包含其他第三方软件。
	Ⅱ	/usr 目录
		/usr 是大多数用户空间程序和数据所在的为止。除了 /usr/bin 、/usr/sbin 和 /usr/lib 之外，/usr 还包含以下内容：
			①	/include	保存 C 编译器使用的头文件
			②	/local		管理员可以在其中安装自己的软件。它的结构类似于/ 和 /usr
			③	/man		包含手册页
			④	/share		包含应该在其他类型的 Unix 机器上运行而不会丢失功能的文件。 这些通常是程序和库根据需要读取的辅助数据文件。 
							过去，计算机网络会从文件服务器共享此目录，但如今以这种方式使用的共享目录很少见，因为当代系统上的此类文件没有实际的空间限制。 
							相反，在 Linux 发行版上，会在这里找到 /man、/info 和许多其他子目录，因为这是一个易于理解的约定。
	Ⅲ	内核路径
		在Linux系统上，内核通常是二进制文件 /vmlinuz 或 /boot/vmlinuz 。引导加载程序将此文件加载到内存中，并在系统引导时将其设置为运动（motion）。
		一旦引导加载程序启动内核，主内核文件就不再被运行的系统使用。但是，内核在正常系统操作过程按需加载和卸载许多模块。称为可加载内核模块，它们位于/lib/modules 。
20、以超级用户运行命令
	可能想启动 root shell，但这样做有很多缺点：
		①	没有系统更改命令的记录
		②	没有执行系统更改命令的用户的记录
		③	无权访问正常的shell 环境
		④	不得不输入 root 密码
	Ⅰ	sudo
		大多数发行版使用名为 sudo 的包来允许管理员在以自己的身份登录时以 root 身份运行命令。如使用 vipw 编辑 /etc/passwd 文件：
			sudo vipw
		当运行此命令时，sudo 会使用local2设施下的syslog服务记录此操作。
	Ⅱ	/etc/sudoers
		通过 /etc/sudoers 文件配置特权用户。sudo 包有很多选项，这使得 /etc/sudoers 中的语法有些复杂。如：
			User_Alias ADMINS = user1, user2	# 定义用户别名
			ADMINS ALL = NOPASSWD: ALL			# 授权（ADMINS 可以使用sudo 以root执行命令）第一个 ALL 意味着any host；第二个 ALL 意味着 any command。
			root ALL=(ALL) ALL					# 授权 超级用户可以使用sudo在任何主机上运行任何命令。（ALL）意味着超级用户能以任何其他用户运行命令。
		》注意：
			使用 visudo 命令编辑 /etc/sudoers。该命令会在保存文件后检查文件语法错误。
	Ⅲ	sudo 日志	
		可以使用以下命令在大多数系统上找到 sudo 日志：
			journalctl SYSLOG_IDENTIFIER=sudo
		在旧系统上，将需要在/var/log中查找日志文件，如/var/log/auth.log 。
	Ⅳ	扩展
			man 5 sudoers
			man 8 sudo


Devices
1、设备文件
	在Unix系统上，操作大多数设备都很容易，内核将许多设备I/O接口作为文件呈现给用户进程。这些设备文件有时称为设备节点。除了使用常规文件来处理设备之外，某些设备也可通过标准程序（如cat）访问。
	但使用文件接口可以执行的操作是有限的，因此并非所有设备或设备功能都可以通过标准文件I/O访问。
	Linux使用与其他Unix风格相同的设备文件设计。设备文件位于 /dev 目录中。常用设备如下：
		①	Block device【b】
			程序以固定块的形式从块设备访问数据。磁盘可以轻松分割成数据块。由于块设备的总大小是固定的并且易于索引，因此进程可以在内核的帮助下快速随机访问设备中的任何块。
		②	Character device【c】
			字符设备使用数据流。只能从字符设备读取字符或向字符设备写入字符。字符设备没有大小；当读取或写入其中一个时，内核通常会对其执行读取或写入操作。
			注意，在字符设备交互期间，内核在将数据传递到设备或进程后无法备份和重新检查数据流。
		③	Pipe device【p】
			命名管道【named pipes】类似于字符设备，I/O流的另一端是其他进程，而不是内核驱动。
		④	Socket device【s】
			套接字是经常用于进程间通信的特殊用途接口。它们通常位于 /dev 目录之外。套接字文件代表 Unix 域套接字【domain sockets】。
	在块设备和字符设备的 ls -l 列表中，日期之前的数字是内核用来标识设备的主设备号和次设备号。类似的设备通常具有相同的主设备号（如 sda3 和 sdb1）【两者都是硬盘分区】。
	》注意：
		并非所有设备都有设备文件，因为块设备和字符设备I/O接口并不适合所有情况。如，网络接口没有设备文件。理论上可以使用单个字符设备与网络接口进行交互，但由于很困难，内核提供了其他I/O接口。
2、sysfs 设备路径
	传统的Unix /dev 目录是用户进程引用和与内核支持的设备交互的便捷方式，但它也是一个非常简单的方案。/dev中的设备名称会告知有关该设备的信息，但通常不足以提供帮助。
	另一个问题是内核按照设备被发现的顺序分配设备，因此设备在重新启动之间可能有不同的名称。
	为了根据附加设备的实际硬件属性提供统一的视图，Linux内核通过文件和目录系统提供 sysfs 接口。设备的基本路径是 /sys/devices（如，位于/dev/sda 的SATA硬盘在sysfs中可能具有以下路径)：
		/sys/devices/pci0000:00/0000:00:17.0/ata3/host0/target0:0:0/0:0:0:0/block/sda
	与 /dev/sda 相比，该路径相当长。但无法真正比较这两条路径，因为它们有不同的目的。 /dev 允许用户进程使用设备，而 /sys/devices 路径用于查看信息和管理设备。
	该目录的文件和子目录主要由程序而不是用户读取，可通过查看 /dev 文件等来了解它们包含和代表的内容。
	/sys 目录中有一些快捷方式。如 /sys/block 应包含系统上可用的所有块设备。这些这是符号链接；可以运行 ls -l /sys/block 来显示真正的 sysfs 路径。
	在 /dev 中找到设备的sysfs位置可能很困难。使用 udevadm 命令显示路径和其他几个有趣的属性，如：
		# udevadm info --query=all --name=/dev/sda
		P: /devices/pci0000:00/0000:00:10.0/host2/target2:0:0/2:0:0:0/block/sda
		M: sda
		U: block
		T: disk
		D: b 8:0
		N: sda
		L: 0
		S: disk/by-diskseq/1
		S: disk/by-path/pci-0000:00:10.0-scsi-0:0:0:0
		Q: 1
		E: DEVPATH=/devices/pci0000:00/0000:00:10.0/host2/target2:0:0/2:0:0:0/block/sda
		E: DEVNAME=/dev/sda
		E: DEVTYPE=disk
		E: DISKSEQ=1
		E: MAJOR=8
		E: MINOR=0
		E: SUBSYSTEM=block
		E: USEC_INITIALIZED=13029062
		E: ID_SCSI=1
		E: ID_VENDOR=VMware_
		E: ID_VENDOR_ENC=VMware\x2c\x20
		E: ID_MODEL=VMware_Virtual_S
		E: ID_MODEL_ENC=VMware\x20Virtual\x20S
		E: ID_REVISION=1.0
		E: ID_TYPE=disk
		E: ID_BUS=scsi
		E: ID_PATH=pci-0000:00:10.0-scsi-0:0:0:0
		E: ID_PATH_TAG=pci-0000_00_10_0-scsi-0_0_0_0
		E: ID_PART_TABLE_UUID=4023d1bc
		E: ID_PART_TABLE_TYPE=dos
		E: DEVLINKS=/dev/disk/by-diskseq/1 /dev/disk/by-path/pci-0000:00:10.0-scsi-0:0:0:0
		E: TAGS=:systemd:
		E: CURRENT_TAGS=:systemd:
3、dd 和设备
	当使用块设备和字符设备时，程序 dd 非常有用。它的唯一功能是从输入文件或流中读取并写入输出文件或流，可能会在途中进行一些编码转换。对于块设备来说，一个特别有用的dd功能是，可以在文件中间处理一大块数据，而忽略之前或之后的数据。
	》警告：
		dd 非常强大，因此确保运行它时知道在做什么。如果不小心犯了错误，很容易损坏设备上的文件和数据。如果不确定输出会做什么，将输出写入新文件通常会有所帮助。
	dd 以固定大小的块复制数据。如：
		dd if=/dev/zero of=new_file bs=1024 count=1
	dd 选项格式与大多数其他 Unix 命令的选项格式不同；它基于旧的 IBM 作业控制语言 (JCL) 风格。 您可以命名一个选项并使用等号 (=) 设置其值，而不是使用破折号 (-) 字符来表示选项。
	dd 的重要选项如下
		①	if=file				输入文件。默认是标准输入。
		②	of=file				输出文件。默认是标准输出。
		③	bs=size				块大小。dd 一次读取和写入这么多字节的数据。要缩写大数据块，可以使用b 和 k分别表示512和1024字节。如 bs=1k等同于bs=1024 。
		④	ibs=size，obs=size	输入和输出块大小。如果为输入和输出使用相同的块大小，使用 bs 选项。如果不是，分别为输入和输出使用 ibs 和 obs 。
		⑤	count=num			要复制的总块数。当使用大文件时，或者使用提供无限数据流的设备（如/dev/zero）时，希望dd在某个固定点停止；否则，可能会浪费大量磁盘空间和/或CPU时间。
								将 count 和 skip 参数结合使用可以从大文件或设备中复制一小部分。
		⑥	skip=num			跳过输入文件或流中的前num个块，并且不将它们复制到输出。
4、设备名称摘要
	有时很难找到设备的名称（如，对磁盘进行分区时）。以下是一些了解它是什么的方法：
		①	使用 udevadm 查询 udevd
		②	在 /sys 目录中查找设备
		③	从 journalctl -k 命令的输出（打印内核消息）或内核系统日志中猜测名称。此输出可能包含系统上的设备的说明。
		④	对于系统已经可见的磁盘设备，可以检查 mount 命令的输出
		⑤	运行 cat /proc/devices 查看系统当前具有驱动程序的块设备和字符设备。每行由一个数字和名称组成。该编号是设备的主编号。
			如果可以从名称猜出设备，在/dev中查找【ls -l /dev】具有相应主设备号的字符或块设备，然后就可以找到了设备文件。
	这些方法中，只有第一种是可靠的，但它确实需要 udev 。如果遇到 udev 不可用的情况，尝试其他方法。注意，内核可能没有适合当前硬件的设备文件。
	Ⅰ	Hard Disks：/dev/sd*
		当前Linux系统挂载的大多数硬盘都对应带有 sd 前缀的设备名称（如，/dev/sda、/dev/sdb 等）。这些设备代表整个磁盘；内核为磁盘上的分区创建单独的设备文件（如，/dev/sda1 和 /dev/sdb2）。
		命名约定需要一些解释。 名称的 sd 部分代表 SCSI 磁盘。 小型计算机系统接口 (SCSI Small Computer System Interface) 最初是作为磁盘和其他外围设备等设备之间通信的硬件和协议标准而开发的。 
		尽管大多数现代机器中并未使用传统的 SCSI 硬件，但 SCSI 协议由于其适应性而无处不在。 例如，USB存储设备就使用它来进行通信。 
		SATA（串行 ATA，PC 上的一种常见存储总线）磁盘的情况稍微复杂一些，但 Linux 内核在与它们通信时在某个时刻仍然使用 SCSI 命令。
		要列出系统上的SCSI设备，使用一个实用程序来遍历 sysfs 提供的设备路径（最简单的工具之一是 lsscsi），如：
			# lsscsi 
			[0:0:0:0]    cd/dvd  NECVMWar VMware IDE CDR00 1.00  /dev/sr0 
			[1:0:0:0]    cd/dvd  NECVMWar VMware IDE CDR10 1.00  /dev/sr1 
			[2:0:0:0]    disk    VMware,  VMware Virtual S 1.0   /dev/sda 
			[2:0:1:0]    disk    VMware,  VMware Virtual S 1.0   /dev/sdb
		其中，第一列标识设备在系统上的位置；第二列描述设备类型；最后一列指示在那里找到设备文件。其他则是供应商信息。
		注意，这种设备分配方案传统上会引起问题。当移除某个磁盘后，设备名发送改变。为了解决这个问题，许多Linux系统实用通用唯一标识符（UUID）和/或逻辑卷管理器（LVM）稳定磁盘设备映射。
	Ⅱ	Virtual Disks：/dev/xvd*，/dev/vd*
		某些磁盘设备针对虚拟机（例如 AWS 实例和 VirtualBox）进行了优化。 Xen虚拟化系统使用/dev/xvd前缀，/dev/vd是类似的类型。
	Ⅲ	Non-Volatile Memory Devices：/dev/nvme*
		一些系统现在使用非易失性内存 Express（NVMe）接口与某些类型的固态存储进行通信。在Linux中，这些设备显示在 /dev/nvme* 中。可以使用 nvme list 命令获取系统上这些设备的列表。
	Ⅳ	Device Mapper：/dev/dm-*，/dev/mapper/*
		在某些系统上，LVM 比磁盘和其他直接块存储更上一层楼，它使用称为设备映射器的内核系统。 如果看到以 /dev/dm- 开头的块设备以及 /dev/mapper 中的符号链接，则系统可能使用它。
	Ⅴ	CD and DVD Drives：/dev/sr*
		Linux将大多数光存储驱动器识别为SCSI设备【/dev/sr0、/dev/sr1等】。但，如果驱动器使用较旧的接口，它可能会显示为 PATA 设备。
		/dev/sr* 设备是只读的，它们仅用于从光盘读取。对于光学设备的写入和重写功能，将使用“通用”SCSI设备，如/dev/sg0。
	Ⅵ	PATA Hard Disks：/dev/hd*
		PATA（串行 ATA）是一个较旧类型的存储总线。Linux 块设备 /dev/hda、/dev/hdb、/dev/hdc 和 /dev/hdd 在较旧版本的 Linux 内核和较旧的硬件上很常见。 
		这些是基于接口 0 和 1 上的设备对的固定分配。有时，可能会发现 SATA 驱动器被识别为这些磁盘之一。 这意味着 SATA 驱动器正在兼容模式下运行，这会影响性能。 检查 BIOS 设置，看看是否可以将 SATA 控制器切换到其本机模式。
	Ⅶ	Terminals：/dev/tty*, /dev/pts/*, and /dev/tty
		终端是用于在用户进程和I/O设备之间移动字符的设备，通常用于将文本输出到终端屏幕。
		大多数终端都是伪终端设备，即了解真实终端 I/O 功能的模拟终端。内核不是与真实的硬件对话，而是向软件提供 I/O 接口，如可能在其中输入大部分命令的shell终端窗口。
		两个常见的终端设备是 /dev/tty1（第一个虚拟控制台）和 dev/pts/0（第一个伪终端设备）。/dev/pst 目录本身是一个专用文件系统。
		/dev/tty 设备是当前进程的控制终端。如果程序当前正在读取和写入终端，则该设备是该终端的同义词。进程不需要附加到终端。
		》显示模式和虚拟控制台
			Linux由两个主要的显示模式：文本模式和图形模式。尽管 Linux 系统传统上以文本模式启动，但现在大多数发行版都使用内核参数和临时图形显示机制（启动画面，例如 plymouth）在系统启动时完全隐藏文本模式。 
			在这种情况下，系统会在启动过程接近结束时切换到全图形模式。
			Linux支持虚拟控制台来复用显示。每个虚拟控制台可以以图形或文本模式运行。在文本模式下，可以使用Alt功能键组合在控制台之间切换，如Alt-F1将转到/dev/tty1，Alt-F2将转到/dev/tty2，依此类推。
			许多虚拟控制台可能被运行登录提示的getty进程占用。
			图形模式下使用的虚拟控制台略有不同。图形环境不是从初始化配置中获取虚拟控制台分配，而是接管一个免费的虚拟控制台，除非指示使用特定的虚拟控制台。如，如果有getty进程在tty1和tty2上运行，则新的图形环境将接管tty3.
			此外，进入图形模式后，通常必须按Ctrl-Alt功能键组合才能切换到另一个虚拟控制台。
			总之，如果想在系统启动后查看文本控制台，按Ctrl-Alt-F1。要返回到图形环境，按Alt-F2、Alt-F3等，直到进入图形环境。
		如果由于输入机制故障或其他情况而导致切换控制台时遇到问题，可以尝试使用 chvt 命令强制系统更改控制台。如要切换到tty1，以root身份运行以下命令：
			chvt 1
	Ⅷ	Serial Ports：/dev/ttyS*，/dev/ttyUSB*，/dev/ttyACM*
		较旧的 RS-232 类型和类似的串行端口被表示为真正的终端设备。 您无法在命令行上对串行端口设备执行太多操作，因为有太多设置需要担心，例如波特率和流量控制，
		可以使用 screen 命令通过添加设备路径来连接到终端。 可能需要设备的读写权限； 有时，可以通过将自己添加到特定组（例如 dialout）来做到这一点。
		在Windows上熟知的COM1是/dev/ttyS0；COM2是/dev/ttyS1；依此类推。插入式 USB 串行适配器与 USB 和 ACM 一起显示，名称为 /dev/ttyUSB0、/dev/ttyACM0、/dev/ttyUSB1、/dev/ttyACM1 等。
	Ⅸ	Parallel Ports：/dev/lp0 and /dev/lp1
		单向并行端口设备 /dev/lp0 和 /dev/lp1 代表一种已被 USB 和网络取代的接口类型，对应于 Windows 中的 LPT1: 和 LPT2:。 您可以使用 cat 命令将文件（例如要打印的文件）直接发送到并行端口，
		但可能需要为打印机提供额外的换页或随后重置。 CUPS 等打印服务器更擅长处理与打印机的交互。
		双向并行端口是 /dev/parport0 和 /dev/parport1。
	Ⅹ	Audio Devices：/dev/snd*，/dev/dsp，/dev/audio， and more
		Linux 有两套音频设备。 高级 Linux 声音架构 (ALSA) 系统接口和较旧的开放声音系统 (OSS) 有单独的设备。 ALSA 设备位于 /dev/snd目录，但直接使用它们很困难。 
		如果当前加载了 OSS 内核支持，则使用 ALSA 的 Linux 系统支持 OSS 向后兼容的设备。
		使用 OSS dsp 和音频设备可以进行一些基本操作。 例如，计算机会播放您发送到 /dev/dsp 的任何 WAV 文件。 然而，由于频率不匹配，硬件可能无法达到您的预期。 此外，在大多数系统上，您一登录设备通常就处于繁忙状态。
	ⅩⅠ	Device File Creation
		在任何最近的 Linux 系统上，都不会创建自己的设备文件； 它们是由 devtmpfs 和 udev 创建的。但是，了解如何执行此操作很有启发性，并且在极少数情况下，可能需要创建命名管道或套接字文件。
		mknod 命令用于创建设备。必须知道设备名称及其主要编号和次要编号，如：
			mknod /dev/sda1 b 8 1
		b 8 1 指定主设备号为8，次设备号为1的块设备。对于字符或命名管道设备，使用c 或 p代替b（对于命名管道，省略主设备号和次设备号）。
		在旧版本的 Unix 和 Linux 中，维护 /dev 目录是一个挑战。随着每次重大的内核升级或驱动程序添加，内核可以支持更多类型的设备，这意味着将有一组新的主要和次要编号分配给设备文件名。 
		为了应对这一维护挑战，每个系统在 /dev 中都有一个 MAKEDEV 程序来创建设备组。当升级系统时，会尝试查找 MAKEDEV 的更新，然后运行它以创建新设备。
		这个静态系统变得笨拙，因此需要更换。 修复此问题的第一个尝试是 devfs，它是 /dev 的内核空间实现，包含当前内核支持的所有设备。 然而，存在一些限制，这导致了 udev 和 devtmpfs 的发展。
5、udev
	内核中不必要的复杂性是非常危险的，因为很容易引入系统不稳定。设备文件管理就是这样一个例子（可以在用户空间中创建设备文件，就没必要在内核中执行此操作了）。
	Linux内核可以在检测到系统上的新设备时（如连接USB闪存驱动器时）向名为 udevd 的用户空间进程发送通知。这个 udevd 进程可以检查新设备的特性，创建设备文件，然后执行任何设备初始化。
	》udevd 作为 systemd-udevd 在系统上运行。
	这种方法有一个问题——设备文件在引导过程的早期是必需的，因此 udevd 也必须尽早启动。但要创建设备文件， udevd 不能依赖于它应该创建的任何设备，并且它需要非常快速地执行其初始启动，以便系统在其余部分不会等待 udevd 启动。
	Ⅰ	devtmpfs
		devtmpfs 文件系统是为了解决启动期间设备可用性问题而开发的。该文件系统类似于旧的devfs支持，但进行了简化。内核根据需要创建设备文件，但它也会通知udevd有新设备可用。
		收到此信号后，udevd不会创建设备文件，但它会执行设备初始化以及设置权限并通知其他进程有新设备可用。
		此外，它还在 /dev 中创建许多符号链接以进一步识别设备。可以在 /dev/disk/by-id 目录中找到示例，其中每个连接的磁盘都有一个或多个条目。
		udevd 进程按接口类型、制造商和型号信息、序列号和分区命名链接。
		》注意：devtmpfs 中的 tmp 表示文件系统驻留在主内存中，具有读取功能。
	Ⅱ	udevd 操作和配置
	Ⅲ	udevadm
	Ⅳ	设备监控
6、深入：SCSI 和 Linux 内核


Disks And Filesystems
	分区是整个磁盘的细分。在Linux上，它们在整个块设备后面用数字表示，因此它们的名称类似于 /dev/sda1 和 /dev/sdb3。内核将每个分区呈现为块设备，就像整个磁盘一样。分区是在磁盘上称为分区表（也称为磁盘标签）的小区域上定义的。
	》注意：
		多个数据分区曾经在具有大磁盘的系统上很常见，因为旧电脑只能从磁盘的某些部分启动。 另外，管理员使用分区为操作系统区域保留一定的空间； 例如，他们不希望用户填满整个系统并阻止关键服务运行。 这种做法并不是 Unix 所独有的。 
		仍然会发现许多新的 Windows 系统在单个磁盘上有多个分区。 此外，大多数系统都有一个单独的交换分区。
	内核使得可以同时访问整个磁盘及其分区，但除非复制整个磁盘，否则通常不会这样做。Linux 逻辑卷（Logical Volume Manager LVM）为传统磁盘设备和分区增加了更多灵活性。
	分区的下一层是文件系统，即习惯在用户空间中与之交互的文件和目录的数据库。
	如果要访问文件中的数据，则需要使用分区表中适当的分区位置，然后在该分区上的文件系统数据库中搜索所需的文件数据。
1、磁盘设备分区
	分区表有很多种。分区表没有什么特别的，它只是一堆数据，说明磁盘上的块是如何划分的。
	传统的表可以追溯到PC时代，是在主引导记录（MBR：Master Boot Record）中找到的表，它有很多限制。大多数较新的系统使用全局唯一标识符分区表（GPT：Globally Unique Identifier Partition Table）。
	常见Linux分区工具如下：
		parted（“partition editor”）	一种基于文本的工具，支持 MBR 和 GPT 。
		gparted							parted 的图形版本
		fdisk							传统的基于文本的Linux磁盘分区工具。最新版本的 fdisk 支持 MBR 、GPT 和许多其他类型的分区表，但旧版本仅限于 MBR 支持。
	因为已经支持 MBR 和 GPT 一段时间了，并且很容易运行单个命令来获取分区标签，将使用 parted 来显示分区表。但，在创建和更改分区表时，将使用 fdisk 。
	分区和文件系统操作之间存在一个关键区别：分区表定义了磁盘上的简单边界，而文件系统是一个复杂得多得数据系统。将使用单独得工具来分区和创建文件系统。
	Ⅰ	查看分区表
		可以使用 parted -l 查看系统得分区表。
		读取分区表时注意单元大小。parted 输出显示基于 parted 认为最容易阅读的内容的近似大小。fdisk -l 显示准确的数字，但在大多数情况下，单位是512字节“扇区”。
		》MBR 基础
			主分区是磁盘的正常细分。基本 MBR 的主分区数量上限为4个，如果想要超过4个，则必须指定一个作为扩展分区。扩展分区划分为逻辑分区，操作系统可以像使用其他分区一样使用逻辑分区。
		》注意：
			parted 列出的文件系统类型不一定与其MBR条目中的系统ID字段相同。MBR系统ID只是一个标识分区类型的数字（如，83是Linux分区，82是Linux交换分区）。parted试图通过自行确定该分区上的文件系统类型来提供更多信息。
			如果需要准确知道MBR的系统ID，使用 fdisk -l 。
		》LVM 分区：
			查看分区表时，如果看到标记为LVM的分区（代码8e作为分区类型）、名为/dev/dm-* 的设备或对“设备映射器【device mapper】”的引用，则系统使用LVM。如：
			# parted -l
			型号：VMware, VMware Virtual S (scsi)
			磁盘 /dev/sda：10.7GB
			扇区大小 (逻辑/物理)：512B/512B
			分区表：msdos
			磁盘标志：
			
			编号  起始点  结束点  大小    类型     文件系统  标志
			 1    1049kB  1075MB  1074MB  primary  xfs       启动
			 2    1075MB  10.7GB  9663MB  primary            lvm
			有一些设备看起来应该是分区，但被称为磁盘。使用 fdisk -l 会得到不太详细的输出。
	Ⅱ	修改分区表
		查看分区表是一个相对简单且无害的操作。 更改分区表也相对容易，但对磁盘进行这种更改会带来风险。 请记住以下几点：
			①	更改分区表使得恢复删除或重新定义的分区上的任何数据变得困难，因为这样做可能会擦除这些分区上文件系统的位置。如果要分区的磁盘包含关键数据，确保有备份。
			②	确保目标磁盘上当前没有任何分区正在使用。这是一个问题（大多数Linux发行版都会自动挂载任何检测到的文件系统）。
		fdisk 和 parted 的工作方式存在重大差异。使用 fdisk ，可以在对磁盘进行实际更改之前设计新的分区表，并且仅在退出程序时它才会进行更改。
		使用 parted ，分区会在发出命令时创建、修改和删除。在更改分区表之前没有机会检查它。
		fdisk 和 parted 都完全在用户空间修改分区；不需要为重写分区表提供内核支持（用户空间可以读取和修改所有块设备）。但在某些时候，内核必须读取分区表才能将分区呈现为块设备，以便可以使用它们。
		fdisk 使用相对简单的方法。修改分区表后，fdisk发出一个系统调用来告诉内核它应该重新读取磁盘的分区表。然后内核会生成调试输出，可以使用 journalctl -k 查看该输出。
		parted 不使用这种磁盘范围的系统调用；相反，当各个分区发生更改时，它们会向内核发出信号。
		有一些方法可以查看分区变化：
			①	使用 udevadm 查看内核事件变化【udevadm monitor --kernel 将显示已删除的旧分区设备和已添加的新分区设备】
			②	查看 /proc/partition（包含完整分区信息）
			③	查看 /sys/block/device/（更改的分区系统接口）或/dev（更改的分区设备）
	Ⅲ	创建分区表
		使用 fdisk 来创建分区表。这是一个交互式命令，在确保磁盘上没有安装任何内容后，在命令提示符下使用设备名称启动，如：
			fdisk /dev/sdd
		其中，使用 p 子命令打印当前分区表；使用 d 子命令删除已存在的分区（在显式写入分区表表之前，fdisk 不会进行更改）。可以使用 q 命令退出 fdisk，而不写入更改。
		使用 n 命令创建新分区；使用 w 写入修改后的分区表。fdisk 不会询问是否确定，只是完成其工作并退出。
		如果对其他诊断消息感兴趣，使用 journalctl -k 查看内核读取消息。
2、文件系统
	磁盘的内核和用户空间之间的最后一个链接通常是文件系统；文件系统是数据库的一种形式；提供了将简单的块设备转换为用户可以理解的复杂的文件和子目录层次结构的结构。
	曾经，所有文件系统都驻留在专门用于数据存储的磁盘和其他物理介质上。文件系统的树形目录结构和I/O接口非常通用，因此文件系统现在执行各种任务，如在/sys 和 /proc 中看到的系统接口。
	文件系统传统上是在内核中实现的，但是Plan 9 中 9P 的创新（https://en.wikipedia.org/wiki/9P_(protocol)）启发了用户空间文件系统的开发。 用户空间文件系统 (FUSE) 功能允许在 Linux 中使用用户空间文件系统。
	虚拟文件系统（VFS）抽象层完成了文件系统的实现。就像SCSI子系统标准化不同设备类型和内核控制命令之间的通信一样，VFS确保所有文件系统实现都支持标准接口，以便用户空间用用程序以相同的方式访问文件和目录。
	VFS支持使Linux能支持数量异常庞大的文件系统。
	Ⅰ	文件系统类型
		Linux 文件系统支持包括针对 Linux 优化的本机设计； 外来类型，例如 Windows FAT 系列； 通用文件系统，如 ISO 9660； 以及许多其他类型。 
		以下列表包括用于数据存储的最常见的文件系统类型。 Linux 识别的类型名称位于文件系统名称旁边的括号中。
		①	ext4	Linux原生文件系统系列的当前迭代。ext2 是Linux系统的长期默认设置，其灵感源自传统Unix文件系统（如，Unix文件系统【UFS】和快速文件系统【FFS】）。
					ext3添加了日志功能以增强数据完整性并加快启动速度。ext4 是一项增量改进，支持比ext2和ext3更大的文件以及更多数量的子目录。
					扩展文件系统系列具有一定程度的向后兼容性。 例如，您可以将 ext2 和 ext3 文件系统相互挂载，也可以将 ext2 和 ext3 文件系统挂载为 ext4，但不能将 ext4 挂载为 ext2 或 ext3。
		②	btrfs	B-tree 文件系统，Linux 原生的较新文件系统，旨在超越 ext4 的功能。
		③	FAT 文件系统（msdos、vfat、exfat）属于 Microsoft 系统。 简单的 msdos 类型支持 MS-DOS 系统中非常原始的单写形式。 
					大多数可移动闪存介质（例如 SD 卡和 USB 驱动器）默认包含 vfat（最多 4GB）或 exfat（4GB 及以上）分区。 Windows 系统可以使用基于 FAT 的文件系统或更高级的 NT 文件系统 (ntfs)
		④	XFS		某些发行版（例如 Red Hat Enterprise Linux 7.0 及更高版本）默认使用的高性能文件系统。
		⑤	hfsplus	大多数 Macintosh 系统上使用的 Apple 标准。
		⑥	iso9660	CD-ROM标准。大多数 CD-ROM 使用某种 ISO 9660 标准。
	Ⅱ	创建文件系统
		要先创建分区，才能创建文件系统。与分区一样，将在用户空间中执行此操作，因为用户空间进程可以直接访问和操作块设备。mkfs 工具可以创建多种类型文件系统。如：
			mkfs -t ext4 /dev/sdf2		# ext4 类型
		mkfs 自动确定设备中的块数并设置一些合理的默认值【除非您真的知道自己在做什么并且想要详细阅读文档，否则不要更改它们。】
		创建文件系统时，mkfs 会在工作时打印诊断输出，包括与超级块相关的输出。 超级块是文件系统数据库顶层的关键组件，它非常重要，mkfs 会创建大量备份，以防原始块被破坏。 
		考虑在 mkfs 运行时记录一些超级块备份编号，以便在磁盘发生故障时需要恢复超级块。
		文件系统创建是一项仅在添加新磁盘或对旧磁盘重新分区后才应执行的任务。应该为每个没有预先存在的数据（或包含要删除的数据）的新分区创建一次文件系统。在现有文件系统之上创建新的文件系统将有效地销毁旧数据。
		》mkfs
			mkfs 只是一系列文件系统创建程序 mkfs.fs 的前缀，其中 fs 是文件系统类型。当运行 mkfs -t ext4 时，mkfs 会运行 mkfs.ext4 。如：
				# ls -l /sbin/mkfs.*
				-rwxr-xr-x. 1 root root  36224  3月 29  2023 /sbin/mkfs.cramfs
				-rwxr-xr-x. 4 root root 136920  6月  8  2022 /sbin/mkfs.ext2
				-rwxr-xr-x. 4 root root 136920  6月  8  2022 /sbin/mkfs.ext3
				-rwxr-xr-x. 4 root root 136920  6月  8  2022 /sbin/mkfs.ext4
				-rwxr-xr-x. 1 root root  44600  3月 29  2023 /sbin/mkfs.minix
				-rwxr-xr-x. 1 root root 450152  8月  3 17:48 /sbin/mkfs.xfs
	Ⅲ	挂载文件系统
		在Unix上，将文件系统附加到正在运行的系统的过程称为挂载。系统启动时，内核会读取一些配置数据，并根据配置数据挂载root（/）。
		要挂载一个文件系统，必须知道以下内容：
			①	文件系统的设备、位置或标识符（如磁盘分区——实际文件系统数据所在的位置）。一些特殊用途的文件系统，如 proc 和 sysfs ，没有位置。
			②	文件系统类型
			③	挂载点——当前系统目录层次结构中将附加文件系统的位置。挂载点始终是普通目录。
		挂载文件系统的常用术语是“在挂载点上挂载设备”。 要了解系统当前的文件系统状态，请运行 mount。
			# mount 
			proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
			sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)
			devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=4096k,nr_inodes=112279,mode=755,inode64)
			securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
			tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel,inode64)
			devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,seclabel,gid=5,mode=620,ptmxmode=000)
			tmpfs on /run type tmpfs (rw,nosuid,nodev,seclabel,size=188124k,nr_inodes=819200,mode=755,inode64)
			cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,seclabel,nsdelegate,memory_recursiveprot)
		每一行对应一个当前挂载的文件系统，分别是：
			①	设备，如 /dev/sda1。注意，其中一些不是真正的设备（如proc），而是真实设备名称的替代品（这些特殊用途的文件系统不需要设备）
			②	on
			③	挂载点
			④	type
			⑤	文件系统类型，通常采用短标识符的形式
			⑥	挂载选项（在括号中）
		要手动挂载文件系统，使用 mount 命令，并指定文件系统类型、设备和所需的挂载点，如：
			mount -t type device mountpoint
		通常不需要提供 -t type 选项（mount通常会计算出来）。有时有必要区分两种相似的类型，如各种FAT类型的文件系统。
		要卸载（分离）文件系统，使用 umount 命令，如：
			umount mountpoint
		还可以使用其设备而不是其挂载点来卸载文件系统。
		》注意：
			几乎所有 Linux 系统都包含一个临时挂载点 /mnt，通常用于测试。 在尝试系统时可以随意使用它，但如果您打算挂载文件系统以供扩展使用，请找到或创建另一个位置。
	Ⅳ	文件系统 UUID
		设备名称可能会更改（取决于内核查找设备的顺序），为了解决这个问题，可以通过通用唯一标识符（UUID）来识别和挂载文件系统，UUID是用于识别计算机系统中对象的唯一“序列号”的行业标准。
		像 mke2fs 这样的文件系统创建程序在初始化文件系统数据结构时会生成 UUID。
		要查看系统上的设备列表以及相应的文件系统和UUID，使用  blkid （block ID）程序，如：
			# blkid 
			/dev/mapper/cs-swap: UUID="f6aeb2bc-cc00-4744-a6c1-2ac319394111" TYPE="swap"
			/dev/sdb1: UUID="4f0140af-c7e6-488b-a945-96633d81ca47" TYPE="xfs" PARTUUID="378151a6-01"
			/dev/sr0: UUID="2023-12-13-21-32-21-00" LABEL="CDROM" TYPE="iso9660"
			/dev/mapper/cs-root: UUID="223f9a2f-50c9-4514-b079-c587b9711290" TYPE="xfs"
			/dev/sda2: UUID="RxkQml-RRIM-YEtJ-Y5vr-S6Z7-GZyq-YMclHO" TYPE="LVM2_member" PARTUUID="4023d1bc-02"
			/dev/sda1: UUID="cefa5978-d61c-46ff-8c46-da07884133eb" TYPE="xfs" PARTUUID="4023d1bc-01"
			/dev/sr1: UUID="2023-08-14-03-57-29-00" LABEL="CentOS-Stream-9-BaseOS-x86_64" TYPE="iso9660" PTUUID="462370a1" PTTYPE="dos"
		要使用 UUID 挂载文件系统，使用 UUID 挂载选项。如：
			mount UUID=b600fe63-d2e9-461c-a5cd-d3b373a5e1d2 /home/extra
		通常，不会像这样通过 UUID 手动挂载文件系统，因为通常知道该设备，并且通过其名称挂载设备比通过其 UUID 挂载要容易得多。尽管如此，了解 UUID 仍然很重要。 
		一方面，它们是在启动时自动在 /etc/fstab 中挂载非 LVM 文件系统的首选方式。此外，许多发行版再插入可移动介质时使用 UUID 作为挂载点。
		如有必要，可以更改文件系统的UUID（如，如果从其他地方复制了完整的文件系统，现在需要将其与原始文件系统区分开来）。有关如何在 ext2/ext3/ext4文件系统上执行此操作，见 man 8 tune2fs
	Ⅴ	磁盘缓冲，缓存和文件系统
		Linux与其他Unix变体一样，缓冲对磁盘的写入。这意味着当进程请求更改时，内核通常不会立即将更改写入文件系统。相反，它将这些更改存储在RAM中，直到内核确定将它们实际写入磁盘的最佳时机。
		该缓冲系统对用户是透明的，并且提供了非常显著的性能增益。
		当使用 umount 卸载文件系统时，内核会自动与磁盘同步，将其缓冲区中的更改写入磁盘。还可以通过运行 sync 命令来强制内核随时执行此操作，默认该命令会同步系统上的所有磁盘。
		如果由于某种原因无法在关闭系统之前卸载文件系统，务必先运行 sync 。
		此外，当从磁盘读取块时，内核使用 RAM 来缓存块。 因此，如果一个或多个进程重复访问一个文件，内核不必一次又一次地访问磁盘，它只需从缓存中读取即可，从而节省时间和资源。
	Ⅵ	文件系统挂载选项
		有很多方法可以更改 mount 命令行为，在使用可移动介质或执行系统维护时，经常需要执行此操作。挂载选项见 man 8 mount 。
		选项大致分为两类：一般选项和特定于文件系统的选项。常规选项通常适用于所有文件系统类型，并包括用于指定文件系统类型的 -t 。相反，文件系统特定选项仅适用于某些文件系统类型。
		要激活文件系统系统选项，使用 -o 。如 -o remount,rw 以读写模式重新挂载以只读模式挂载的文件系统。
		①	Short general options
			常规选项的语法很短。最重要的是：
				-r	以只读模式挂载文件系统。当访问只读设备（如CD-ROM）时，不需要指定该选项；系统会帮助完成此操作。
				-n	确保 mount 不会尝试更新系统运行时挂载数据库 /etc/mtab 。默认，当无法写入该文件时，挂载操作会失败，该选项在引导时很重要，因为根分区（包括系统挂载数据库）最初是只读的。
					当尝试在单用户模式下修复系统时，还会发现该选项很方便，因为系统挂载数据库当时可能不可用。
				-t	指定文件系统类型
		②	Long options
			像 -r 这样的短选项对于不断增加的挂载选项来说太有限了； 字母表中的字母太少，无法容纳所有可能的选项。 简短的选项也很麻烦，因为很难根据单个字母确定选项的含义。 
			许多常规选项和所有特定于文件系统的选项都使用更长、更灵活的选项格式。
			要在命令行上使用 mount 的长选项，以 -o 开头，后跟以逗号分隔的相应关键字。如：
				mount -t vfat /dev/sda1 /dos -o ro,uid=1000
			最有用的长选项如下：
				exec, noexec	启用或禁用文件系统上程序的执行。
				suid, nosuid	启用或禁用 setuid 程序
				ro				以只读模式挂载文件系统（与 -r 选项相同）
				rw				以读写模式挂载文件系统
			》注意：
				Unix 和 DOS 文本文件之间存在差异，主要在于行的结束方式。 在 Unix 中，只有换行符 (\n, ASCII 0x0A) 标记行的结束，但 DOS 使用回车符 (\r, ASCII 0x0D) 后跟换行符。 
				在文件系统级别上进行了许多自动转换的尝试，但这些总是存在问题。 vim 等文本编辑器可以自动检测文件的换行符样式并对其进行适当维护。 这样更容易保持样式统一。
	Ⅶ	重载文件系统
		有时需要更改当前挂载的文件系统的安装选项；最常见的情况是当需要在崩溃恢复期间使只读文件系统可写时。在这种情况下，需要在同一安装点重新附加文件系统。
		以下命令以读写模式重新挂载根目录（需要 -n 选项，因为当根目录为只读时，mount 命令无法写入系统挂载数据库）：
			mount -n -o remount /
		上述命令假定 /etc/fstab 中包含 / 的正确设备列表。如果不是，必须将该设备指定为附加选项
	Ⅷ	/etc/fstab 文件系统表
		为了在引导时自动挂载文件系统，Linux系统在 /etc/fstab 中保留了文件系统和选项的永久列表。每一行对应一个文件系统并分为六个字段。从左到右，这些字段分别是：
			①	设备或UUID		当前大多数Linux系统在 /etc/fstab 中不再使用设备，倾向于使用 UUID。
			②	挂载点			指示在那里附加文件系统
			③	文件系统类型	
			④	选项			有逗号分隔的长选项
			⑤	由 dump 命令使用的备份信息	dump 命令是一个早已过时的备份实用程序；该字段不再相关，应该始终将其设置为0
			⑥	文件系统完整性测试顺序	要确保 fsck 始终首先在根上运行，始终将根文件系统的值设置为1，将硬盘或SSD上任何其他本地连接的文件系统的值设置为2。
										使用0禁用对所有其他文件系统的启动检查，包括只读设备、交换区和 /proc 文件系统。
		可以尝试使用以下命令同时挂载 /etc/fstab 中不包含 noauto 选项的所有条目：
			mount -a
		选项说明：
			①	defaults	设置 mount 的默认值：读写模式、启动设备文件、可执行文件、setuid位等。当不想为文件系统提供任何特殊选项但确实想填写 /etc/fstab 中的所有字段时使用此选项。
			②	errors		这个特定于 ext2/ext3/ext4 的参数设置系统在挂载文件系统时遇到问题时的内核行为。默认值为 errors=continue（内核应该返回错误代码并继续运行）。
							要让内核以只读模式再次尝试挂载，使用 errors=remount-ro 。errors=panic（告诉内核和系统在挂载出现问题时停止）
			③	noauto		告诉 mount -a ，忽略该条目。使用此选项可以防止在启动时挂载可移动媒体设备，如闪存设备。
			④	user		此选项允许非特权用户在特定条目上运行挂载，这对于允许对可移动媒体进行某种类型的访问非常方便。
							由于用户可以将setuid-root 文件放在另一个系统的可移动介质上，因此此选项还会设置nosuid、noexec和nodev（以禁止特殊设备文件）。
							对于可移动媒体和其他一般情况，此选项现在的用途有限，因为大多数系统使用ubus以及其他机制来自动挂载插入的媒体。
							但，当想要授予对挂载特定目录的控制权时，此选项在特殊情况下很有用。
	Ⅸ	/etc/fstab 的替代
		尽管 /etc/fstab 文件是表示文件系统及其挂载点的传统方式，但还有两种选择。 第一个是 /etc/fstab.d 目录，其中包含单独的文件系统配置文件（每个文件系统一个文件）。
		第二种选择是为文件系统配置systemd单元。但systemd单元配置通常是从（或基于）/etc/fsatab文件生成的，可能会发现在系统上有一些重叠。
	Ⅹ	文件系统容量
		要查看当前挂载的文件系统的大小和利用率，使用 df 命令。如：
			# df 
			文件系统              1K-块    已用    可用 已用% 挂载点
			devtmpfs               4096       0    4096    0% /dev
			tmpfs                470304       0  470304    0% /dev/shm
			tmpfs                188124    3924  184200    3% /run
			/dev/mapper/cs-root 8318976 1827344 6491632   22% /
			tmpfs                470308       0  470308    0% /tmp
			/dev/sdb1           5176320  151148 5025172    3% /home
			/dev/sda1            983040  207068  775972   22% /boot
			tmpfs                 94060       0   94060    0% /run/user/0
		输出字段如下：
			①	Filesystem	文件系统设备
			②	1K-blocks	文件系统的总容量（以1024字节块为单位）
			③	Used		被占用的blocks数量
			④	Available	可用的blocks数量
			⑤	Use%		已用的blocks百分比
			⑥	Mount on	挂载点
		》注意：
			如果无法在df输出中找到与特定目录相对应的正确行，运行 df dir 。这限制了该目录的文件系统的输出。如 df . 将输出限制到持有当前目录的设备。
		》获取使用列表
			如果磁盘已满并且需要知道所有这些占用空间的文件在哪里，使用 du 命令。如果不带参数，du 会从当前工作目录开始打印目录层次结构中每个目录的磁盘使用情况。
			du -s 命令打开摘要【summary】模式以仅打印累计。要评估特定目录中的所有内容（文件和子目录），切换到该目录并运行 du -s * （该命令可能无法捕获某些点目录）。
		》注意：
			POSIX 标准定义块大小为 512 字节。 然而，这个大小更难读取，因此默认情况下，大多数 Linux 发行版中的 df 和 du 输出都以 1,024 字节块为单位。 
			如果坚持以 512 字节块显示数字，请设置 POSIXLY_CORRECT 环境变量。 要显式指定 1,024 字节块，请使用 -k 选项（两个实用程序都支持此选项）。 
			df 和 du 程序还有一个 -m 选项来列出 1MB 块的容量，以及一个 -h 选项来根据文件系统的总体大小来最佳猜测最容易阅读的内容。
	Ⅹ Ⅰ	检查和修复文件系统
		Unix 文件系统提供的优化是通过复杂的数据库机制实现的。 为了使文件系统无缝工作，内核必须相信已挂载的文件系统没有错误，并且硬件可靠地存储数据。 如果存在错误，可能会导致数据丢失和系统崩溃。
		除了硬件问题之外，文件系统错误通常是由于用户以粗鲁的方式关闭系统（例如，拔掉电源线）造成的。 在这种情况下，内存中先前的文件系统缓存可能与磁盘上的数据不匹配，并且当碰巧启动计算机时，系统也可能正在更改文件系统。
		尽管许多文件系统支持日志以使文件系统损坏的情况大大减少，但应该始终正确关闭系统。 无论使用什么文件系统，仍然需要时不时地检查文件系统，以确保一切仍然正常。
		检查文件系统的工具是 fsck 。与 mkfs 一样，Linux支持的每种文件系统类型都有不同版本的 fsck 。如，当在扩展文件系统系列 (ext2/ext3/ext4) 上运行时，fsck 会识别文件系统类型并启动 e2fsck 实用程序。 
		通常不需要输入 e2fsck，除非 fsck 无法确定文件系统类型或者您正在查找 e2fsck 手册页。
		要在交互式手动模式下运行 fsck ，提供设备或挂载点作为参数，如：
			fsck /dev/sdb1
		》注意：
			切勿在已挂载的文件系统上使用 fsck ——内核可能会在运行检查时更改磁盘数据，从而导致运行时不匹配，从而导致系统崩溃并损坏文件。只有一个例外：如果以单用户模式以只读方式挂载根分区，则可以对其使用 fsck 。
		在手动模式下， fsck 会打印详细的状态报告。如果 fsck 在手动模式下发现问题，它会停止并询问与修复问题相关的问题。这些问题涉及文件系统的内部结构，如重新连接松散的inode和清除块。
		当fsck 询问是否重新连接此类文件时，它发现了一个似乎没有名称的文件。当重新连接此类文件时，fsck会将文件放置在文件系统中的lost+found目录中，并以数字作为文件名。
		如果发生这种事情，需要根据文件内容猜测名称；原来的文件名可能已经消失了。
		一般来说，如果刚刚不小心关闭了系统，那么等待 fsck 修复过程是没有意义的，因为 fsck 可能有很多小错误需要修复。幸运的是，e2fsck 有一个 -p 选项，可以自动修复普通问题，无需询问，并在出现严重错误时中止。 
		事实上，Linux 发行版在启动时运行 fsck -p 的变体。（可能还会看到 fsck -a，它执行相同的操作。）
		如果怀疑系统发生重大灾难（如硬件故障或设备配置错误），需要决定采取哪些行动，因为 fsck 确实会弄乱具有更大问题的文件系统。（表明系统存在严重问题的一个迹象是fsck在手动模式下询问很多问题）
		如果认为发生了非常糟糕的事情，尝试运行 fsck -n 检查文件系统而不修改任何内容。如果认为可以修复的设备存在问题，在真正运行 fsck 之前修复它，否则可能会丢失大量数据。
		如果怀疑只有超级块已损坏，也许可以使用 mkfs 创建的超级快备份之一来恢复文件系统。使用 fsck -b num 将损坏的超级快替换为块 num 处的备用块，并希望得到最好的结果。
		如果不知道在哪里找到备份超级块，可以在设备上运行 mkfs -n 以查看超级块备份编号列表，而不破坏数据。【再次确保使用的是 -n ，否则真的会破坏文件系统】。如：
			# mkfs -n /dev/sdb1
			mke2fs 1.46.5 (30-Dec-2021)
			 /dev/sdb1 有一个 ext4 文件系统
			        创建于 Sun Jan 21 21:29:47 2024
			无论如何也要继续?（y,N) y
			创建含有 1310464 个块（每块 4k）和 327680 个inode的文件系统
			文件系统UUID：c22521e1-ca0d-406d-b281-b64bfd7c5632
			超级块的备份存储于下列块： 
			        32768, 98304, 163840, 229376, 294912, 819200, 884736
		》检查 ext3 和 ext4 文件系统
			通常不需要手动检查ext3和ext4文件系统（日志可确保数据完整性）。如果没有彻底关闭系统，日志中可能会包含一些数据。要将ext3或extr4文件系统中的日志刷新到常规文件系统数据库，运行 e2fsck ，如：
				e2fsck -fy /dev/disk_device
			可能希望在ext2模式下挂载损坏的ext3或ext4文件系统（内核不会挂载具有非空日志的ext3 或 ext4文件系统）
		》最坏的情况
			更严重的磁盘问题使得几乎没有选择：
				①	可以尝试使用 dd 从磁盘中提取整个文件系统镜像，并将其传输到另一个相同大小的磁盘上的分区。
				②	可以尝试尽可能多地修补文件系统，以只读模式挂载它，并尽可能地挽救它
				③	尝试 debugfs
			在前两种情况下，仍然需要在挂载文件系统之前修复它，除非想手动挑选原始数据。如果愿意，可以选择通过输入 fsck -y 来回答所有 fsck 问题，但将此作为最后的手段（在修复过程中可能会出现更愿意手动处理的问题）。
			debugfs 允许查看文件系统上的文件并将它们复制到其他地方。默认，它以只读模式打开文件系统。如果要恢复数据，最好保持文件完好无损，以避免进一步搞乱。
	Ⅹ Ⅱ	特殊目的文件系统
		并非所有文件系统都代表物理介质上的存储。 大多数版本的 Unix 都有充当系统接口的文件系统。 也就是说，文件系统不仅仅充当在设备上存储数据的方式，还可以表示系统信息，例如进程 ID 和内核诊断信息。
		Linux上常用的一些特殊文件系统类型包括：
			①	proc	挂载在/proc。proc是process的缩写。/proc 中的每个数字目录均指代系统上当前进程的ID；每个目录中的各个文件代表该进程的各个方面。/proc/self 目录代表当前进程。
						proc 文件系统在/proc/cpuinfo等文件中包含大量附加额外内核和硬件信息。【内核设计指南建议将与进程无关的信息从/proc移出并移入/sys，因此/proc中的系统信息可能不是最新的接口】。
			②	sysfs	挂载在/sys。
			③	tmpfs	挂载在/run和其他路径。通过tmpfs，可以使用物理内存和交换空间作为临时存储。可以将 tmpfs 挂载在喜欢的位置，使用 size 和 nr_blocks 长选项来控制最大大小。
						注意，不要不断地将内容倒入tmpfs位置，系统最终会耗尽内存，并且程序将开始崩溃。
			④	squashfs 一种只读文件系统，其中内容以压缩格式存储并通过环回设备按需提取。如在 snap 包管理系统中，该系统将包安装在 /snap 目录下。
			⑤	overlay	将目录合并为组合的文件系统。容器经常使用 overlay 文件系统。
3、交换空间
	并非磁盘上的每个分区都包含文件系统。还可以使用磁盘空间来增加机器上的RAM。如果实际内存不足，Linux虚拟内存系统可以自动将内存片段移入磁盘存储或从磁盘存储取出。
	这称为交换，因为空闲程序片段被交换到磁盘以交换驻留在磁盘上的活动片段。用于存储内存页的磁盘区域称为交换空间【swap space】（或简称交换【swap】）
	free 命令的输出包括当前交换使用量，如：
		# free
		               total        used        free      shared  buff/cache   available
		Mem:          940612      355492      499060        3932      232248      585120
		Swap:        1048572           0     1048572
	Ⅰ	使用磁盘分区作为交换空间
		要使用整个磁盘分区作为交换，完成以下步骤：
			①	确保分区是空的
			②	使用 mkswap dev ，其中 dev 是分区的设备。此命令在分区上放置交换签名，将其标记为交换空间（而不是文件系统或其他）。
			③	执行 swapon dev ，将空间注册到内核
		创建交换分区后，可以在 /etc/fstab 文件中添加新的交换条目，以使系统在计算机启动时立即使用交换空间。如：
			/dev/sda5 none swap sw 0 0
		swap 签名具有 UUID 。
	Ⅱ	使用文件作为交换空间
		如果被迫重新分区磁盘以创建交换分区，则可以使用常规文件作为交换空间。使用以下命令创建一个空文件，将其初始化为swap，并将其添加到交换池【swap pool】中：
			# dd if=/dev/zero of=swap_file bs=1024k count=num_mb
			# mkswap swap_file
			# swapon swap_file
		swap_file 是新交换文件的名称，num_mb是所需的大小。
		要从内核的活动池中删除交换分区或我呢见，使用 swapoff 命令。系统必须有足够的可用剩余内存（实际内存和交换内存总和）来容纳要删除的交换池部分中的任何活动页面。
	Ⅲ	确定需要多少 swap
		曾经，Unix 传统观点认为，应该始终保留至少两倍于实际内存的交换空间。 如今，不仅可用的巨大磁盘和内存容量使问题变得模糊，而且使用系统的方式也使问题变得模糊。
		一方面，磁盘空间非常充足，因此很容易分配两倍以上的内存大小。另一方面，可能永远不会使用交换空间，因为您有太多的实际内存。
		“双倍实际内存”规则源于多个用户登录到一台计算机的时代。 不过，并非所有用户都处于活动状态，因此当活动用户需要更多内存时，能够方便地交换不活动用户的内存。
		对于单用户计算机来说，同样的情况可能仍然适用。 如果正在运行许多进程，通常可以交换部分不活动进程，甚至交换活动进程的不活动部分。
		然而，如果因为许多活动进程想要同时使用内存而频繁访问交换空间，那么将遭受严重的性能问题，因为磁盘 I/O（甚至 SSD 的 I/O）速度太慢，无法跟上其余系统进程的速度。唯一的解决方案是购买更多内存、终止某些进程或抱怨。
		有时，Linux 内核可能会选择交换进程以支持更多的磁盘缓存。 为了防止这种行为，一些管理员将某些系统配置为根本没有交换空间。 例如，高性能服务器永远不应该占用交换空间，并且应该尽可能避免磁盘访问。
		》注意：
			在通用机器上不配置交换空间是危险的。 如果一台机器完全耗尽了实际内存和交换空间，Linux 内核会调用内存不足 (OOM) 杀手来终止进程以释放一些内存。
4、逻辑卷管理器
	逻辑卷只是块设备，它们通常包含文件系统或交换签名，可以将卷组及其逻辑卷之间的关系视为类似于磁盘及其分区之间的关系。关键区别在于，通常不需要定义逻辑卷在卷组中的布局方式——LVM可以解决所有这些问题。
	LVM允许一些强大且及其有用的操作，如：
		①	添加更多PV（如其他磁盘）到一个卷组，增加其大小。
		②	删除PV【在有足够的剩余空间来容纳卷组内的现有逻辑卷】
		③	调整逻辑卷大小（相应的，使用 fsadm 工具调整文件系统大小）
	无需重新启动计算机即可完成所有这些操作，并且在大多数情况下无需卸载任何文件系统。 尽管添加新的物理磁盘硬件可能需要关闭，但云计算环境通常允许您动态添加新的块存储设备，这使得 LVM 成为需要这种灵活性的系统的绝佳选择。	
	Ⅰ	使用LVM
		LVM有许多用于管理卷和卷组的用户空间工具。其中大多数都基于lvm命令，这是一种交互式通用工具。有单独的命令（只是LVM的符号连接）来执行特定任务。
		如，vgs命令与在交互式lvm工具的lvm>提示符下键入vgs具有相同的效果，并且会发现vgs（通常在/sbin中）是lvm的符号链接。
		①	列出和了解卷组
			vgs 命令显式系统上当前配置的卷组，如：
				# vgs
				  Devices file /dev/sdb is excluded: device is partitioned.
				  VG #PV #LV #SN Attr   VSize  VFree
				  cs   1   2   0 wz--n- <9.00g    0
			vgs 输出字段说明：
				VG		卷组名成。
				#PV		卷组存储包含的物理卷【pv】的数量。
				#LV		卷组中逻辑卷【lv】的数量
				#SN		逻辑卷快照的数量。
				Attr	卷组的属性。w（可写）、z（可调整大小）、n（正常分配策略）处于活跃状态。
				VSize	卷组大小
				VFree	卷组上未分配空间的数量
			如果想更深入地了解卷组，使用 vgdisplay 命令，如：
				# vgdisplay
				  --- Volume group ---
				  VG Name               cs
				  System ID             
				  Format                lvm2
				  Metadata Areas        1
				  Metadata Sequence No  3
				  VG Access             read/write
				  VG Status             resizable
				  MAX LV                0
				  Cur LV                2
				  Open LV               2
				  Max PV                0
				  Cur PV                1
				  Act PV                1
				  VG Size               <9.00 GiB
				  PE Size               4.00 MiB
				  Total PE              2303
				  Alloc PE / Size       2303 / <9.00 GiB
				  Free  PE / Size       0 / 0   
				  VG UUID               P8Ld4d-N1BR-tkPH-ho3N-YD0n-eQPg-3Rcaje
			vgdisplay 输出字段说明：
				Open LV		当前使用的逻辑卷数量
				Cur PV		卷组包含地物理卷的数量
				Act PV		卷组中活动物理卷的数量
				VG UUID		卷组的通用唯一标识符。系统上可能存在多个同名卷组；在这种情况下，UUID可以帮助隔离特定的一个。大多数LVM工具（如vgrename，可以帮助解决此类情况）接受UUID作为卷组名称的替代名称。
		②	列出逻辑卷
			列出逻辑卷的命令是 lvs ，lvdisplay 显式更多详情。如：
				# lvs
				  LV   VG Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
				  root cs -wi-ao---- <8.00g                                                    
				  swap cs -wi-ao----  1.00g 
			lvs 输出字段说明：
				LV			逻辑卷名称
				VG			逻辑卷所在的卷组
				Attr		逻辑卷的属性。其中w（可写），i（继承的分配策略）、a（活动）和o（开放）。在更高级的卷组配置中，更多的属性处于活动状态，特别是第一个、第七个和第九个。
				LSize		逻辑卷的大小
			运行 lvdisplay 有助于了解逻辑卷适合系统的位置。如：
				# lvdisplay /dev/cs/root
				  --- Logical volume ---
				  LV Path                /dev/cs/root
				  LV Name                root
				  VG Name                cs
				  LV UUID                GErhST-n05b-u5HL-fEce-cdDY-zfJe-llx9jS
				  LV Write Access        read/write
				  LV Creation host, time localhost.localdomain, 2023-12-13 21:36:26 +0800
				  LV Status              available
				  # open                 1
				  LV Size                <8.00 GiB
				  Current LE             2047
				  Segments               1
				  Allocation             inherit
				  Read ahead sectors     auto
				  - currently set to     256
				  Block device           253:0
		③	使用逻辑卷设备
			一旦LVM完成其在系统上的设置工作，逻辑卷块设备就以 /dev/dm-0，/dev/dm-1等形式可用了。由于这些设备名称的不可预测性，LVM还会根据卷组和逻辑卷名称创建具有指向具有稳定名称的设备的符号链接，如/dev/cs/root。
			在大多数实现中，符号链接还有一个附加位置：/dev/mapper。这里的名称格式也是基于卷组和逻辑卷的，但没有目录层次结构（如，cs-root）。在这里，udev 将卷组中的单破折号转换为双破折号，用单破折号分隔卷组和逻辑卷名称。
			许多系统在systemd、引导加载器【boot loader】配置中使用 /dev/mapper 中的链接，以便将系统指向用于文件系统和交换空间的逻辑卷。
			在任何情况下，这些符号链接都指向逻辑卷的块设备，可以像与任何其他块设备一样与它们交互：创建文件系统、创建交换分区等。
		④	使用物理卷
			LVM 要检查的最后一个主要部分是物理卷 (PV)。 卷组由一个或多个 PV 构建。 尽管 PV 看起来像是 LVM 系统的一个简单部分，但它包含的信息比表面上看到的要多一些。 
			与卷组和逻辑卷非常相似，用于查看 PV 的 LVM 命令是 pvs（用于简短列表）和 pvdisplay（用于更深入的视图）。如：
				# pvs
				  PV         VG Fmt  Attr PSize  PFree
				  /dev/sda2  cs lvm2 a--  <9.00g    0
				# pvdisplay
				  --- Physical volume ---
				  PV Name               /dev/sda2
				  VG Name               cs
				  PV Size               <9.00 GiB / not usable 3.00 MiB
				  Allocatable           yes (but full)
				  PE Size               4.00 MiB
				  Total PE              2303
				  Free PE               0
				  Allocated PE          2303
				  PV UUID               RxkQml-RRIM-YEtJ-Y5vr-S6Z7-GZyq-YMclHO
			》注意：
				①	除了块设备之外，PV没有特殊的名称（不需要）—— 引用逻辑卷所需的所有名称都位于卷组级别及以上级别。PV有一个UUID，这是构成卷组所必需的。
				②	有一小部分空间被LVM标记为不可用【如，3.00MiB】，因为它不足以填满整个PE。
				③	pvs 输出的属性中的a对应于 pvdisplay 输出中的Allocatable，它简单地表示如果要为卷组中的某个逻辑卷分配空间，LVM可以选择使用该PV。
			PV不仅包含有关它们自己对卷组的单独贡献的信息。每个PV都包含物理卷元数据、有关其卷组及其逻辑卷的大量信息。
		⑤	构建逻辑卷系统
			》在磁盘上创建分区并将其标记为LVM【8e】
			# fdisk /dev/sdb
				命令(输入 m 获取帮助)：n
				分区类型
				   p   主分区 (0 primary, 0 extended, 4 free)
				   e   扩展分区 (逻辑分区容器)
				选择 (默认 p)：p
				分区号 (1-4, 默认  1):
				第一个扇区 (2048-10485759, 默认 2048):
				最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (2048-10485759, 默认 10485759):
				
				创建了一个新分区 1，类型为“Linux”，大小为 5 GiB。
				
				命令(输入 m 获取帮助)：t
				已选择分区 1
				Hex 代码或别名（输入 L 列出所有代码）：8e
				已将分区“Linux”的类型更改为“Linux LVM”。
			# parted /dev/sdb print
				型号：VMware, VMware Virtual S (scsi)
				磁盘 /dev/sdb：5369MB
				扇区大小 (逻辑/物理)：512B/512B
				分区表：msdos
				磁盘标志：
				
				编号  起始点  结束点  大小    类型     文件系统  标志
				 1    1049kB  5369MB  5368MB  primary            lvm	
			不一定需要对磁盘进行分区才能使其成为PV。PV可以是任何块设备，甚至是整个磁盘设备（如，/dev/sdb）。然而，分区允许从磁盘启动，并且它还提供了一种将块设备识别为LVM物理卷的方法。
		⑥	创建物理卷和卷组
			    新建分区后，LVM的第一步是将分区指定为PV并将其分配给新的卷组—— vgcreate 可执行此任务。如创建名为 myvg 的卷组，并将 /dev/vdb1作为初始PV：
					# vgcreate myvg /dev/sdb1
					  Devices file /dev/sdb is excluded: device is partitioned.
					  Physical volume "/dev/sdb1" successfully created.
					  Volume group "myvg" successfully created
			》注意：
				还可以首先使用 pvcreate 命令在单独的步骤中创建PV。但是，如果当前不存在任何内容，则 vgcreate 在分区上执行此操作。
			大多数系统会自动检测新的卷组；运行 vgs 等命令进行验证，如：
				# vgs
				  Devices file /dev/sdb is excluded: device is partitioned.
				  VG   #PV #LV #SN Attr   VSize  VFree 
				  cs     1   2   0 wz--n- <9.00g     0 
				  myvg   1   0   0 wz--n- <5.00g <5.00g
			》注意：
				如果没有看到新的卷组，先尝试运行 pvscan 。如果系统无法自动检测 LVM 的更改，则每次进行更改时都需要运行 pvscan 。
			接着可以使用 vgextend 命令 添加其他 PV，如：
				# vgextend myvg /dev/sdc1
		⑦	创建逻辑卷
			块设备级别的最后一步时创建逻辑卷。lvcreate 命令在卷组中分配一个新的逻辑卷。创建简单逻辑卷的唯一真正的复杂性是当卷组包含多个卷时确定其大小以及指定逻辑卷的类型。
			注意，PV分为多个范围【extends】；可用的PE数量可能与所需的大小不太符合。然而，它应该足够接近，这样就不会出现问题。
			使用 lvcreate 时，可以使用 --size 按字节容量指定逻辑卷的大小，或使用 --extends 选项按PE数量指定逻辑卷的大小。如：
				# lvcreate --size 1g --type linear -n mylv1 myvg
				  Logical volume "mylv1" created.
			这里的类型是线性映射，当不需要冗余或任何其他特殊功能时，这是最简单的类型。在这种情况下，--type Linear 是可选的，因为它是默认映射。
			可使用 lvs 查看新建的逻辑卷，然后，可以使用 vgdisplay 仔细查看卷组的当前状态，如：
				# vgdisplay
				  --- Volume group ---
				  VG Name               myvg
				  System ID             
				  Format                lvm2
				  Metadata Areas        1
				  Metadata Sequence No  2
				  VG Access             read/write
				  VG Status             resizable
				  MAX LV                0
				  Cur LV                1
				  Open LV               0
				  Max PV                0
				  Cur PV                1
				  Act PV                1
				  VG Size               <5.00 GiB
				  PE Size               4.00 MiB
				  Total PE              1279
				  Alloc PE / Size       256 / 1.00 GiB
				  Free  PE / Size       1023 / <4.00 GiB
				  VG UUID               zF1Cpj-2FVV-P3So-azd2-S9BJ-Dbkl-c7u21v
		⑧	操作逻辑卷：创建分区
			有了新的逻辑卷，可以通过将文件系统放在设备【逻辑卷】上并将任何普通磁盘分区一样挂载它们来使用它们。/dev/mapper中将存在指向设备【逻辑卷】的符号链接，/dev目录下中包含与卷组同名的目录中包含指向设备【逻辑卷】的符号链接。
			可以运行如下三个命令来创建文件系统、临时挂载，并查看逻辑卷上有多少实际空间：
				# mkfs -t ext4 /dev/mapper/myvg-mylv1
				# mount /dev/mapper/myvg-mylv1 /mnt
				# df /mnt
		⑨	移除逻辑卷
			在已经移动或删除了要删除的逻辑卷上的任何重要内容后，并且它们不在当前系统使用中（已卸载），可使用 lvremove 将其删除。在用这个命令操作逻辑卷时，用/分隔卷组和逻辑卷（如，myvg/mylv1），如：
				# lvremove myvg/mylv1
		⑩	调整逻辑卷和文件系统大小
			即使逻辑卷正在使用并且其文件系统已挂载，也可以调整逻辑卷的大小。但，重要的是要了解有两个步骤。要使用更大的逻辑卷，需要调整它及其内部的文件系统的大小。
			由于这是一个常见的操作，调整逻辑卷大小的 lvresize 命令有一个选项（-r）可以执行文件系统大小调整。
			有多种方法可一个更改逻辑卷大小，最直接的方法是将卷组中的空闲PE添加到逻辑卷【可通过vgdisplay查看空闲的PE】。如：
				# lvresive -l +2602 myvg/mylv1
			现在需要调整内部文件系统的大小。可以使用fsadm命令执行此操作。使用 -v 显示详细模式，如：
				# fsadm -v resize /dev/mapper/muvg-mylv1
			fsadm 只是一个脚本，它知道如何将其参数转换为特定于文件系统的工具（如 resize2fs）使用的参数。 默认情况下，如果您不指定尺寸，它只会调整大小以适合整个设备。
			使用lvresize 同时调整逻辑卷和其上文件系统的大小，如：
				# lvresize -r -l +100%FREE  myvg/mylv1
			可以在挂载时扩展ext2/ext3/ext4文件系统。但不能反向操作。文件系统挂载后无法收缩。不仅必须卸载文件系统，而且缩小逻辑卷的过程也要求执行相反的步骤。
			当手动调整大小时，需要在调整逻辑卷之前调整分区的大小，确保新的逻辑卷仍然足够大以包含文件系统。同样，将 lvresize 与 -r 一起使用要容易得多，这样它就可以协调文件系统和逻辑卷大小。
	Ⅲ	LVM 实现
		LVM 包含许多层和组件，并且内核空间和用户空间的各部分之间进行了相当仔细地分离。
		查找PV来发现卷组和逻辑卷地结构有些复杂，Linux内核宁愿不处理其中任何一个。这些事情没有理由发生在内核空间；PV只是块设备，用户空间可以随机访问块设备。事实上LVM本身只是一组了解LVM结构的用户空间实用程序的名称。
		另外，内核处理将对逻辑卷的块设备上的位置的请求路由到实际设备上的真实位置的工作。其驱动程序是设备映射器（有时简称为devmapper），它是夹在普通块设备和文件系统之间的一个新层。
		LVM用户空间工具和设备映射器之间存在某种联系：一些在用户空间中运行的实用程序，用于管理内核中的设备映射。
		①	LVM 实用程序和扫描物理卷
			在执行任何操作之前，LVM实用程序必须首先扫描可用的块设备以查找PV。LVM在用户空间必须执行的步骤大致如下：
				》找到系统上的所有PV
				》通过UUID查找PV所属的所有卷组（此信息包含在PV中）
				》验证一切是否完整（即，属于该卷组的所有必要PV都存在）
				》找到卷组中的所有逻辑卷
				》找出将数据从PV映射到逻辑卷的方案
			每个PV的开头都有一个标头，用于标识卷及其卷组和其中的逻辑卷。LVM实用程序可以将这些信息放在一起，并确定卷组（及其逻辑卷）所需的所有PV是否都存在。如果一切正常，LVM就可以将信息传送到内核。
			如果对PV上LVM标头的感兴趣，可以运行如下命令：
				# dd if=/dev/sdb1 count=1000 | strings | less
			这里，使用 /dev/sdb1 作为 PV，显示LVM所需的信息。
			任何LVM实用程序（如pvscan、lvs或vgcreate）都能执行扫描和处理PV的工作。
			》设备映射器
				LVM从PV上的所有标头确定逻辑卷的结构后，它与内核的设备映射器驱动程序通信，以便初始化逻辑卷的块设备并加载其映射表。它通过/dev/mapper/control设备文件上的ioctl(2)系统调用（通常的内核接口）来实现此目的。
				尝试监视此交互并不实际，但可以实用 dmsetup 命令查看结果的详细信息。要获取设备映射器当前服务的映射设备的清单，使用 dmsetup info，如：
					# dmsetup info
					Name:              myvg-mylv1
					State:             ACTIVE
					Read Ahead:        256
					Tables present:    LIVE
					Open count:        0
					Event number:      0
					Major, minor:      253, 2
					Number of targets: 1
					UUID: LVM-zF1Cpj2FVVP3Soazd2S9BJDbklc7u21vHyGciyCYNetGhJVAnTbTA5ohFodrWEIk
				设备的主设备号和次设备号对应于映射设备的/dev/dm-*设备文件；这里设备映射器的主设备号为253。由于次设备号为2，因此设备文件名为/dev/dm-2。
				注意，内核有一个名称和另一个映射设备的UUID。LVM将这些提供给内核（内核UUID只是卷组和逻辑卷UUID的串联）。
				还可以通过 dmsetup table 来查看 LVM 提供给设备映射器的表。如：
					# dmsetup table
					cs-root: 0 16769024 linear 8:2 2099200
					cs-swap: 0 2097152 linear 8:2 2048
					myvg-mylv1: 0 2097152 linear 8:17 2048
				名称后面的字段按顺序依次为：
					①	映射设备的起始偏移量。这些单元采用512字节“扇区”
					②	该片段的长度
					③	映射方案。这里是简单的一对一线性方案。
					④	源设备的主设备号和次设备号对，即LVM所说的物理卷
					⑤	源设备上的起始偏移量
				许多功能（如软件RAID和加密磁盘）都是基于设备映射器构建的。
5、磁盘和用户空间
	在Unix系统上与磁盘相关的组件中，用户空间和内核之间的界限可能很难描述。如，内核处理来自设备的原始块I/O，用户空间工具可以通过设备文件来使用块I/O。然而，用户空间通常仅将块I/O用于初始化操作，如分区、文件系统创建和交换空间创建。
	在正常使用中，用户空间仅使用内核在块I/O之上提供的文件系统支持。类似地，在处理虚拟内存系统中的交换空间时，内核也会处理大部分繁琐的细节。

6、传统文件系统
	传统的Unix文件系统有两个主要组件：可以存储数据的数据块池和管理数据池的数据库系统。数据库以索引节点【inode】数据结构为中心。
	索引节点【inode】是描述特定文件的一组数据，包括其类型、权限以及（也许最重要）文件数据在数据池中的驻留位置。索引节点由索引节点表中列出的数字来标识。
	文件和目录也被实现为inode。目录inode包含其他inode相对应的文件名和链接的列表。
	对于任何ext2/3/4文件系统，开始在索引节点号2处，这是根索引节点（尽量不要将其与系统根文件系统混淆）。
	这个系统由指向目录数据结构的索引节点和指向索引节点的目录数据结构组成，允许创建习惯的文件系统层次结构。此外，注意目录inode包含 . （当前目录）和 .. （父目录，根目录除外）。这样可以轻松获取参考点并导航会目录结构。
	Ⅰ	索引节点详情和链接计数
		要查看任何目录的inode编号，使用 ls -i 命令（有关更详细的inode信息，使用 stat 命令）：
			# ls -i
			 9122692 dir_1  13443245 dir_2
		链接计数是指向某个inode的目录条目总数（跨所有目录）。大多数文件的链接计数为1（它们仅在目录条目中出现一次）。大多数情况下，当创建文件时，会创建一个新的目录条目和一个新的索引节点来配合它。
		硬链接只是在目录中手动创建的指向已存在索引节点的条目。ln 命令（不带 -s 选项）允许手动创建新的硬链接。
		链接计数对于目录的作用大致相同。当创建一个目录（如，dir_1）时，其对应的inode 计数为2（一个是其父目录中的dir_1条目，一个是dir_1中的 . 条目【自引用】），
		当在dir_1中新建一个目录（如，dir_1_1），dir_1对应的索引会加一（dir_1_1 中的 .. 【指向其父目录dir_1】）。
		》注意：
			根 inode 是一个例外，其包含一个链接位于文件系统的超级块中（超级块告知在哪里可以找到根inode）。
	Ⅱ	块分配
		当为新文件分配数据池块时，文件系统要知道哪些块正在使用以及哪些块可用的最基本方法之一是使用成为块位图【block bitmap】。
		在该方法中，文件系统保留一系列字节，每一位对应于数据池中的一个块。值为0表示该块空闲，值为1表示该块正在使用中。因此，分配和解除分配块就是翻转位的问题。
		当索引节点表数据与块分配数据不匹配或链接计数不正确时，文件系统中就会出现问题。因此，当检查文件系统时，fsck会遍历inode表和目录结构以生成新的链接计数和新的块分配图【block allocation map】，
		然后比较新生成的数据与磁盘上的文件系统。如果存在不匹配，fsck必须修复链接计数并确定如何处理遍历目录结构时未出现的任何inode和/或数据。大多数 fsck 程序都会在文件系统的 lost+found 目录中创建这些“孤立”新文件。
	Ⅲ	在用户空间使用文件系统
		在用户空间中处理文件和目录时，不必太担心它们下面的实现。进程应该通过内核系统调用来访问已安装文件系统的文件和目录的内容。
		但奇怪的是，确实可以访问某些似乎不适合用户空间的文件系统信息，特别是 stat() 系统调用返回 inode 编号和链接计数。
		当您不维护文件系统时，您是否需要担心 inode 编号、链接计数和其他实现细节？ 一般来说，不会。 用户模式程序可以访问这些东西主要是为了向后兼容。
		此外，并非 Linux 中可用的所有文件系统都具有这些文件系统内部结构。 VFS 接口层确保系统调用始终返回 inode 编号和链接计数，但这些数字可能不一定意味着什么。
		可能无法在非传统文件系统上执行传统 Unix 文件系统操作。 例如，不能使用 ln 在已挂载的 VFAT 文件系统上创建硬链接，因为它的目录项结构是为 Windows 而不是 Unix 设计的。
		Linux 系统上用户空间可用的系统调用为无痛文件访问提供了足够的抽象——无需了解任何有关底层实现的信息即可访问文件。 此外，文件名格式灵活，支持大小写混合，可以轻松支持其他分层风格的文件系统。
		特定的文件系统支持不一定需要在内核中。如，在用户空间文件系统中，内核只需充当系统调用的管道。


How The Linux Kernel Boots
	启动过程的简化试图如下：
		①	机器的BIOS或启动固件加载并运行启动加载程序
		②	引导加载程序在磁盘上查找内核镜像，将其加载到内存中，然后启动它
		③	内核初始化设备及其驱动程序
		④	内核挂载根文件系统
		⑤	内核启动一个名为 init 的程序，进程ID为1。此时就是用户空间启动
		⑥	init 启动系统进程的其他部分
		⑦	在某个时刻，init 会启动一个允许登录的进程，通常是在引导序列的末尾或接近末尾时
1、启动消息
	传统的Unix系统在启动时会产生许多诊断消息，告诉有关启动过程的信息。这些消息首先来自内核，然后来自init启动的进程和初始化过程。大多数当前的Linux发行版都尽力通过闪屏和其他形式的填充来隐藏启动诊断。
	查看内核的引导和运行时诊断消息的最佳方法是使用 journalctl 命令来检索内核的日志。运行 journalctl -k 会显示当前启动的消息，但可以使用 -b 选项查看以前的启动。
	如果没有 systemd ，可以检查日志文件（如，/var/log/kern.log）或运行 dmesg 命令查看内核环形缓冲区中的消息。
	内核启动后，用户空间启动过程通常会生成消息。这些消息可能更难以查看和审查（在大多数系统上，不会在单个日志文件中找到它们）。
	启动脚本旨在将消息发送到控制台，这些消息在启动过程完成后会被删除。然而，这在Linux系统上不是问题，因为 systemd 从启动和运行时捕获通常会发送到控制台。
2、内核初始化和启动选项
	启动时，Linux内核按以下一般顺序进行初始化：
		①	CPU检查
		②	内存检查
		③	设备总线发现
		④	设备发现
		⑤	辅助内核子系统设置（网络等）
		⑥	根文件系统挂载
		⑦	用户空间启动
3、内核参数
	当Linux内核启动时，它会收到一组基于文本的内核参数，其中包含一些附加的系统详细信息。这些参数指定许多不同类型的行为，如内核应生成的诊断输出量以及设备驱动程序特定的选项。
	可以通过查看 /proc/cmdline 文件来查看传递给系统当前运行的内核的参数，如：
		# cat /proc/cmdline
		BOOT_IMAGE=(hd0,msdos1)/vmlinuz-5.14.0-352.el9.x86_64 root=/dev/mapper/cs-root ro resume=/dev/mapper/cs-swap rd.lvm.lv=cs/root rd.lvm.lv=cs/swap
	这些参数可以是简单的单字标志（如，ro和Quiet），也可以是 键=值 对。最重要的参数是 root 参数，没有它，内核无法正确执行用户空间启动。
	根文件系统可以指定为设备文件，如：
		root=/dev/sda1
	在大多数现代系统中，有两种更常见的替代方案。首先是逻辑卷，如：
		root=/dev/mapper/cs-root
	也可以是 UUID，如：
		root=UUID=17f12d53-c3d7-4ab3-943e-a0a72366c9fa
	这两者都是更可取的，因为它们不依赖于特定的内核设备映射。
	ro 参数指示内核在用户空间启动时以只读模式挂载根文件系统。这个是正常的；只读模式确保 fsck 在尝试执行任何重要操作之前可以安全地检查根文件系统。检查后，启动过程以读写模式重新挂载根文件系统。
	当遇到不理解地参数时，Linux内核会保存该参数。内核随后在执行用户空间启动时将参数传递给init。（如，将 -s 添加到内核参数，内核会将 -s 传递给 init 程序以指示它应该以单用户模式启动。
	如果对基本启动参数感兴趣，bootparam(7) 手册页提供了概述。如果正在寻找非常具体地内容，可以查看 kernel-params.txt，这是Linux内核附带地参考文件。
4、引导加载程序
	在引导过程开始时，在内核和init启动之前，引导加载程序会启动内核。引导加载程序的工作听起来很简单：将内核从磁盘上的某个位置加载到内存中，然后使用一组内核参数启动内核。
	然而，这项工作比看起来更复杂。要了解原因，考虑引导加载程序必须回答的问题：
		①	内核在哪里
		②	启动时应该向内核传递哪些内核参数
	内核及其参数通常位于根文件系统上的某个位置。内核本身尚未运行，通常是内核遍历文件系统来查找必要的文件。更糟糕的是，通常用于访问磁盘的内核设备驱动程序也不可用。
	引导加载程序确实需要驱动程序来访问磁盘，但它与内核使用的驱动程序不同。在PC上，引导加载程序使用传统的基本输入/输出系统（BIOS）或较新的统一可扩展固件接口（UEFI）来访问磁盘。
	现代磁盘硬件包括允许BIOS或UEFI通过逻辑块寻址（LBA）访问连接的存储硬件的固件。LBA是一种通用的、简单的从任何磁盘访问数据的方法，但其性能较差。不过，引导加载程序通常是唯一必须使用次模式进行磁盘访问的程序。
	启动后，内核可以访问自己的高性能驱动程序。
	》注意：
		要确定系统使用BIOS还是UEFI，可以运行 efibootmgr 。如果获得启动目标列表，表明系统具有UEFI。如果显示 EFI variables are not supported on this system. 则系统将使用BIOS。
		也可以检查 /sys/firmware/efi 是否存在；如果存在，系统使用 UEFI 。
	一旦解决了对磁盘原始数据的访问问题，引导加载程序必须完成在文件系统上定位所需数据的工作。最常见的引导加载程序可以读取分区表，并内置对文件系统只读访问的支持。
	因此，他们可以找到并读取将内核放入内存所需的文件。此功能使动态配置和增强引导加载程序变得更加容易。Linux引导加载程序并不总是具有此功能；没有它，配置引导加载程序会更加困难。
	一般来说，有一种模式是内核添加新功能（特别是在存储技术方面），然后引导加载程序添加这些功能的单独的简化版本来进行补偿。
	Ⅰ	引导加载程序任务
		Linux引导加载程序的核心功能包括执行以下操作的能力：
			①	从多个内核进行选择
			②	在内核参数组之间切换
			③	允许用户手动覆盖和编辑内核镜像名称和参数（如，进入单用户模式）
			④	提供对启动其他操作系统的支持
		自Linux内核诞生以来，引导加载程序已经变得相当先进，具有命令行历史记录和菜单系统等功能，但基本需求始终是内核镜像和参数选择的灵活性。
		引导加载程序提供比以往更强大的功能，如果正在构建自定义内核或只是想调整参数，这会特别方便。
	Ⅱ	引导加载程序概述
		以下是可能遇到的主要引导加载程序：
			①	GRUB			Linux系统上近乎通用的标准，具有BIOS/MBR和UEFI版本。
			②	LILO			最早的Linux引导加载程序之一。ELILO是UEFI版本
			③	SYSLINUX		可以配置为从许多不同类型的文件系统运行
			④	LOADLIN			从MS-DOS启动内核
			⑤	systemd-boot	简单的UEFI启动管理器
			⑥	coreboot		PC BIOS 的高性能替代品，可以包含内核
			⑦	Linux Kernel EFISTUB	用于直接从 EFI/UEFI 系统分区 (ESP) 加载内核的内核插件。
			⑧	efilinux		UEFI 引导加载程序旨在充当其他UEFI引导加载程序的模型和参考
		使用其他引导加载程序的基本原理是它们比 GRUB 更容易配置，速度更快，或者提供一些其他特殊用途的功能。
		可以通过进入引导提示符了解有关引导加载程序的更多信息，可以在引导提示符中输入内核名称和参数。
5、GRUB介绍
	GRUB 代表 Grand Unified Boot Loader 。GRUB最重要的功能之一是文件系统导航，可以轻松选择内核镜像和配置。查看其实际情况并总体了解GRUB的最佳方法之一是查看其菜单。
	要访问 GRUB 菜单，在BIOS启动屏幕首次出现时按住Shift，如果系统具有UEFI，按住ESC。否则，引导加载程序可能不会在加载内核之前暂停。
	Ⅰ	使用 GRUB 命令行探索设备和分区
		【进入 GRUB 菜单后，按 c 键入 GRUB 命令行。会出现 GRUB 提示符，如：
			grub>
		GRUB 有自己的设备寻址方案。设备名称分配可能会发生变化，但幸运的是，GRUB可以在所有分区中搜索UUID，以找到内核所在的分区。
		》列出设备
			可以通过不带参数的 ls 命令输出GRUB已知的设备列表，如：
			grub> ls
			(hd0) (hd0,msdos2) (hd0,msdos1) (hd1) (hd1,msdos1)
			这里有两个磁盘设备 (hd0) 、 (hd1) ，和三个分区 (hd0,msdos1) (hd0,msdos2) (hd1,msdos1)
			分区上的msdos前缀说明该磁盘包含MBR分区表；如果以gpt开头表示GPT（在UEFI系统上找到）。
			还有带有第三个标识符的更深层次的组合，其中BSD磁盘标签映射驻留在分区内，但通常不必担心这一点，除非在一台计算机上运行多个操作系统。
			要获取更详细的信息，使用 ls -l 。此命令特别有用，因为它显示分区文件系统的所有UUID，如：
		》文件导航
			使用 echo 命令确定 GRUB 根目录，如：
			grub> echo $root
			hd0,msdos1
			要使用 GRUB 的 ls 命令列出该根目录中的文件和目录，可以在分区末尾附加一个斜杠，如：
			grub> ls (hd0,msdos1)
			由于输入实际的根分区很不方便，可以替换为root变量以节省输入，如：
			grub> ls ($root)/
			输出是该分区文件系统上的文件和目录名称的简短列表，如etc/，bin/，和dev/。
			可以以类似的方式更深入地查看分区上地文件和目录，如：
			grub> ls ($root)/boot
			使用上下箭头翻阅GRUB命令历史记录，使用左右箭头编辑当前命令行。标准阅读行键（Ctrl-N、Ctrl-P等）也可以使用。
			还可以使用 set 命令查看当前设置的所有GRUB变量，如：
			grug> set
			这些变量中最重要的变量之一是 $prefix ，即GRUB期望在其中找到其配置和辅助支持的文件系统和目录。
		使用完GRUB命令行界面后，可以按ESC键返回GRUB菜单。或，如果已经设置了启动所需的所有配置（包括linux和可能的initrd变量），则可以输入boot命令来启动该设置。
	Ⅱ	GRUB 配置
		GRUB配置目录通常是 /boot/grub 或 /boot/grub2 。它包含中央配置文件 grub.cfg、特定于体系结构的目录（例如包含带有 .mod 后缀的可加载模块的 i386-pc）以及一些其他项目（例如字体和本地化信息）。 
		不会直接修改grub.cfg； 相反，将使用 grub-mkconfig 命令（或 Fedora 上的 grub2-mkconfig）。
		》查看 grub.cfg
			快速浏览grub.cfg，了解GRUB如何初始化其菜单和内核选项。该文件由GRUB命令组成，这些命令通常以许多初始化步骤开始，然后是一系列针对不同内核和引导配置的菜单条目。
		》生成新的配置文件
			如果想更改GRUB配置，不要直接编辑grub.cfg文件（它是自动生成的，系统偶尔会覆盖它）。将在其他地方设置新配置，然后运行grub-mkconfig来生成新配置。grub.cfg 开头部分，应该有这样的注释行：
				### BEGIN /etc/grub.d/00_header ###
			/etc/grub.d 中几乎每个文件是一个shell脚本，它生成 grub.cfg 文件的一部分。 grub-mkconfig 命令本身是一个shell脚本，它运行 /etc/grub.d 中的所有内容。
			GRUB本身不会在引导时运行这些脚本；在用户空间运行脚本来生成GRUB运行的grub.cfg文件。以root 身份运行 grub-mkconfig|grub2-mkconfig 会将配置打印到标准输出。
			如果想向 GRUB 配置添加菜单项和其他命令，应该将自定义内容放入 GRUB 配置目录中的新 custom.cfg 文件（通常为/boot/grub2/custom.cfg）中。
			/etc/grub.d 配置目录提供了两个选项：40_custom 和 41_custom 。在40_custom 中，可以自己编辑脚本，但它最不稳定（软件包升级可能会破坏所做的任何更改）。
			41_custom 脚本更简单（它只是GRUB启动时加载custom.cfg的一系列命令）。如果选择41_custom ，则在生成配置文件时不会显示更改（GRUB在引导时完成所有工作）。
		》注意：
			文件名前面的数字影响处理顺序；配置文件中数字较小的排在前面。
		自定义配置文件的两个选项并不是特别广泛，并且没有什么可以阻止添加自定义脚本来生成配置数据。可能会在 /etc/grub.d 目录中看到一些特定于特定发行版的添加内容。
		要编写并安装新生成的GRUB配置文件，可以使用 grub-mkconfig 的 -o 选项将配置写入 GRUB 目录，如：
			# grub-mkconfig -o /boot/grub2/grub.cfg
		像往常一样，备份旧配置并确保安装到正确的目录。
	Ⅲ	GRUB 安装
		安装GRUB比配置它更复杂。幸运的是，通常不必担心安装（发行版会帮助处理它）。但，如果尝试复制或恢复可启动磁盘，或准备自己的启动顺序，则可能需要自行安装。
		在安装GRUB之前，要知道PC如何启动并确定使用的是MBR还是UEFI启动。接着，构建 GRUB 软件集并确定 GRUB 目录所在的位置（默认位置是/boot/grub2）。
		如果发行版构建了GRUB，可能不需要构建GRUB，但如果需要构建GRUB，需要了解如何从源代码构建软件。确保构建正确的目标：MBR 或 UEFI 启动是不同的（32位和64位EFI之间甚至存在差异）。
		》在系统上安装GRUB
			安装引导加载程序要求用户或安装程序确定以下内容：
				①	当前运行的系统所看到的目标GRUB目录（通常是/boot/grub），但如果将GRUB安装在另一个磁盘上以便在另一个系统上使用，则可能会有所不同。
				②	GRUB目标磁盘的当前设备
				③	对于 UEFI 启动，EFI 系统分区的当前挂载点（通常是/boot/efi）。
			GRUB是一个模块化系统，但为了加载模块，它必须读取包含GRUB目录的文件系统。需要构建一个能够读取该文件系统的GRUB版本，以便它可以加载其配置的其余部分（grub.cfg）和任何所需的模块。
			在Linux上，这通常意味着构建一个预加载了ext2.mod 模块（可能还有lvm.mod）的GRUB版本。一旦有了这个版本，需要做的就是将它放在磁盘的可引导部分，并将其余所需的文件放入/boot/grub。
			GRUB附带了一个grub-install的实用程序，它执行安装GRUB文件和配置的大部分工作（如，如果当前的磁盘位于/dev/sda，并且想要使用当前的/boot/grub 目录在该磁盘的MBR上安装GRUB，使用以下命令）：
				# grub-install /dev/sda
			》注意：
				错误地安装GRUB可能会破坏系统地启动顺序。可以通过 dd 备份 MBR ，备份当前安装地任何其他GRUB目录，并确保有紧急启动计划。
		》使用 MBR 在其他存储设备上安装GRUB
			要在当前系统外部得分存储设备上安装GRUB，必须在该设备上手动指定当前现在看到的GRUB目录。如，假设有一个目标设备/dev/sdc，并且该设备的包含/boot的根文件系统（如/dev/sdc1）安装在当前系统的/mnt上。
			这意味着当安装GRUB时，当前系统将在/mnt/boot/grub中看到GRUB文件。运行grub-install时，告诉它这些文件应该放在哪里，如：
				# grub-install --boot-directory=/mnt/boot /dev/sdc
			在大多数MBR系统上，/boot是根文件系统的一部分，但某些安装将/boot放入其自己的单独文件系统中。确保知道目标/boot所在的位置
		》使用 UEFI 安装 GRUB
			UEFI 安装更容易（要做的是将引导加载程序复制到位）。还需要使用efibootmgr命令向固件“宣布”引导加载程序，即将加载程序配置保存到NVRAM。
			grub-install 命令会在可用时运行此命令。因此通常可以在UEFI系统上安装GRUB，如：
				# grub-install --efi-directory=efi_dir --bootloader-id=name
			这里，efi_dir是UEFI目录出现在当前系统上的位置（通常是/boot/efi/EFI，UEFI分区通常安装在/boot/efi】），name是引导加载程序的标识符。
			注意，当安装UEFI引导加载程序时，可能会出现许多问题。如，如果要安装到最终将在另一个系统中的磁盘，必须弄清楚如何向新系统的固件宣布该引导加载程序。可移动介质的安装过程也存在差异。
			最大的问题之一是UEFI安全启动。
6、UEFI安全启动【boot】问题
	影响 Linux 安装的一个新问题是处理最近 PC 上发现的安全启动功能。当激活时，UEFI机制要求任何引导加载程序都由受信任的机构进行数字签名才能运行。Microsoft已要求随其系统提供 Windows 8 及更高版本的硬件供应商使用安全启动。
	结果是，如果尝试在这些系统上安装未签名的引导加载程序，固件将拒绝该加载程序，并且操作系统将无法加载。
	主要的Linux发行版在安全启动方面没有问题（它们包含签名的启动加载程序，通常基于UEFI版本的GRUB）。UEFI和GRUB之间通常有一个小的签名垫片【shim】（UEFI运行shim，后者又执行GRUB）。
	如果计算机不在值得信赖的环境中或需要满足某些安全要求，那么防止启动未经授权的软件是一项重要功能，因此某些发行版更进一步，要求对整个启动序列（包括内核）进行签名。
	保护引导系统有一些缺点，特别是对于尝试构建自己的引导加载程序的人来说。可以通过在 UEFI 设置中禁用安全启动要求来绕过安全启动要求。然而，这对于双启动系统来说并不能完全正常工作，因为如果没有启用安全启动，Windows 将无法运行。
7、链式加载其他操作系统
	UEFI使得支持加载其他操作系统相对容易，因为可以在EFI分区中安装多个引导加载程序。但，较旧的MBR不支持此功能，即使有UEFI，可能仍有一个带有想要使用的MBR样式引导加载程序的单独分区。
	GRUB可以在磁盘上的特定分区上加载并运行不同的引导加载程序，而不是配置和运行Linux内核，这称为链式加载。
	要进行链式加载，在GRUB配置中创建新的菜单条目（使用“生成新配置文件”中的方法之一）。如（在磁盘的第三个分区上安装Windows）：
		menuentry "Windows" {
				insmod chain
				insmod ntfs
				set root=(hd0,3)
				chainloader +1
		}
	+1 选项告诉chainloader加载分区第一个扇区的任何内容。还可以让它直接加载文件，通过使用这样的行来加载io.sys MS-DOS 加载程序：
		menuentry "DOS" {
				insmod chain
				insmod fat
				set root=(hd0,3)
				chainloader /io.sys
		}
8、引导加载器详情
	Ⅰ	MBR 引导
		除了分区信息外，MBR还包括 PC BIOS 在加电自检（POST）后加载和执行的441字节的小区域。这个空间不足以容纳几乎所有引导加载程序，因此需要额外的空间，从而产生所谓的多级引导加载程序。
		在这种情况下，MBR中的初始代码除了加载引导加载程序代码的其余部分之外什么也不做。引导加载程序的其余部分之外什么也不做。引导加载程序的其余部分通常填充到MBR和磁盘上第一个分区之间的空间中。
		这并不是很安全，因为任何东西都可以覆盖其中的代码，但大多数引导加载程序都会这样做，包括大多数GRUB安装。
		这种将引导加载程序代码放在MBR之后的方案不适用于使用BIOS引导的GPT分区磁盘，因为GPT信息驻留在MBR之后的区域（GPT保留了传统的MBR，以实现向后兼容性）。
		GPT 的解决方法是创建一个名为BIOS引导分区的小分区，并使用特殊的UUID为完整的引导加载程序代码指定存放位置。这不是常见的配置(GPT通常与UEFI一起使用，而不是与传统的BIOS一起使用）。
		它通常只出现在具有非常大磁盘（大于2TB）的旧系统中；这些对于MBR来说太大了。
	Ⅱ	UEFI 引导
		PC 制造商和软件公司意识到传统的 PC BIOS 受到严重限制，因此他们决定开发一种称为可扩展固件接口 (EFI：Extensible Firmware Interface) 的替代品。
		EFI 花了一段时间才在大多数 PC 上流行起来，但如今它是最常见的，尤其是现在 Microsoft 要求 Windows 安全启动。 当前的标准是统一可扩展固件接口 (UEFI：Unified EFI)，其中包括内置shell以及读取分区表和导航文件系统的功能等功能。
		GPT 分区方案是 UEFI 标准的一部分。
		与 MBR 相比，UEFI 系统上的引导完全不同。在大多数情况下，它更容易理解。与驻留在文件系统外部的可执行引导代码不同，总是有一个称为 EFI 系统分区 (ESP) 的特殊 VFAT 文件系统，其中包含一个名为 EFI 的目录。 
		ESP 通常安装在 Linux 系统的 /boot/efi 上，大部分 EFI 目录结构都从 /boot/efi/EFI 开始。每个引导加载程序都有自己的标识符和相应的子目录，例如 efi/microsoft、efi/apple、efi/ubuntu 或 efi/grub。 
		引导加载程序文件具有 .efi 扩展名，并与其他支持文件一起驻留在这些子目录之一中。还有 grubx64.efi（GRUB 的 EFI 版本）和 shimx64.efi 等文件。
		》注意：
			ESP与BIOS引导分区不同，并且具有不同的UUID。不应该遇到同时具有这两者的系统。
		不能将旧的引导加载程序代码放入ESP中（旧代码是为BIOS接口编写的）。必须提供为UEFI编写的引导加载程序。如，使用GRUB时，必须安装UEFI版本的GRUB，而不是BIOS版本。而且，必须向固件宣告新的引导加载程序。
	Ⅲ	GRUB工作方式
		①	PC BIOS 或固件初始化硬件并在其引导顺序存储设备中搜索引导代码
		②	找到启动代码后，BIOS/固件就会加载并执行它【这是GRUB开始的地方】
		③	GRUB 核心加载
		④	核心初始化。现在，GRUB可以访问磁盘和文件系统
		⑤	GRUB识别其引导分区并在其中加载配置
		⑥	GRUB给用户机会来更改配置
		⑦	超时或用户操作后，GRUB执行配置（grub.cfg文件中的命令序列）
		⑧	在执行配置的过程中，GRUB可能会在引导分区中加载额外的代码（模块）。其中一些模块可能是预加载的。
		⑨	GRUB执行引导命令来加载并执行配置的Linux命令指定的内核
		由于传统 PC 引导机制的不足，该序列的第 3 步和第 4 步（即 GRUB 核心加载）可能会很复杂。 最大的问题是“GRUB 核心在哪里？” 存在三种基本的可能性：
			》部分填充在MBR和第一个分区的开头之间
			》在一个常规分区
			》在一个特殊的引导分区：一个GPT引导分区，ESP，或其他地方
		在所有情况下，除了拥有UEFI/ESP的情况外，PC BIOS 都会从MBR加载512字节，这就是GRUB启动的地方。这个小片段（源自GRUB目录中的boot.img）还不是核心，但它包含核心的起始位置并从该点加载核心。
		但是，如果有ESP，则GRUB核心会作为文件存在。固件可以导航ESP并直接执行所有GRUB或位于其中的任何其他操作系统加载程序。（可能在ESP中有一个垫片，它位于GRUB之前来处理安全引导，但想法是相同的）
		在大多数系统上，这并不是完整的情况。在加载和执行内核之前，引导加载程序可能还需要将初始化RAM文件系统镜像加载到内存中。这就是 initrd 配置参数指定的内容。


How User Space Starts
	内核启动init（第一个用户空间进程）这一点非常重要——不仅因为内存和CPU最终准备好进行正常的系统操作，还因为在这里可以看到系统的其余部分如何构建为整体。
	在此之前，内核遵循由相对少数的软件开发人员定义的受控良好的执行路径。用户空间更加模块化和可定制，而且也很容易看到用户空间启动和操作的内容。
	用户空间启动大致按以下顺序启动：
		①	init
		②	基本的底层服务，如udevd和syslogd
		③	网络配置
		④	中层和高层服务（cron，打印，等）
		⑤	登录提示符，GUIs，高层应用程序（如，web服务器）
1、init介绍
	init是一个用户空间程序，可以在/sbin中找到它以及许多其他系统二进制文件。其主要目的是启动和停止系统上的基本服务进程。在主要Linux发行版的所有当前版本中，init的标准实现是 systemd 。
	在较旧的系统上可能会遇到另外两种类型的init。System V init是传统的顺序init（Sys V，通常发音为“sys-5”，起源于 Unix System V），可在7.0版本之前的 RHEL 和 Debian 8 上找到。Upstart 是 版本 15.04 之前的 Ubuntu 发行版。
	存在其他版本的init，尤其是在嵌入式平台上。BSD也有自己的init版本。
	为了解决 System V init中的几个缺点，开发了不同的init实现。要理解这些问题，考虑传统init的内部工作原理。它基本上是 init 按顺序运行的一系列脚本。每个脚本通常启动一项服务或配置系统的一个单独部分。
	在大多数情况下，解决依赖关系相对容易，而且通过修改脚本可以非常灵活地适应不寻常地启动要求。
	然而，该方案存在一些重大限制。这些可以分为“性能问题”和“系统管理麻烦”。其中最重要的如下：
		①	引导序列的两个部分无法正常同时运行，性能受到影响
		②	管理正在运行的系统可能很困难。启动脚本预计会启动服务守护进程。要查找服务守护进程的PID，需要使用ps、特定于该服务的其他一些机制，或记录PID的半标准化系统（如，/var/run/myservice.pid）。
		③	启动脚本往往包含许多标准的“样板”代码，有时很难阅读和理解它们的作用。
		④	几乎没有按需服务和配置的概念。大多数服务在启动时启动；系统配置也很大程度上是在那时确定的。传统的 inetd 守护进程曾经能够处理按需网络服务，但它基本上已经不再使用。
	现代 init 系统通过改变服务的启动方式、监管方式以及依赖关系的配置方式来解决这些问题
2、识别 init
	确定系统的init版本通常并不困难。查看 init(1)【man init】手册页通常会立即告知，但如果不确定，按如下方式检查系统：
		①	如果系统上有 /usr/lib/systemd 和 /etc/systemd 目录，使用 systemd
		②	如果有一个/etc/init 目录，其中包含多个 .conf 文件，可能运行Upstart（除非运行的是Debian7或更早版本，在这种情况下可能有System V init）。
		③	如果以上情况均不成立，但有 /etc/inittab 文件，可能运行 System V init。
3、systemd
	systemd init 是 Linux上最新的init实现之一。除了处理常规启动过程之外，systemd还旨在整合许多标准Unix服务的功能，如cron和inetd。
	systemd 真正从其前辈中脱颖而出的是其先进的服务管理功能。与传统 init 不同，systemd可以在各个服务守护进程启动后对其进行跟踪，并将与服务关联的多个进程组合在一起，从而提供更多功能并深入了解系统上正在运行的内容。
	systemd 是面向目标【target】的。在顶层，可以考虑为某些系统任务定义一个目标，成为单元【unit】。一个单元可以包含常见启动任务的指令，如启动守护程序，并且它还具有依赖项，即其他单元。
	当启动（或激活）一个单元时，systemd会尝试激活其他依赖项，然后继续处理该单元的详细信息。当启动服务时，systemd并不遵循严格的顺序；相反，它会在单元准备好时激活它们，启动后，systemd可以通过激活其他单元来对系统事件做出响应。
	Ⅰ	单元和单元类型
		systemd 不仅操作进程和服务，它还可以管理文件系统挂载、监视网络连接请求、运行计时器等。每个能力称为单元类型，每个特定功能（如服务）称为单元。当打开一个单元时，就激活了它。每个单元都有自己的配置文件。
		以下是典型Linux系统上执行启动时任务的最重要的单元类型：
			①	Service units		控制在Unix系统上发现的服务守护进程
			②	Target units		控制其他单元，通常通过将它们分组
			③	Socket units		表示传入网络连接请求的位置
			④	Mount units			表示文件系统与系统的连接

		》注意：可以在 systemd(1)手册页中找到单元类型的完整列表
		其中，服务和目标单元是最常见且最容易理解的。
	Ⅱ	引导【booting】和单元依赖图
		当启动系统时，将激活一个默认单元，通常是一个名为 default.target 的目标单元，它将许多服务和挂载单元组合在一起作为依赖项。因此，可以很容易地了解启动时将发生的情况。
		可能期望单元依赖关系形成一棵树——顶部是一个单元，在启动过程的后续阶段分支为下面的几个单元——但它们实际上形成了一个图。
		启动过程中较晚出现的单元可能依赖于多个先前的单元，从而使依赖树的较早分支重新连接在一起。甚至可以使用 systemd-analyze dot 命令创建依赖关系图。整个图表在典型系统上相当大，有一些方法可以过滤单元并将各个部分归零。
		在大多数系统上，default.target 是指向其他一些高级目标单元的链接（如，代表用户界面启动的单元）。default.target 对启动 GUI所需的单元进行分组，如：
									default.target
										|
										↓
									multi-user.target
									        |
							|———————————————|——————————————|
							↓	     		↓              ↓
					  basic.target    cron.service     dbus.service
						    |
							↓
					sysinit.target
		这里是一个简化的视图。在自己的系统上，会发现仅通过查看顶部的单元配置文件并向下进行工作来勾勒处依赖关系是不可行的。
	Ⅲ	systemd 配置
		systemd 配置文件分布在系统中的许多目录中，因此当查找特定文件时可能需要进行一些搜索。
		systemd配置有两个主要目录：系统单元目录（全局配置；通常为/lib/systemd/system 或 /usr/lib/systemd/system）和系统配置目录（本地定义；通常为/etc/systemd/system）。
		为了防止混淆，应遵守以下规则：避免更改系统单元目录（发行版会维护它）。对系统配置目录进行本地更改。这个一般规则也适用于整个系统。当要选择修改/usr和/etc中的某些内容时，务必更改/etc。
		可以使用以下命令检查当前的 systemd 配置搜索路径（包括优先级），如：
			# systemctl -p UnitPath show
			UnitPath=/etc/systemd/system.control /run/systemd/system.control /run/systemd/transient /run/systemd/generator.early /etc/systemd/system /etc/systemd/system.attached /run/systemd/system /run/systemd/system.attached /run/systemd
		要查看系统上的系统单元和配置目录，使用以下命令：
			# pkg-config systemd --variable=systemdsystemunitdir
			/usr/lib/systemd/system
			# pkg-config systemd --variable=systemdsystemconfdir
			/etc/systemd/system
		①	单元文件
			单元文件的格式源自XDG Desktop Entry 规范（用于 .desktop 文件）。节【section】名称位于方括号（[]）中，变量和值分配（选项）在每个section。如（桌面总线守护程序的dbus-daemon.service单元文件）：
				[Unit]
				Description=D-Bus System Message Bus
				Documentation=man:dbus-daemon(1)
				Requires=dbus.socket
				RefuseManualStart=yes

				[Service]
				ExecStart=/usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
				ExecReload=/usr/bin/dbus-send --print-reply --system --type=method_call --dest=org.freedesktop.DBus / org.freedesktop.DBus.ReloadConfig
			这里有两个节【section】（[Unit] 和 [Service]）。[Unit] 提供了有关单元的一些详细信息，并包含描述和依赖关系信息。特别是，该单元需要dbus.socket单元作为依赖项。
			在这样的服务单元中，可以在 [Service] 找到有关服务的详细信息，包括如何准备、启动和重新加载服务。可以在 systemd.service(5) 和 systemd.exec(5) 手册页找到完整的列表。
			许多其他单元配置文件也同样简单。如，服务单元文件 sshd.service 通过启动 sshd 来启用远程安全 shell 登录。
		②	变量
			可以在单元文件中找到变量。这是另一个单元文件的一部分，如：
				[Service]
				EnvironmentFile=/etc/sysconfig/sshd
				ExecStartPre=/usr/sbin/sshd-keygen
				ExecStart=/usr/sbin/sshd -D $OPTIONS $CRYPTO_POLICY
				ExecReload=/bin/kill -HUP $MAINPID
			任何以 $ 开头的都是变量。尽管这些变量具有相同的语法，但其来源不同。$OPTIONS 和 $CRYPTO_POLICY 选项可在单元激活时传递给sshd，它们是在EnvironmentFile 设置指定的文件中定义的。
			在这里，可查看 /etc/sysconfig/sshd 以确定是否设置了变量。
			相比之下，$MAINPID 包含服务的跟踪进程的ID。单元激活后，systemd 会记录并存储此PID，以便稍后可以使用它来操作特定于服务的进程。
			当想要重新加载配置时，sshd.service 单元文件使用$MAINPID 向 sshd 发下哦那个挂断（HUP）信号（这是处理重新加载和重新启动Unix守护进程的一种非常常见的技术）。
		③	说明符【specifiers】
			说明符是单元文件中常见的类似变量的功能。说明符以百分号（%）开头。如，%n说明符是当前单元名称，%H是当前主机名。
			还可以使用说明符从单个单元文件创建单元的多个副本。一个示例是一组getty进程，用于控制虚拟控制台上的登录提示，如tty1和tty2。要使用此功能，在单元名称末尾、单元文件名中的点之前添加@符号。
			如，在大多数发行版中，getty单元文件是getty@.service，允许动态创建单元，如getty@tty1 和 getty@tty2。@之后的任何内容都称为实例。当查看这些单元文件之一时，可能还看到%I和%i说明符。
			当从带有实例的单元文件激活服务时，systemd会将%I或%i说明符替换为实例以创建新的服务名称。
		④	systemd 操作
			主要通过 systemctl 与 systemd 进行交互，该命令允许激活和停用服务、列出状态、重新加载配置等。
			最基本的命令可以帮助获取单元信息。如，要查看系统上活动单元的列表，发出 list-units 命令（这是 systemctl 的默认命令，因此从技术上讲，不需要 list-units 参数）。如：
				# systemctl list-units
			输出格式是典型的Unix信息列表命令。默认，systemctl list-units 会产生大量输出，因为典型的系统有许多活动单元，但它仍是一种缩写形式，因为systemctl会截断任何非常大的单元名称。
			要查看单元的全名，使用 --full 选项，要查看所有单元单元（不仅仅是活动的单元），使用 --all 选项。
			一个特别有用的systemctl 操作是获取特定单元的状态。如：
				# systemctl status sshd.service
			输出还可能有许多日志消息。不仅可以获得设备的状态，还可以获得与服务关联的进程、设备启动时的信息以及大量日志消息（如果有）。输出中一个有趣的部分是控制组（cgroup）名称，cgroup中的进程显示在其下方。
			可以使用 systemd-cgls 命令查看与systemd相关的cgroup，而无需查看其余单元状态。
			status 命令还显示设备的最新诊断日志消息。可以通过以下方式查看某个单元的所有消息：
				# journalctl --unit=unit_name
				# journalctl --unit=sshd
			》作业【jobs】与启动、停止和重新加载单元有何关系
				要激活、停用和重新启动单元，使用 systemctl start、systemctl stop 和 systemctl restart 。如果更改了单元配置文件，可以告诉 systemd 通过以下两种方式之一重新加载该文件：
					systemctl reload unit			仅重新加载单元的配置
					systemctl daemon-reload			重新加载所有单元的配置
				激活、重新激活和重新启动单元的请求在 systemd 中称为作业【jobs】，它们本质上是单元状态更改。可以使用以下命令检查系统上当前的作业：
					# systemctl list-jobs
				如果系统已经运行一段时间，可以合理地预期不会有任何活动作业（启动系统所需的所有激活都应该已完成）。
			》给systemd添加单元
				向 systemd 添加单元主要是创建、然后激活并可能启用单元文件。通常应该将自己的单元文件放在系统配置目录（/etc/systemd/system）中，这样就不会将它们与发行版附带的任何内容混淆，并且发行版在升级时也不会覆盖它们。
				创建实际上不执行任何操作或不干扰系统的目标单元很容易。要创建两个目标，其中一个目标依赖于另一个目标，按以下步骤操作：
					①	在/etc/systemd/system中创建名为 test1.target 的单元文件：
						[Unit]
						Description=test 1
					②	创建依赖 test1.target 的 test2.target:
						[Unit]
						Description=test 2
						Wants=test1.target
					Wants 关键字定义了一个依赖项，当激活 test2.target 时，该依赖项会导致 test1.target 被激活。激活【start】 test2.target 单元已查看其运行情况下：
						# systemctl start test2.target
					③	验证单元是否激活：
						# systemctl status test1.target test2.target
					④	如果单元文件有[install] section，需要在激活【start】它之前“启用【enable】”该单元。
						# systemctl enable unit
			》从 systemd 中移除单元
				要移除单元，进行以下步骤：
					①	如有必要，停用该单元：
						# systemctl stop unit
					②	如果单元有 [Install] section ，禁用【disable】该单元已删除依赖系统创建的任何符号链接：
						# systemctl disable unit
					如果愿意，可以删除该单元文件
			》注意：禁用【disable】隐式启用的单元（即没有[Install]）没有任何效果。
		⑤	systemd 进程跟踪和同步
			systemd 希望获得合理数量的信息并控制它启动的每个进程。这在历史上是很难的。服务可以通过不同的方式启动；它可以派生出自己的新实例，甚至可以进行守护进程并将其自身与原始进程分离。也不知道服务器可以生成多少个子进程。
			为了轻松管理激活的单元，systemd使用cgroup，这是一种Linux内核功能，可以更精细地跟踪进程层次结构。使用cgroup还有助于最大限度地减少包开发人员或管理员创建工作单元所需的工作。
			在systemd中，不必担心考虑每种可能的启动行为；只需知道服务启动进程是否分叉即可。使用服务单元文件中的“Type”选项来指示启动行为。有两种基本的启动方式：
				Type=simple		服务进程不会交叉【fork】和终止【terminate】；它仍然是主要的服务流程。
				Type=forking	服务交叉，systemd期望原始服务进程终止。终止后，systemd 假定服务已准备就绪。
			Type=simple 选项没有考虑到服务可能需要一些时间来启动这一事实，因此systemd不知道何时启动任何绝对需要此类服务准备就绪的依赖单元。解决这个问题的一种方法是使用延迟启动。
			但，某些Type启动样式可以指示服务本身将在准备就绪时通知systemd：
				Type=notify		准备就绪后，该服务会通过特殊函数调用发送特定于systemd的通知
				Type=dbus		准备就绪后，服务将自身注册到D-Bus（桌面总线）上
			另一种服务启动方式通过 Type=oneshot指定；这里服务进程完成终止，启动后没有子进程。就像 Type=simple 一样，只不过 systemd直到服务进程终止才认为服务已启动。任何严格的依赖关系在终止之前都不会启动。
			使用 Type=oneshot 的服务还会获得默认的RemainAfterExit=yes 指令，以便systemd即使在进程终止后也会将服务视为活动状态。
			最后一个选项是 Type=idle 。这与simple风格类似，但它指示systemd在所有活动作业完成之前不要启动服务。这里的想法只是延迟服务启动，直到其他服务开始阻止服务相互影响输出。
			一旦服务启动，启动它的systemd作业就会终止，因此等待所有其他作业完成可确保没有其他作业启动。
		⑥	systemd 依赖
			一个针对启动时间和操作依赖性的灵活系统需要一定程度的复杂性，因为过于严格的规则可能会导致系统性能不佳和不稳定。 
			例如，假设希望在启动数据库服务器后显示登录提示，因此定义从登录提示到数据库服务器的严格依赖关系。这意味着如果数据库服务器出现故障，登录提示也会失败，甚至无法登录到您的计算机来解决问题！
			Unix启动时任务具有相当的容错能力，并且经常会失败，而不会导致标准服务出现严重问题。如，如果删除了系统的数据磁盘，但保留了其/etc/fstab 条目（或systemd中的挂载单元），则引导时文件系统挂载将失败。
			尽管此故障可能会影响应用程序服务器（如web服务器），但通常不会影响标准系统操作。
			为了满足灵活性和容错的需求，systemd提供了多种依赖类型和样式：
				Requires		严格的依赖关系。当激活带有 Requires 依赖单元的单元时，systemd会尝试激活依赖单元。如果依赖单元发生故障，systemd也会停用该依赖单元。
				Wants			仅用于激活的依赖项。激活一个单元后，systemd会激活该单元的Wants依赖项，但它并不关心这些依赖项是否失败。
				Requisite		必须已经处于活动状态的单位。在激活具有Requisite依赖项的单元之前，systemd首先检查依赖项的状态。如果尚未激活依赖项，则systemd激活具有依赖项的单元时会失败。
				Conflicts		负依赖。当激活具有冲突依赖项的单元时，systemd会自动停用相反的依赖项（如果它处于活动状态）。同时激活冲突单位失败。
			Wants 依赖项类型特别重要（它不会将故障传播到其他单元）。systemd.service(5)手册页指出，如果可能的话，应该这样指定依赖项，并且很容易理解原因。
			这种行为会产生一个更加健壮的系统，让您受益于传统init，其中早期启动组件的失败并不一定会阻止后续组件的启动。
			可以使用 systemctl 命令查看单元的依赖关系，只要指定依赖关系的类型，如Wants或Requeires：
				# systemctl show -p type unit
				# systemctl show -p Wants sshd
				Wants=sshd-keygen.target
				# systemctl show -p Requires sshd
				Requires=system.slice sysinit.target
			》顺序【Ordering】
				要按特定顺序激活单元，使用以下依赖修改器：
					Before		当前单元将在列出的单元之前激活。如，如果 Before=bar.target 出现在 foo.target 中，则systemd会在bar.target之前激活foo.target。
					After		当前单元在列出的单元之后激活
				当使用排序时，systemd会等到一个单元处于活动状态，然后再激活其依赖单元【dependent units】。
			》默认和隐式依赖关系
				可能会出现某些单元获取单元文件或其他可见机制中未明确说明的依赖项。最有可能在具有Wants依赖关系的目标单元中遇到这种情况。systemd在任何列为Wants依赖项的单元旁边添加一个After修饰符。
				这些额外的依赖项是systemd的内部依赖项，在启动时计算，并且不存储在配置文件中。
				添加的After修饰符称为默认依赖项，自动添加到单元配置中，旨在避免常见错误并保持单元文件大小。这些依赖性根据单元的类型而变化。
				如，systemd不会为目标单元添加与服务单元相同的默认依赖项。这些差异在单元配置手册页的DEFAULT DEPENDENCIES 部分中，如 systemd.service(5)和systemd.target(5)。
				可以通过将 DefualtDependency=no 添加到其配置文件来禁用单元中的默认依赖项。
			》条件依赖项
				可以使用多个条件依赖参数来测试各种操作系统状态而不是 systemd 单元，如：
					ConditionPathExists=p			如果系统上存在（文件）路径 p ，则为True
					ConditionPathIsDirectory=p		如果 p 是目录，则为True
					ConditionFileNotEmpty=p			如果 p 为非零长度文件，则为True
				当systemd尝试激活单元时，如果单元中的条件依赖为False，则该单元不会激活，尽管这仅适用于它出现的单元。
				也就是说，如果激活一个具有条件依赖项和某些单元依赖项的单元，无论条件为真还是假，systemd都会尝试激活这些单元依赖项。
				其他依赖项主要是前面依赖项的变体。如，RequiresOverridable 依赖项在正常运行时就像Requires一样，但如果手动激活单元，它的作用就像Wants依赖项。
				有关完整列表，参见 systemd.unit(5) 手册页。
			》[Install] section 和启用单元
			 	除了在依赖单元的单元文件中定义依赖关系，也可“反向”执行此操作，即通过在依赖项的单元文件中指定依赖单元。可以通过在[Install] 中的WantedBy 或RequiredBy 参数来完成此操作。
				这种机制允许更改单元何时启动，而无需修改其他配置文件（如，当不想编辑系统单元文件时）。
				如，有两个单元，test1.target 和 test2.target ，其中 test2.target 对 test1.target 有 Wants 依赖。可以更改它们，test1.target 如下：
					[Unit]
					Description=test 1

					[Install]
					WantedBy=test2.target

				test2.target 如下：
					[Unit]
					Description=test 2
				因为有一个带有 [Install] 的单元，所以需要先使用 systemctl 启用该单元，然后才能启动它。以下是 test1.target的工作原理：
					# systemctl enable test1.target
					Created symlink /etc/systemd/system/test2.target.wants/test1.target → /etc/systemd/system/test1.target.
				这里启用【enable】单元的效果是在与依赖单元（如，test2.target）相对应的 .wants 子目录中创建符号链接。现在，可以使用 systemctl start test2.target 同时启动两个单元（因为依赖关系已就位）。
				》注意：启用单元不会激活它。
				要禁用单元（和移除符号链接），systemctl 使用方式如下：
					# systemctl disable test1.target
					Removed /etc/systemd/system/test2.target.wants/test1.target.
				在正常操作期间，systemd会忽略单元中的[Install]部分，但会注意到它的存在，并且默认情况下会认为该单元已禁用。启用单元在重新启动后仍有效。
				[Install]通常负责系统配置目录（/etc/systemd/system）中的 .wants 和 .requires 目录。但是，单元配置目录（[/usr]/lib/systemd/system）还包含 .wants 目录，并且还可以添加与单元文件中的[Install]不对应的链接。
				这些手动添加是添加依赖项的简单方法，无需修改将来可能被覆盖的单元文件（如，通过软件升级），但并不特别鼓励这样，因为手动添加很难跟踪。
		⑦	systemd on-Demand and Resource-Parallelized【按需和资源并行启动】
				systemd 的功能之一是能够延迟单元启动，直到绝对需要为止。该设置通常如下所示：
					①	为想要提供的系统服务创建一个 systemd 单元（如，Unit A）
					②	确定单元 A 用于提供服务的系统资源，如网络端口/套接字、文件或设备
					③	创建另一个 systemd 单元（Unit R）来表示该资源。这些单元分为多种类型，如套接字单元、路径单元和设备单元。
					④	定义单元A和单元R之间的关系。通常，这是基于单元名称隐式的，但也可以是显式的。
				一旦就位，操作将按如下方式进行：
					①	激活 Unit R 后，systemd会监视资源。
					②	当任何东西尝试访问资源时，systemd会阻止该资源，并且资源的输入将被缓冲
					③	systemd激活 Unit A
					④	准备就绪后，Unit A 的服务将控制资源、读取缓冲的输入并正常运行
				这里有一些问题：
					①	必须确保资源单元覆盖服务提供的所有资源。这通常不是问题，因为大多数服务只有一个访问点。
					②	需要确保资源单元与其代表的服务单元相关联。这可以是隐式的或显式的，并且在某些情况下，许多选项代表 systemd 执行到服务单元的切换的不同方式。
					③	并非所有服务器都知道如何与 systemd 可以提供的资源单元进行交互。
				》Socket 单元和服务示例
					echo 服务的想法是重复网络客户端在连接后发送的任何内容；这里监听 TCP 端口 22222 。将开始使用 socket 单元来构建它来表示端口，如（echo.socket 单元文件）：
						[Unit]
						Description=echo socket

						[Socket]
						ListenStream=22222
						Accept=true
					注意，单元文件中没有提及该套接字支持的服务单元。它的名称是 echo@.service 。链接是按照命名约定建立的；如果服务单元文件与 .socket 文件具有相同的前缀（如，echo），
					则 systemd 知道当套接字单元上有活动时激活该服务单元。在这种情况下，当 echo.socket 上有活动时，systemd 会创建一个 echo@.service 实例。echo@.service 单元文件如下：
						[Unit]
						Description=echo service

						[Service]
						ExecStart=/bin/cat
						StandardInput=socket
				》注意：
					如果不喜欢根据前缀隐式激活单元，或需要链接具有不同前缀的单元，则可以在定义资源的单元中使用显式选项。如，在 foo.service 中使用 Socket=bar.socket 可以让 bar.socket 将其套接字交给 foo.service 。
				要运行此示例单元，需要启动 echo.socket 单元：
					# systemctl start echo.socket
				现在，可以通过使用 telnet 等连接到本地 TCP 端口 22222 来测试该服务。如：
					# telnet localhost 22222
					Trying ::1...
					Connected to localhost.
					Escape character is '^]'.
					Hi.
					Hi.
				》实例和切换
					因为 echo@.service 单元支持多个同时实例，所以名称中有一个@。为什么想要多个实例？假设有多个网络客户端同时连接到该服务，并且希望每个连接都有自己的实例。
					在这种情况下，服务必须支持多个实例，因为在echo.socket中包含了Accept=true选项。该选项指示systemd不仅监听端口，还代表服务单元接受传入并将其传递给它们，为每个连接创建一个单独的实例。
					每个实例都从连接读取数据作为标准输入，但它不一定需要知道数据来自网络连接。
				》注意：
					大多数网络连接需要更多的灵活性，而不仅仅是标准输入和输出的简单网关，因此不要期望能使用服务单元文件（如，echo@.service）创建复杂的网络服务。
				如果服务单元可以完成接受连接的工作，则不要在其单元文件名中放置@，并且不要在套接字单元中放置Accept=true。在这种情况下，服务单元从 systemd 完全控制套接字，而 systemd 在服务单元完成之前不会尝试再次侦听网络接口。
				许多不同的资源和切换【handoff】服务单元的选项使得很难提供分类总结。不仅如此，选项的文档还分布在多个手册页中。对于面向资源的单元，检查 systemd.socket(5)、systemd.path(5)和systemd.device(5)。
				服务单元经常被忽视的一个文档是 systemd.exec(5)，它包含有关服务单元在激活时如何期望接受资源的信息。
				》使用辅助单元进行启动优化
					systemd 的总体目标是简化依赖顺序并加快启动时间。诸如套接字单元之类的资源单元提供了一种类似于按需启动的方法。
					仍然会有一个服务单元和一个代表服务单元提供的资源的辅助单元，只不过在这种情况下，systemd在激活辅助单元后立即启动服务单元，而不是等待请求。
					采用此方案的原因是，诸如 systemd-journald.service 之类的基本启动时服务单元需要一些时间才能启动，并且许多其他单元都依赖于它们。
					然而，systemd 可以非常快速地提供一个单元（如，套接字单元）的基本资源，然后它不仅可以立即激活该基本单元，还可以立即激活依赖于它的任何单元。一旦基本单元准备就绪，它就会控制资源。
		⑧	systemd 辅助组件
			随着 systemd 的日益普及，它已经开始支持一些与启动和服务管理无关的任务，无论是直接支持还是通过辅助兼容层（/lib/systemd 中有许多程序，这些是与这些功能相关的可执行文件）。
			以下是一些指定系统服务：
				①	udevd		它是 systemd 的一部分
				②	journald	处理几种不同日志记录的日志记录服务，包括传统的Unix syslog服务。
				③	resolved	DNS名称服务缓存守护进程
			这些服务的所有可执行文件都以 system- 为前缀。如，systemd-integrated udevd 称为 systemd-udevd 。
			如果深入挖掘，会发现其中一些程序是相对简单的包装器。它们的功能是运行标准系统实用程序并将结果通知给 systemd。如，system-fsck。
			如果在/lib/systemd中看到无法识别的程序，检查是否有手册页。它很可能不仅描述实用程序，还描述它要增强的单元类型。
4、Systemd V 运行级别
	在Linux系统上的任何给定时间，一组特定的基本进程（如crond和udevd）都在运行。在System V init 中，机器的这种状态称为运行级别，用0到6之间的数字表示。
	系统大部分时间都处于单一运行级别，但是当关闭机器时，init会切换到一个运行级别，以便以有序的方式终止系统服务并告诉内核停止。
	可以运行 who -r 命令来检查系统的运行级别，如：
		# who -r
		         运行级别 3 2024-02-02 18:22
	运行级别有多种用途，但最常见的用途是区分系统启动、关闭、单用户模式和控制台模式状态。如，大多数传统上对文本控制台实用运行级别2到4；运行级别5表示系统启动GUI登录。
	但运行级别正在成为过去。尽管 systemd 支持它们，但它认为运行级别作为系统的最终状态已经过时，而是更喜欢目标单元。对于 systemd 来说，运行级别的存在主要是为了启动仅支持 System V 初始化脚本的服务。
5、System V init
	System V init 实现是Linux上最古老的实现之一。其核心思想是通过精心构建的启动序列支持有序启动到不同的运行级别。
	System V init 现在在大多数服务器和桌面安装中并常见，但可能会在 7.0 版之前的 RHEL 版本以及嵌入式 Linux 环境（例如路由器和电话）中遇到它。
	另外，一些较旧的软件包可能只提供为System V init 设计的启动脚本；systemd 可以实用兼容模式来处理这些问题。
6、关闭系统
	init 控制系统如何关闭和重新启动。无论运行哪个版本的init，关闭系统的命令是相同的。关闭Linux机器的正确方法是使用 shutdown 命令。
	使用 shutdown 有两种基本方法。如果停止系统，它会关闭机器并使其保持关闭状态。要使机器立即停止【halt】，运行以下命令：
		# shutdown -h now
	在大多数机器和Linux版本上，停止会切断机器的电源。也可以重新启动机器。要重新启动【reboot】，使用 -r 而不是 -h。
	关闭过程需要几秒钟。应该避免在关机期间重置或关闭机器。
	包含时间参数是强制性的，但有多种方法可以指定它。如，希望计算机在将来某个时间关闭，则可以使用n，其中n是在关闭之前应等待的分钟数。有关其他选项，见 shutdown(8)手册页。
	如，要使系统在10分钟内重新启动，输入：
		# shutdown -r 10
	在Linux上，关机会通知任何登录的用户机器即将关闭，但它几乎没有什么实际作用。如果指定的时间不是 now ，shutdown 会创建一个名为 /etc/nologin 文件。当此文件存在时，系统禁止除超级用户之外的任何人登录。
	当系统关闭时间最终到达时，shutdown告诉init开始shutdown进程。在systemd上，这意味着激活shutdown单元，在System V init上，这意味着将运行级别更改为0（停止）或6（重新启动）。
	无论init实现或配置如何，过程通常是这样的：
		①	init 要求每个进程彻底关闭
		②	如果进程在一段时间没有响应，init将杀死它，首先尝试TERM信号
		③	如果TERM信号不起作用，init将对任何落后者【tragglers】使用KILL信号
		④	系统将系统文件锁定到位并为shutdown做好其它准备。
		⑤	系统卸载除 root 之外的所有文件系统
		⑥	系统以只读方式重新挂载 root 文件系统
		⑦	系统使用同步程序将所有缓冲数据写入文件系统
		⑧	最后一步是通过 reboot(2)系统调用告诉内核重新启动或停止。这可以通过init 或辅助程序（如，reboot、halt 或 poweroff）来完成。
	reboot 或 halt 程序的行为取决于它们的调用方式，这可能会导致混乱。默认，这些程序使用 -r 或 -h 选项 shutdown。但是，如果系统已经处于halt 或 reboot 运行级别，程序会告诉内核立即关闭自身。
	如果确实项快速关闭计算机，无论无序关闭可能造成任何潜在损害，使用 -f （force）选项。
7、初始 RAM 文件系统
	大多数情况下，Linux启动过程相当简单。但有一个组件总是有些令人困惑：initramfs，即初始RAM文件系统。将其视为位于正常用户模式启动之前的一个小用户空间楔子。首先谈论其为何存在。
	该问题源于许多不同类型的存储硬件的可用性。Linux内核不会与PC BIOS 接口或 EFI 通信以从磁盘获取数据，因此为了挂载其root文件系统，它需要底层存储机制的驱动程序支持。
	如，如果root位于连接到第三方控制器的RAID阵列上，则内核首先需要该控制器的驱动程序。不幸的是，存储控制器驱动程序太多，发行版无法将所有驱动程序都包含在内核中，因此许多驱动程序作为可加载模块提供。
	但是可加载模块是文件，如果内核首先没有挂载文件系统，则它无法加载所需的驱动程序模块。
	解决方法是将一小部分内核驱动程序模块以及一些其他实用程序收集到归档中。引导加载程序在运行内核之前将此归档加载到内存中。
	启动时，内核将归档的内容读入临时RAM文件系统（initramfs），将其挂载在/处，然后将用户模式切换到initramfs上的init。然后，initramfs中包含的实用程序允许内核为真正的root文件系统加载必要的驱动程序模块。
	最后，实用程序挂载真正的根文件系统并启动真正的init。
	实施方式各不相同并且不断发展。在某些发行版上，initramfs 上的init是一个相当简单的shell脚本（它启动udevd来加载驱动程序，然后挂载真正的根目录并在那里执行init）。
	在使用 systemd 的发行版上，通常会看到整个 systemd 安装，没有单元配置文件，只有一些 udevd 配置文件。
	初始 RAM 文件系统的一个基本特征自诞生以来移至保持不变，那就是在不需要时可以绕开它。也就是说，如果内核具有挂载根文件系统所需的所有驱动程序，则可以在引导加载程序配置中省略初始RAM文件系统。
	成功后，消除初始RAM文件系统会稍微缩短启动时间。可以进行尝试（在引导时，使用GRUB菜单编辑器删除 initrd 行）。
	注意，最好不要通过更改GRUB配置文件进行试验，因为可能会犯下难以修复的错误。由于诸如mount-by-UUID之类的功能，绕过初始RAM文件系统已逐渐变得更加困难，可能不适用于通用发行版内核。
	可以检查初始RAM文件系统的内容，但需要做一些侦探工作。现在大多数系统都使用 mkinitramfs 创建的归档，可以使用 unmkinitramfs 解压这些归档。其他可能是较旧的cpio归档。
	一个特别有趣的部分是初始RAM文件系统上init进程最后的“pivot【枢轴】”。这部分负责删除临时文件系统的内容（以节省内存）并永久切换到真实root。
	通常不会创建自己的初始RAM文件系统，因为这是一个艰苦的过程。有许多实用程序可用于创建初始 RAM 文件系统映像，您的发行版可能附带一个实用程序。 最常见的两个是 mkinitramfs 和 dracut。
	》注意：
		术语“初始 RAM 文件系统（initramfs）”是指使用cpio归档作为临时文件系统源的实现。有一个称为初始RAM磁盘或initrd的旧版本，它使用磁盘镜像作为临时文件系统的基础。它已被废弃，因为维护cpio归档要容易得多。
		经常会看到术语“initrd”用于指代基于cpio的初始RAM文件系统。通常，文件名和配置文件仍然会包含initrd。
8、紧急启动和单用户模式
	当系统出现问题时，第一个办法通常是使用发行版的“live”镜像或专用的救援镜像（如，可以放在可移动介质上的SystemRescueCD）来启动系统。
	live镜像只是一个无需安装过程即可启动和运行的Linux系统；大多数发行版的安装镜像兼作live镜像。修复系统的常见任务包括以下内容：
		①	系统崩溃后检查文件系统
		②	重置忘记的密码
		③	修复关键文件中的问题，如/etc/fstab和/etc/passwd
		④	系统崩溃后从备份中恢复
	快速启动到可用状态的另一个选项是单用户模式。这个想法是系统快速启动到root shell，而不是经历整个混乱的服务。在System V init 中，单用户模式通常是运行级别1。在systemd中，它由rescue.target表示。
	通常，可以使用引导加载程序的 -s 参数进入该模式。可能需要root密码才能进入单用户模式。
	单用户模式的最大问题是它不提供很多便利设施。网络几乎肯定不可用（如果可用，将很难使用），没有 GUI，终端甚至可能无法正常工作。 因此，live镜像几乎总是被认为是更可取的。


System Configuration：Logging，System Time，Batch Jobs，And Users
1、系统日志
	大多数系统程序将其诊断输出作为消息写入 syslog 服务。传统的 syslogd 守护进程通过等待消息并在收到消息后将其发送到适当的通道（如文件或数据库）来执行此服务。
	在大多数现代系统上，journald （随 systemd 一起提供）完成了大部分工作。
	系统日志记录器是系统最重要的部分之一。当出现问题并且不知道从哪里开始时，检查日志是最明智的。如果有 journald ，则可以使用 journalctl 命令来执行此操作。在较旧的系统上，需要检查文件本身。
	日志消息通常包含重要信息，例如进程名称、进程 ID 和时间戳。 还可以有其他两个字段：设施【facility】（一般类别）和严重性【severity】（消息的紧急程度）。
	由于新旧软件组件的组合多种多样，了解 Linux 系统中的日志记录可能会有些困难。 一些发行版（例如 Fedora）已转为默认的journald-only，其他发行版则与journald一起运行较旧的 syslogd 版本（例如 rsyslogd）。 
	较旧的发行版和某些专用系统可能根本不使用 systemd，并且只有 syslogd 版本之一。 此外，一些软件系统完全绕过标准化日志记录并编写自己的日志记录。
	Ⅰ	检查日志设置
		应该检查系统上已安装了哪种类型的日志记录，如：
			①	检查 journald ，如果正在运行 systemd ，几乎肯定有它。尽管可以在进程列表中查找 journald，但最简单的方法是简单地运行 journalctl。如果日志在系统上处于活动状态，将获得日志消息的分页列表。
			②	查看 rsyslogd ，在进程列表中查看 rsyslogd ，然后查找 /etc/rsyslog.conf
			③	如果没有 rsyslogd ，通过查找名为 /etc/syslog-ng 的目录来检查 syslog-ng（ syslogd 的另一个版本）
		通过在 /var/log 中查找日志文件进行继续。如果有 syslogd 版本，则此目录应包含许多文件，其中大部分是由 syslog 守护程序创建的。
		这里会有一些由其他服务维护的文件； wtmp 和lastlog 是两个示例，last 和lastlog 等实用程序访问这些日志文件以获取登录记录。
		此外，/var/log 中可能还有包含日志的子目录。这些几乎总是来自其他服务。其中之一是/var/log/journal，是 journald 存储其（二进制）日志文件的位置。
	Ⅱ	搜索和监控日志
		除非系统没有 journald，或正在搜索由其他实用程序维护的日志文件，将查看日志【journal】。如果没有参数，journalctl 提供日志中的所有消息，从最旧的开始。
		journalctl 默认使用 pager（如less）来显式消息。可以使用pager来搜索消息并使用 journalctl -r 反转消息时间顺序。
		》注意：
			要获得对日志消息的完全访问权限，需要以root身份或属于adm 或 systemd-journal 组的用户身份运行 journalctl 。
		一般，只需将journal的各个字段添加到命令行即可搜索它们；如，运行 journalctl _PID=8792 来搜索来自进程ID 8792 的消息。最强大的过滤功能更通用。如果需要多个条件，可以指定一个或多个条件。
			①	以时间进行过滤
				-S（since）选项是缩小特定时间范围最有用的选项之一。如：
					# journalctl -S -4h			# 在当前时区搜索过去4小时的消息
				可以指定日期和/或时间的组合，如：
					# journalctl -S 06:00:00
					# journalctl -S 2020-01-14
					# journalctl -S '2020-01-14 14:30:00'
				-U（until）选项的工作方式相同，指定 journalctl 检索消息的截至时间。它通常没有那么有用，因为通常会翻页或搜索消息，直到找到所需的内容，然后退出。
			②	以单元进行过滤
				获取相关日志的另一种快速有效的方法是按 systemd 单元进行过滤。可以使用 -u 选项来执行此操作。如：
					# journalctl -u cron.service
				按单位过滤时，通常可以省略单位类型（如，.service）
				如果不知道特定单元的名称，尝试使用如下命令列出日志中的所有单元：
					# journalctl -F _SYSTEMD_UNIT
				-F 选项显式日志中特定字段的所有值。
			③	查找字段
				有时，只需要知道要搜索哪个字段。可以列出所有可用字段，如：
					# journalctl -N
				任何以下划线开头的字段（如，_SYSTEMD_UNIT）都是可信字段；发送消息的客户端无法更改这些字段。
			④	通过文本过滤
				搜索日志文件的经典方法是对所有日志文件运行grep，希望找到文件中可能包含更多信息的相关行或位置。同样，可以使用-g选项通过正则表达式搜索日志消息。如：
					# journalctl -g 'kernel.*memory'
				当以这种方式搜索日志时，只能得到与表达式匹配的消息。通常，重要信息可能就时间而言就在附近。尝试从匹配中找出时间戳，然后使用之前的时间运行 journalctl -S，，以查看同一时间发出的消息。
				》注意
					-g 选项需要使用特定库构建 journalctl 。某些发行版不支持 -g 的。
			⑤	按 boot 过滤
				通常，会发现在计算机启动时或停机（并重新启动）之前查看日志以查找消息。从机器启动到停止，只需一次启动即可轻松获取消息。如，如果正在查找当前启动的开始位置，只需使用 -b 选项：
					# journalctl -b
				还可以添加偏移量，如，要从上次引导开始，使用偏移量 -1 ，如：
					# journalctl -b -1
				》注意：
					可以通过组合 -b 和 -r（reverse）选项来快速检查机器是否在最后一个周期完全关闭。
				还可以通过ID查看boots，而不是像 -1 这样的偏移量。运行以下命令获取启动ID：
					# journalctl --list-boots
					IDX BOOT ID                          FIRST ENTRY                 LAST ENTRY                 
					  0 d5afd95a86dd4f12aadff68df9c53199 Sat 2024-02-03 18:37:50 CST Sat 2024-02-03 20:50:53 CST
				可以使用 journalctl -k 显式内核消息（无论是否选择特定引导）。
			⑥	按严重性/优先级过滤
				某些程序会产生大量诊断消息，这些消息可能会覆盖重要日志。可以通过 -p 选项指定 0（最重要）和7（最不重要）之间的值来按严重性级别进行过滤。如，要获取级别0到3的日志：
					# journalctl -p 3
				如果只需一组特定严重性级别的日志，使用 .. range 语法。如：
					# journalctl -p 2..3
				按严重性过滤听起来可能会节省大量时间，但可能会法相它没有多大用处。大多数应用程序默认不会生成大量信息数据，尽管有些应用程序包含配置选项以启用更详细的日志记录。
			⑦	简单日志监控
				监视日志的一种传统方法是在日志文件上使用 tail -f 或 less follow 模式（less F）来查看从系统记录器到达的最新日志。
				这不是一种非常有效的常规系统监控实践（很容易错过某些东西），但是当试图查找问题或实时仔细查看启动和操作时，它对于检查服务很有用。
				使用 tail -f 不适用于日志，因为它不使用纯文本文件；相反，可以使用 journalctl 的 -f 选项来产生与日志到达时打印日志相同的效果：
					# journalctl -f
				这个简单的调用足以满足大多数需求。但如果系统有相当稳定的日志消息流，与要查找的内容无关，可能需要添加一些过滤选项。
	Ⅲ	日志文件轮询
		当使用系统日志守护程序【syslog daemon】时，系统记录的任何日志消息都会进入日志文件中的某个位置，这意味着需要偶尔删除旧消息，以免它们最终耗尽您的所有存储空间。
		不同的发行版以不同的方式执行此操作，但大多数都使用 logrotate 实用程序。
		该机制称为日志轮转。由于传统的文本日志文件在开头包含最旧的消息，在结尾包含最新的消息，因此很难从文件中删除较旧的消息以释放一些空间。 相反，由 logrotate 维护的日志被分为许多块。
		假设在/var/log中有一个名为auth.log 的日志文件，其中包含最近的日志消息。然后是 auth.log.1、auth.log.2 和 auth.log.3 ，每个都包含逐渐旧的数据。当 logrotate 决定是时候删除一些旧数据时，它会像如下“轮换”文件：
			①	移除最旧的文件，auth.log.3
			②	重命名 auth.log.2 为 auth.log.3
			③	重命名 auth.log.1 为 auth.log.2
			④	重命名 auth.log 为 auth.log.1
		不同发行版的名称和一些细节有所不同。例如，Ubuntu 配置指定 logrotate 应压缩从“1”位置移动到“2”位置的文件，因此在前面的示例中，您将拥有 auth.log.2.gz 和 auth.log.3 .gz。 
		在其他发行版中，logrotate 使用日期后缀重命名日志文件，例如 -20200529。 该方案的优点之一是更容易找到特定时间的日志文件。
	Ⅳ	日志维护【journal maintenance】
		存储在 /var/log/journal 中的日志不需要轮换，因为 journald 本身可以识别并删除旧消息。
		与传统的日志管理不同，journald 通常根据日志文件系统上剩余的空间大小、日志应占用的空间占文件系统的百分比以及最大日志大小设置为多少来决定删除消息。还有其他日志管理选项，如，日志消息允许的最长期限。
		可以在 journal.conf(5)手册页中找到默认值以及其他设置的描述。
	Ⅴ	查看系统日志记录
		在 20 世纪 80 年代，一个差距开始出现：Unix 服务器需要一种方法来记录诊断信息，但没有这样做的标准。 当 syslog 与 sendmail 电子邮件服务器一起出现时，其他服务的开发人员很乐意采用它。 RFC 3164 描述了 syslog 的演变。
		该机制相当简单。 传统的 syslogd 侦听并等待 Unix 域套接字 /dev/log 上的消息。 syslogd 的另一项强大功能是除了 /dev/log 之外还能够侦听网络套接字，从而使客户端计算机能够通过网络发送消息。
		这使得将整个网络的所有系统日志消息整合到一台日志服务器上成为可能，因此，系统日志在网络管理员中变得非常流行。 许多网络设备（例如路由器和嵌入式设备）可以充当系统日志客户端，将其诊断消息发送到服务器。
		Syslog 具有经典的客户端-服务器架构，包括其自己的协议（当前在 RFC 5424 中定义）。 然而，该协议并不总是标准的，早期版本除了一些基础知识之外并没有容纳太多结构。 
		使用 syslog 的程序员应该为自己的应用程序提供一种描述性的、清晰且简短的日志消息格式。 随着时间的推移，该协议添加了新功能，同时仍试图保持尽可能多的向后兼容性。
		①	设施【facility】、严重性【severity】和其他字段
			由于 syslog 将各种类型的消息从不同的服务发送到不同的目的地，因此需要一种方法对每个消息进行分类。传统方法是使用通常（但并非总是）包含在消息中的facility和severity的编码值。 
			除了文件输出之外，即使是非常旧的 syslogd 版本也能够根据消息的facility和severity将重要消息发送到控制台并直接发送到特定的登录用户——这是一种早期的系统监控工具。
			facility是一个通用服务类型，用于识别发送消息的内容。facilities 包括服务和系统组件，如内核、邮件系统和打印机。
			severity是日志消息的紧急程度。有八个级别，编号为0到7。它们通常通过名称来引用，尽管名称不是很一致并且在不同的实现中有所不同：
				0: emerg	1: alert	2: crit		3: err		4: warning		5: notice		6: info		7: debug
			facility 和 severity 共同构成优先级，在系统日志协议中打包为一个数字。可以在 RFC 5424 中阅读有关这些字段的所有信息，在syslog(3)手册页中了解如何在应用程序中指定它们，并在rsyslog.conf(5)手册页中了解如何匹配它们。
			但是，在将它们转换到日志世界【journal world】时，可能会遇到一些混乱，其中 severity 被称为优先级（如，当运行 journalctl -o json 以获取机器可读的日志输出时）。
			当开始检查协议的权限部分的详情时，会发现它不能与系统【OS】的其余部分的变化和需求保持同步。severity 定义仍然有效，但可用的facilities是硬链接的，包括很少使用的服务，如UUCP，无法定义新的服务。
			RFC 5424还包括结构化数据的规定，应用程序程序员可以使用任意键值对的集合来定义自己的字段。虽然这些数据可以通过一些额外的工作与日志一起使用，但将它们发送到其他类型的数据库更为常见。
		②	syslog 和 journald 的关系
			在某些系统上，journald 已经完全取代了 syslog，但有些系统仍保留 syslog 的主要原因如下：
				》syslog 具有在多台机器上聚合日志的良好定义的方法。当日志仅在一台机器上是，监视日志要容易得多。
				》rsyslog 等版本的syslog是模块化的，能够输出到许多不同的格式和数据（包括日志格式）。这使得将它们连接到分析和监控工具变得更容易。
			相比之下，journald强调将一台机器的日志输出收集和组织成一种格式。当想做一些更复杂的事情时，journald将其日志提供给不同的记录器的能力提供了高度的多功能性。
			当考虑到systemd可以收集server单元的输出并将它们发送到journald时，这一点尤其正确，从而使得可以访问比此应用程序发送到syslog的日志数据更多的日志数据。
		③	日志记录的最后注意事项
			现在，在一台机器上收集、存储和检索日志的过程已经得到了很好的定义，但日志记录的其他方面还没有标准化。
			首先，当希望在计算机网络上聚合和存储日志时，有一系列可用选项。而不是简单地将日志存储在文本文件中地集中式日志服务器，日志现在可以进入数据库，并且通常集中式服务器本身被互联网服务取代。
			接下来，使用日志的性质发生了变化。曾经，日志不被认为是“真实的”数据;它们的主要用途是当出现问题时(人类)管理员可以读取的资源。然而，随着应用程序变得越来越复杂，日志记录需求也在增长。
			这些新需求包括搜索、提取、显示和分析日志中的数据的功能。尽管我们有很多方法可以在数据库中存储日志，但是在应用程序中使用日志的工具仍然处于起步阶段。
			最后，要确保日志是值得信赖地。原始的rsyslog日志没有身份验证可言；只需相信发送日志的任何应用程序和/或机器都在说真话。此外，日志没有加密，这使得它们很容易被网络窥探。
			这在需要高度安全性的网络中是一个严重的风险。当代的syslog服务器有标准的方法来加密日志消息并对其发出的机器进行身份验证。
			然而，当您深入到单个应用程序时，情况就不那么清楚了。例如，你如何确定自称为你的web服务器的东西确实是web服务器?
2、/etc 的结构
	Linux系统上的大多数系统配置文件都在/etc目录下。从历史上看，每个程序或系统服务都有一个或多个配置文件，由于Unix系统上有大量组件，/etc会很快积累文件。
	这种方法有两个问题:很难在运行的系统中找到特定的配置文件，并且很难维护以这种方式配置的系统。例如，如果想更改sudo配置，则必须编辑/etc/sudoers但在你改变之后，升级可能会抹去你的自定义，因为它会覆盖/etc中的所有内容。
	多年来的趋势是将系统配置文件放在 /etc 下的子目录中（如，systemd 使用 /etc/systemd），在/etc目录中仍然有一些单独的配置文件，但如果运行 ls -F /etc，将看到那里的大多数项目现在都是子目录。
	为了解决覆盖配置文件的问题，可以将自定义放在配置子目录中的单独文件中，例如/etc/grub.d中的文件。
	/etc 目录下的放置配置文件的基本原则是，单个机器的可定制配置，如用户信息（/etc/passwd）和网络详细信息（/etc/network）。然而，一般的应用程序细节，比如一个发行版的默认用户界面，不属于/etc。
	不打算自定义的系统默认配置文件通常也可以在其他地方找到，例如/usr/lib/ System 中预打包的systemd单元文件。
3、用户管理文件
	Unix系统允许多个独立用户。在内核级别，用户只是数字(用户id)，但是因为记住名称比记住数字容易得多，所以在管理Linux时通常使用用户名(或登录名)。
	用户名只存在于用户空间中，因此任何使用用户名的程序都需要找到对应的用户与内核通信时的ID。
	Ⅰ	/etc/passwd 文件
		该纯文本文件映射用户名与用户ID。每行代表一个用户，包含由分号分隔的七个字段。其中第一个是用户名，接着是用户的密码。
		在大多数Linux系统中，密码实际上不再存储在passwd文件中，而是存储在shadow文件中。shadow文件格式与passwd类似，但普通用户没有读权限。passwd或shadow中的第二个字段是加密的密码。
		Unix密码从不以明文形式存储；实际上，该字段并不是密码本身，而是它的派生。在大多数情况下，从该字段获取原始密码是非常困难的(假设密码不容易猜到)。
		密码字段中的x表示加密的密码存储在shadow文件中；* 表示无法登录。如果密码字段为空，则登录时无需密码。
		余下字段如下：
			UID		用户ID，用户在内核中。可以有两个具有相同用户ID的条目，但这会使人感到困惑——也可能使软件感到困惑——因此请保持用户ID惟一。
			GID		组ID。应该是 /etc/group 文件中的编号条目之一。组决定文件权限和其他事情。此组也称为用户的主组。
			GECOS	用户的真实名称。有时会在这个字段中发现逗号，表示房间和电话号码之类的信息
			用户家目录
			用户的登录shell
		/etc/passwd 中的条目示例如下：
			Login Name
			  |	     UID  GID    Home Dir	Shell  	
			  |		  |    |       |		  |
			miggi:x:1000:1000::/home/miggi:/bin/bash
				  |          |
				  |			GECOS
				  passwd
		/etc/passwd中的用户和相应的主目录统称为一个账户（这是用户空间约定）。passwd文件中的一个条目通常就足够了;为了让大多数程序识别一个帐户，主目录不必存在。
		此外，有一些方法可以在系统上添加用户，而无需显式地将他们包含在passwd文件中;例如，使用NIS(网络信息服务)或LDAP(轻量级目录访问协议)之类的东西从网络服务器添加用户曾经很常见。
	Ⅱ	特殊用户
		会在 /etc/passwd 中找到一些特殊用户。超级用户（root）UID为0，GID为0。一些用户，如daemon，没有登录权限。nobody 用户是一个底层用户；有些进程作为nobody运行，因为它（通常）不能写入系统上的任何内容。
		不能登录的用户称为伪用户（pseudo-users）。虽然不能登录，但系统可以用他们的用户ID启动进程。伪用户（如，nobody）通常是处于安全原因创建的。
		同样，这些都是用户空间约定。这些用户对内核没有特殊的意义;唯一对内核有特殊意义的用户ID是超级用户的0。可以让nobody用户访问系统上的所有内容，就像对任何其他用户一样。
	Ⅲ	/etc/shadow 文件
		/etc/shadow 通常包含用户认证信息，包括/etc/passwd中对应用户的加密密码和密码过期信息。
		引入 shadow 文件是为了提供一种更灵活（也可能更安全）的存储密码的方式。它包括一套库和使用程序，其中许多很快就被PAM（Pluggable Authentication Modules）模块所取代。
		PAM没有为Linux引入一组全新的文件，而是使用 /etc/shadow，而不是某些相应的配置文件（如，/etc/login.defs）。
	Ⅳ	操作用户和密码
		常规用户使用 passwd 命令和一些其他工具与/etc/passwd 交互。使用 passwd更改密码。可以使用chfn 和chsh分别更改real name和shell（shell必须有在/etc/shells中列出来）。
		这些都是suid-root可执行文件，因为只有超级用户可以修改/etc/passwd文件。
		①	以超级用户更改/etc/passwd
			因为/etc/passwd只是一个普通的明文文件，从技术上讲，超级用户可以使用任何文本编辑器进行修改。像这样直接编辑passwd并不是一个好主意。这不仅很容易出错，而且如果其他东西同时更改了passwd，还可能遇到并发问题。
			使用终端或GUI提供的单独命令对用户进行更改要容易得多(也安全得多)。如使用 passwd user 设置密码；使用adduser和deluser分别添加和删除用户。
			如果，确实必须直接编辑文件，使用vipw程序，它会在编辑时备份并锁定/etc/passwd。使用 vipw -s 编辑 /etc/shadow 。
	Ⅴ	使用组
		Unix中的组提供了在特定用户之间共享文件的方法。其思想是，您可以为特定组设置读或写权限位，将其他所有组排除在外。这个特性曾经很重要，因为许多用户共享一台机器或网络，但近年来，由于工作站的共享频率降低，它变得不那么重要了。
		/etc/group 文件定义了组ID（如在/etc/passwd中的）。/etc/group中的每一行都是一组用冒号分隔的字段。每个条目中的字段从左到右依次为：
			①	组名		当使用 ls -l 时会出现
			②	组密码		Unix组密码很少使用，也不应该使用它们（在大多数情况下，sudo更好）。使用 * 或任何其他默认值。x 表示在/etc/gshadow中有一个相应的条目。用 * 或 ! 表示这是一个禁用的密码。
			③	组ID（数字）group 文件中的GID必须是唯一的。这个数字将进入该用户的/etc/passwd条目中的用户组字段
			④	属于该组的用户的可选列表	除了这里列出的用户之外，在其passwd文件条目中具有相应组ID的用户也属于该组
		/etc/group 条目示例如下：
			Group name
				| PWD GID  Additional members	
				|  |   |     |
			group3:x:1005:miggi
		要查看当前用户所属的组，使用 groups 命令。
		》注意：Linux发行版通常为每个新添加的用户创建一个新祖，并使用与用户相同的名称。
4、getty and login
	getty程序连接到终端并显示登录提示符。在大多数Linux系统上，getty并不复杂，因为系统只使用它在虚拟终端上进行登录。在许多系统上，在使用CTRL-ALT-F1之类的命令访问虚拟终端之前，甚至可能看不到getty进程。
	在输入登录名之后，getty将自己替换为登录程序，该程序会要求输入密码。如果输入了正确的密码，login将用shell替换自己(使用exec())。否则，将获得“登录错误”消息。登录程序的大部分实际身份验证工作都是由PAM处理的。
	可能永远不需要配置或更改它们。实际上，甚至很少使用它们，因为现在大多数用户要么通过图形界面(如gdm)登录，要么使用SSH远程登录，这两种方式都不使用getty或login。
5、设置时间
	Unix依赖于精确的计时。内核维护系统时钟，这是运行date等命令时所参考的时钟。也可以使用date设置系统时钟，通常不是一个好主意（永远不会得到完全正确的时间）。系统时钟应该尽可能接近正确的时间。
	PC硬件有一个电池支持的实时时钟(RTC)。RTC不是世界上最好的时钟，但总比没有好。内核通常根据启动时的RTC设置时间，可以使用hwclock将系统时钟重置为当前硬件时间。
	保持硬件时钟在通用协调时间(UTC)，以避免任何麻烦的时区或夏令时修正。可以使用下面的命令将RTC设置为内核的UTC时钟：
		# hwclock --systohc --utc
	内核在保持时间方面比RTC更差，而且由于Unix机器在一次引导中经常要运行很长时间，因此它们往往会产生时间漂移。时间漂移是内核时间与真实事件（由原子钟或其他非常精确的时钟定义）之间的当前差异。
	不应该尝试使用hwclock来修复时间漂移（基于时间的系统事件可能会丢失或损坏）。可以余小宁像adjtimex这样的实用程序来基于RTC平滑地更新时钟，但通常最好使用网络时间守护进程来保持系统时间正确。
	Ⅰ	内核时间表示和时区
		内核的系统时钟将当前时间表示为从UTC时间（1970/1/1 12PM）开始的秒数。要查看当前的这个数字，可以运行：
			# date +%s
		为了将这个数字转换为人类可读的内容，用户空间程序将其更改为当地时间。本地时区由 /etc/localtime 文件（二进制）控制。
		系统上的时区文件位于/usr/share/zoneinfo 目录。该目录包含许多时区和时区别名。
		要手动设置系统的时区，可以将 /usr/share/zoneinfo 中的一个文件复制到 /etc/localtime（或创建一个符号连接），或使用发行版的时区工具更改它。tzselect 可以帮助识别时区文件。
		要在一个shell会话中使用系统默认时区以外的时区，将 TZ 环境变量设置为 /usr/share/zoneinfo 中的文件名称，并测试更改，如：
			# export TZ=US/Central
			# date
		与其他环境变量一样，也可以设置单个命令的时区，如：
			TZ=US/Central date
	Ⅱ	网络时间
		如果机器联网，可以运行网络时间协议（NTP）守护进程来使用远程服务器维护时间。这曾经是由ntpd守护进程处理的，但与许多其他服务一样，systemd用自己的包（timesyncd）代替了它。
		大多数发行版都包含timesyncd，默认是启用的。不需要配置它，配置详情见 timesyncd.conf(5)。最常见的重写是更改远程时间服务器。
		如果想运行ntpd，则需要禁用已安装的timesyncd。登录https://www.ntppool.org/查看说明。如果您仍然希望在不同的服务器上使用timesyncd，这个站点可能也很有用。
		如果机器没有永久的互联网连接，可以使用一个守护进程（如，chronyd）来维护断开连接期间的时间。
		还可以根据网络时间设置硬件事件，以帮助系统在重新启动时保持时间一致性。许多发行版会自动执行此操作，但要手动执行此操作，确保从网络设置系统时间，然后运行以下命令：
			# hwclock --systohc --utc
6、使用 cron 和定时器单元【timer units】调度经常性任务
	有两种方法可以在重复调度上运行程序：cron 和 systemd 定时器单元。这种能力对于自动化系统维护任务是至关重要的。如，日志轮询实用程序确保硬盘不会被旧的日志文件填满。
	cron 服务长期以来一直是执行此操作的事实上的标准。systemd 的定时器单元在某些情况下是cron的替代方案。
	可以在任何适合的时间使用cron运行任何程序。通过cron运行的程序称为 cron 作业。要安装cron作业，需要在crontab文件中创建一个条目，通常是通过运行crontab命令。如：
		15 09 * * * /home/juser/bin/spmake
	该行开头的五个字段由空格分隔，指定计划时间，个字段依次如下：
		①	分	（0~59）
		②	时	（0~23）
		③	日	（1~31）
		④	月	（1~12）
		⑤	周	（0~7）0和7是星期日
	任何字段中的 * 表示匹配每个值。每个字段可以选择多个时间（用逗号分隔）。如：
		15 09 5,14 * * /home/juser/bin/spamke
	》注意：
		如果cron作业生成标准输出或错误或异常退出，则cron应该将此信息通过电子邮件发送给cron作业的所有者(假设电子邮件在系统上有效)。如果电子邮件令人讨厌，则将输出重定向到/dev/null或其他日志文件。
	crontab(5)手册页提供关于crontab格式的完整信息。
	Ⅰ	安装 crontab 文件
		每个用户都可以有其自己的 crontab 文件，这意味着每个系统可能有多个crontab（见/var/spool/cron/crontabs）。常规用户不能写入该目录；crontab命令安装、列出，编辑和移除用户的crontab。
		安装crontab最简单的方式是将crontab条目放入文件，然后使用 crontab file 来安装file作为当前crontab。crontab 检查文件格式确保没有任何错误。
		要列出cron作业，使用 crontab -l。要移除crontab，使用crontab -r。
		在创建了初始crontab之后，使用临时文件进行进一步编辑可能会有点混乱。相反，可以使用 crontab -e 来编辑和安装 crontab。如果出现编辑错误，crontab会告知错误在哪里，并询问是否再次尝试编辑。
	Ⅱ	系统 crontab 文件
		许多常见的 cron-activated 系统任务是以超级用户运行的。但，Linux发行版通常为整个系统提供一个 /etc/crontab 文件，而不是编辑和维护超级用户的crontab来调度这些操作。
		不会使用 crontab 来编辑这个文件，而且在任何情况下，它的格式都略有不同：在运行命令之前，有一个额外的字段指定应该运行作业的用户（(这使有机会将系统任务分组在一起，即使它们并非全部由同一用户运行。）。如：
			42 6 * * * root /usr/local/bin/cleansystem > /dev/null 2>&1
		》注意：
			一些发行版在/etc/cron.d 目录中存储了额外的crontab文件，其中包含的文件格式与/etc/crontab相同。也可能有一些目录，如/etc/cron.daily，但这里的文件通常是由/etc/crontab或/etc/cron.d中特定的cron作业运行的脚本。
			跟踪作业的位置和运行时间有时会令人困惑。
	Ⅲ	定时器单元【timer units】
		为周期性任务创建cron作业的另一种方法是构建一个系统定时器单元。对于一个全新的任务，必须创建两个单元：定时器单元【timer unit】和服务单元【service unit】。
		两个单元的原因是计时器单元不包含任何关于执行任务的细节；它只是运行服务单元（或从概念上讲，是另一种单元，但最常见的用法是服务单元）的激活机制。
		典型的定时器/服务单元对如下：
			# loggertest.timer
			[Unit]
			Description=Example timer unit

			[Timer]
			OnCalender=*-*-* *:00,20,40
			Unit=loggertest.service

			[Install]
			WantedBy=timers.target
		这个定时器每20分钟运行一次，其OnCalendar选项类似于cron语法。OnCalendar 时间格式是 year-month-day hour:minuter:second。秒字段是可选的。
		与cron一样，* 表示一种通配符，逗号分隔多个值。/（周期）语法也是有效的，如：*:00,20,40 可更改为*:00/20（每20分钟一次），以达到相同的效果。
		OnCalendar字段中的时间语法有许多快捷方式和变体。systemd.time(7)手册页中的Calendar Events部分以获取完整列表。
		关联的服务单元名为loggertest.service（在定时器中使用Unit选项显式地命名它，但这并不是绝对必要地，因为systemd会查找一个与定时器单元文件具有相同基名的.service文件）。这个服务单元文件也在/etc/systemd/system中。如：
			[Unit]
			Description=Example Test Service

			[Service]
			Type=oneshot
			ExecStart=/usr/bin/logger -p local3.debug I\'m logger
		这里的关键是 ExecStart行，这是服务在激活时运行的命令。使用oneshot作为服务类型，表明服务预计讲运行并退出，并且在ExecStart指定的命令完成之前，systemd不会认为服务已启动。这对于定时器来说有一些好处：
			①	可以在单元文件中指定多个ExecStart命令
			②	在使用Wants和Before依赖指令激活其他单元时，更容易控制严格的依赖顺序。
			③	可以在journal中更好地记录单元的开始和结束时间
		》注意：
			这里使用logger向syslog和journal发送条目。可以按单元查看日志消息。但是，该单元可能在journald有机会接收到消息之前就结束了。这是一个竞争条件，如果单元完成得太快，则journald将无法查找与syslog消息关联得单元（这是通过进程ID完成得）。
			因此，写入journal的消息可能不包括单元字段（可通过 journalctl -f -u loggertest.service之类的过滤命令呈现）。服务无法显示syslog消息。在运行较长时间的服务中，这通常不是问题。
	Ⅳ	cron 与 定时器单元
		cron实用程序是Linux系统中最古老的组件之一;它已经存在了几十年(早于Linux本身)，它的配置格式多年来没有太大变化。
		systemd 定时器单元似乎是一个合乎逻辑的替代，实际上，许多发行版现在已经将系统级定期维护任务移到了定时器单元。但事实证明，cron有一些优势:
			①	更简单的配置
			②	与多个第三方服务兼容
			③	用户更容易安装自己的任务
		定时器单元提供以下优势：
			①	通过cgroup对与任务/单元相关的进程进行更好的跟踪
			②	出色地跟踪journal中的诊断信息
			③	激活时间和频率的额外选项
			④	能使用系统依赖和激活机制
7、使用 at 调度一次性任务
	要在将来运行一次性作业而不使用cron，可使用 at 服务（需要运行 atd 服务）。如：
		# at 02:17
		warning: commands will be executed using /bin/sh
		at> echo "Hello World" > ~/abcdd.txt
		at> <EOT>
	使用 Ctrl-D 结束输入。at 从标准输入中读取命令。
	要检查作业是否已被调度，使用atq。要去除它，使用atrm。还可通过以DD.MM.YY格式添加日期来计划未来的作业日期。at命令没有太多其他内容。
	Ⅰ	定时器单元当量【equivalents】
		可以使用系统定时器单元来代替 at 。这些比周期定时器单元更容易创建，并且可以在命令行上运行，如：
			# systemd-run --on-calendar='2024-02-05 02:46' /bin/echo this is a test
			Running timer as unit: run-rdf81b674f3db479196f59a6d095b45e4.timer
			Will run service as unit: run-rdf81b674f3db479196f59a6d095b45e4.service
		systemd-run 创建一个暂态定时器单元，可以使用常用的systemctl list-timers 查看该单元。如果不关心具体的事件，可以使用 --on-active 来指定时间偏移量（如，--on-active=30m 表示未来的30分钟）。
		》注意：
			当使用 --on-calendar 时，重要的是要包括（未来的）日期和时间。否则，定时器和服务单元将保持不变，定时器每天在指定的时间运行服务。该选项的语法与定时器单元中的OnCalendar选项相同。
8、定时器单元以普通用户运行
	可以以普通用户创建定时器单元——通过在systemd-run 上添加 --user 选项。
	如果在单元运行前退出登录，单元将不会开始；如果在单元完成前退出登录，单元将终止（systemd有一个与登录用户相关联的用户管理器，这对于运行定时器单元是必要的）。
	可以使用如下命令告诉 systemd 在注销后保留用户管理器：
		# loginctl enable-linger
	作为root用户，可以为其他用户启用管理器：
		# loginctl enable-linger user
9、用户访问主题
	Ⅰ	用户ID和用户切换
		当暂时切换到另一个用户时，所做的只是更改用户ID。有两种方法可以做到这一点，内核可以处理这两种方法。第一个是 setuid 可执行文件；第二个是通过 setuid() 系列系统调用。这个系统调用有几种不同的版本，以适应与进程相关联的各种用户ID。
		内核有关于进程能做什么或不能做什么的基本规则，这里有三个基本规则，涵盖了setuid可执行文件和setuid()：
			①	只要具有足够的文件权限，进程就可以运行 setuid 可执行文件
			②	作为 root 运行的进程发可以使用 setuid()成为任何其他用户
			③	不以root身份运行的进程对如何使用setuid()有严格的限制；在大多数情况下不能使用。
		这些规则的结果是，如果希望将用户id从普通用户切换到另一个用户，通常需要组合使用这些方法。如，sudo可执行文件是 setuid root ，一旦运行，它可以调用setuid()成为另一个用户。
		》注意：从本质上讲，用户切换与密码合伙用户名无关。这些都是严格上的用户空间概念。
	Ⅱ	进程所有者，有效【effective】UID，真实【real】UID，和保存的【saved】UID
		每个进程都有多个用户ID。有效用户ID（effective UID，或euid），它定义了进程的访问权限（最重要的是文件权限）。第二个用户ID，即真实用户ID（real UID或ruid），表示是谁发起了进程。
		通常，这些ID是相同的，当运行setuid程序时，Linux在执行期间将euid设置为程序的所有者，但它在ruid中保留原始用户ID。
		有效UID和真实UID之间的区别令人困惑，以至于很多关于进程所有权的文档都是不正确的。
		可以把euid想成行动者【actor】，ruid想成所有者【owner】。ruid定义了可以与正在运行的进程交互的用户——最重要的是，哪个用户可以杀死进程并向进程发送信号。
		如，如果用户A启动了一个以用户B身份运行的新进程（基于setuid权限），用户A仍拥有该进程，并且可以杀死它。
		大多数进程具有相同的euid和ruid。因此，ps和其他系统诊断程序的默认输出只显示euid。要查看系统上的这两个用户ID，使用以下命令：
			# ps -eo pid,euser,ruser,comm
		除了真实和有效的用户ID之外，还有一个保存的用户ID。进程可以在执行期间将其euid切换为ruid或保存的用户【saved user】ID。（Linux还有另一个用户ID：file system user ID，或fsuid，它定义了访问文件系统的用户，很少使用）。
		ruid的概念可能与之前的经验相矛盾。为什么不需要经常处理其他用户ID？如，在用sudo启动一个进程后，如果想终止它，仍然使用sudo；不能把它当作自己的普通用户。在这种情况下，普通用户不应该是ruid，提供正确的权限？
		这种行为的原因是sudo和许多其他setuid程序显式地使用setuid()系统调用之一更改了euid和ruid。这些程序之所以这样做，是因为当所有用户id不匹配时，通常会出现意想不到的副作用和访问问题。
		》注意：
			如果对有关用户ID切换的细节和规则感兴趣，阅读 setuid(2)手册页，并查看SEE ALSO 部分列出的其他手册页。对于不同的情况，有许多不同的系统调用。
		有些程序不喜欢 root 的 ruid。为了防止sudo 更改 ruid，将如下行添加到 /etc/sudoers中（注意对想以root身份运行的其他程序的副作用）：
			Defaults	stay_setuid
		①	安全影响
			由于Linux内核通过setuid程序和随后的系统调用来处理所有用户切换（以及文件权限），因此系统开发人员和管理员必须非常小心以下两件事：
				》具有 setuid 权限的程序的数量和质量
				》这些程序是做什么的
	Ⅲ	用户标识、身份验证和授权
		多用户系统必须在三个方面为用户安全性提供基本支持：标识、身份验证和授权。
		当涉及到用户标识时，Linux内核只知道进程和文件所有权的数字用户ID。内核知道如何运行setuid可执行文件的授权规则，以及用户如何运行setuid()系列系统调用以从一个用户更改到另一个用户。
		内核不知道任何关于身份验证的信息：用户名和密码等。实际上，所有与身份验证相关的事情都发生在用户空间中。




			
			

	
			




	





					






	
				



						


					
					
				 



				



			 











			
			




	


					
			


				

				









	


			




			
		


	

	

		

			





			

		

			

		




	



System Configuration: Logging, System Time, Batch Jobs, and Users
3、用户管理文件
	Unix 系统允许多个独立用户。 在内核级别，用户只是数字（用户 ID），但由于记住名称比记住数字容易得多，因此在管理 Linux 时通常会使用用户名（或登录名）。

System Configuration: Logging, System Time, Batch Jobs, and Users
3、用户管理文件
	Unix 系统允许多个独立用户。 在内核级别，用户只是数字（用户 ID），但由于记住名称比记住数字容易得多，因此在管理 Linux 时通常会使用用户名（或登录名）。
	用户名仅存在于用户空间中，因此任何使用用户名的程序在与内核通信时都需要找到其相应的用户ID。
	①	/etc/passwd 
	该文件中每行代表一个用户，并有七个用冒号分隔的字段。字段分别是：
		Login name:Password:User ID:Group ID:Real name(GECOS):Home directory:Shell
	在大多数Linux系统中，密码不再实际存储在/etc/passwd文件中，而是/etc/shadow文件，/etc/shadow 文件格式与/etc/passwd类似，但普通用户没有shadow的读取权限，其中第二个字段是加密的密码。
	Unix 密码永远不会以明文形式存储； 事实上，该字段不是密码本身，而是密码的派生。 在大多数情况下，从该字段获取原始密码非常困难。
	Password字段中的x表示加密的密码存储在shadow文件中；*表示密码已禁用。如果Password字段为空，则无需密码即可登录。
	/etc/passwd文件语法相当严格，不允许有任何注释或空行。
	②	特殊用户
	超级用户（root）其UID为0，GID为0。某些用户（如daemon）没有登录权限。nobody用户是低权限用户；某些进程已nobody身份运行【通常无法在系统上写入任何内容】。
	无法登录的用户称为伪用户【pseudo-users】。尽管他们无法登录，但系统可以使用他们的用户 ID 启动进程。 出于安全原因，通常会创建诸如“nobody”之类的伪用户。
	再次强调，这些都是用户空间约定。这些用户对内核没有特殊意义；对内核有特殊意义的唯一用户 ID 是超级用户的 0。可以授予nobody用户访问系统上所有内容的权限，就像访问任何其他用户一样。
	③	/etc/shadow
	Unix 系统允许多个独立用户。 在内核级别，用户只是数字（用户 ID），但由于记住名称比记住数字容易得多，因此在管理 Linux 时通常会使用用户名（或登录名）。

System Configuration: Logging, System Time, Batch Jobs, and Users
3、用户管理文件
	Unix 系统允许多个独立用户。 在内核级别，用户只是数字（用户 ID），但由于记住名称比记住数字容易得多，因此在管理 Linux 时通常会使用用户名（或登录名）。
	用户名仅存在于用户空间中，因此任何使用用户名的程序在与内核通信时都需要找到其相应的用户ID。
	①	/etc/passwd 
	该文件中每行代表一个用户，并有七个用冒号分隔的字段。字段分别是：
		Login name:Password:User ID:Group ID:Real name(GECOS):Home directory:Shell
	在大多数Linux系统中，密码不再实际存储在/etc/passwd文件中，而是/etc/shadow文件，/etc/shadow 文件格式与/etc/passwd类似，但普通用户没有shadow的读取权限，其中第二个字段是加密的密码。
	Unix 密码永远不会以明文形式存储； 事实上，该字段不是密码本身，而是密码的派生。 在大多数情况下，从该字段获取原始密码非常困难。
	Password字段中的x表示加密的密码存储在shadow文件中；*表示密码已禁用。如果Password字段为空，则无需密码即可登录。
	/etc/passwd文件语法相当严格，不允许有任何注释或空行。
	②	特殊用户
	超级用户（root）其UID为0，GID为0。某些用户（如daemon）没有登录权限。nobody用户是低权限用户；某些进程已nobody身份运行【通常无法在系统上写入任何内容】。
	无法登录的用户称为伪用户【pseudo-users】。尽管他们无法登录，但系统可以使用他们的用户 ID 启动进程。 出于安全原因，通常会创建诸如“nobody”之类的伪用户。
	再次强调，这些都是用户空间约定。这些用户对内核没有特殊意义；对内核有特殊意义的唯一用户 ID 是超级用户的 0。可以授予nobody用户访问系统上所有内容的权限，就像访问任何其他用户一样。
	③	/etc/shadow
	Linux系统上的影子密码文件（/etc/shadow）通常包含用户认证信息，包括/etc/passwd中与用户对应的加密密码和密码过期信息。
	引入shadow文件是为了提供一种更灵活（也许更安全）的密码存储方式。它包括一套库和使用程序，其中许多很快就被PAM（可插入身份验证模块）所取代。
	PAM没有为Linux引入一组全新的文件，而是使用/etc/shadow，但不使用某些相关的配置，如/etc/login.defs。
	④	操作用户和密码
	普通用户使用passwd命令和其他一些工具与/etc/passwd交互。使用passwd更改密码。可以使用chfn和chsh分别更改真实名称和shell（shel必须在/etc/shells中列出）。这些都是suid-root可执行文件，因为只有超级用户才能更改/etc/passwd文件。
	chfn和chsh可通过安装util-linux-user来获得。
	》以超级用户身份更改/etc/passwd
	由于 /etc/passwd 只是一个普通的纯文本文件，因此技术上允许超级用户使用任何文本编辑器进行更改。要添加用户，可以简单地添加适当的行并为用户创建主目录；要删除，可以执行相反的操作
	然而，像这样直接编辑 passwd 是一个坏主意。 这不仅很容易犯错误，而且如果其他东西同时更改密码，还可能会遇到并发问题。 使用终端或 GUI 提供的单独命令对用户进行更改要容易得多（也更安全）。
	例如，要设置用户的密码，请以超级用户身份运行 passwd user。 使用 adduser 和 userdel 分别添加和删除用户。
	但，如果确实必须直接编辑该文件，使用vipw程序，该程序会在编辑/etc/passwd时备份并锁定它，作为额外的预防措施。要编辑/etc/shadow，使用vipw -s。
	》vipw使用说明：
	现在知道 getty 和 login 的作用，但可能永远不需要配置或更改它们。事实上，甚至很少会使用它们，因为大多数用户现在要么通过图形界面（例如 gdm）登录，要么通过 SSH 远程登录，这两种方式都不使用 getty 或登录。


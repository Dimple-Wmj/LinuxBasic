Linux 概述
1、资源可见性
	秉承UNIX的优良传统，Linux默认具有全局资源视图。
	在Linux 和Unix中“一切皆文件”。在这里，认为资源是任何可以用来帮助软件执行的东西【包括硬件及其抽象（CPU和RAM、文件）、文件系统、硬盘驱动器、固态驱动器（SSD）、进程、与网络相关的东西（如设备或路由表），以及代表用户的凭据。】
	注意：并非Linux中的所有资源都是文件或通过文件接口表示。有一些系统，可以更进一步。
	Linux资源的具体示例如下：
	①	查看Linux版本信息：
	# cat /proc/version 
	Linux version 5.14.0-352.el9.x86_64 (mockbuild@x86-05.stream.rdu2.redhat.com) (gcc (GCC) 11.4.1 20230605 (Red Hat 11.4.1-2), GNU ld version 2.35.2-42.el9) #1 SMP PREEMPT_DYNAMIC Wed Aug 9 00:25:27 UTC 2023cat /proc/version
	②	查看正在使用的CPU的特定硬件信息：
	# cat /proc/cpuinfo | grep "model name"
	model name      : Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
	③	打印进程状态（有关当前进程的详细信息）并将输出限制为仅显示当前六行。
	# cat /proc/$$/status | head -n6
		Name:   bash
		Umask:  0022
		State:  S (sleeping)
		Tgid:   1034
		Ngid:   0
		Pid:    1034
	》补充：$$
		这是一个特殊变量，涉及当前进程。在shell上下文中，$$是在其中输入命令的shell的进程ID。
	在Linux中可以有多个具有相同PID的进程【不同的上下文【命名空间】中可以有多个具有相同PID的进程，如在容器化设置。
	每个进程可能认为它很特殊，具有PID 1，在更传统的设置中，它是为用户空间进程树的根保留的。
	给定资源可以有全局视图（两个用户在完全相同的位置查看文件）以及本地或虚拟化视图。Linux中的所有内容并非默认都是全局的。
	多个用户或进程并行运行的错觉的一部分是对资源的（有限的）可见性。在Linux中提供（某些受支持的）资源的本地视图是通过命名空间。
	第二个独立的维度是隔离。考虑进程隔离的一种方法是限制内存消耗，以便一个进程不会导致其他进程没有内存可用。如为应用程序提供1GB的RAM供使用。如果它使用更多，就会因为内存不足而被杀死。这提供了一定程度的保护。在Linux中，使用称为cgroups的内核功能来提供这种隔离。
	另一方面，完全隔离的环境使应用程序看起来完全独立。如虚拟机可用于提供完全隔离。
	任何Linux发行版的核心都具有内核【kernel】，提供其他所有内容所构建的API。文件、网络和可观察性这三个核心主题随处可见。
	从形式上来说，POSIX（便携式操作系统接口）是一个IEEE标准，用于定义UNIX操作系统的服务接口。动机是提供不同实现之间的可移植性。如果读到“符合POSIX标准”之类的内容，考虑一组在官方采购环境中特别相关的正式规范，而在日常使用中则不太相关。
	Linux 的构建是为了兼容 POSIX 以及 UNIX 系统 V 接口定义 (SVID)，这赋予了它老式 AT&T UNIX 系统的风格，而不是 Berkeley Software Distribution (BSD)风格系统。


The Linux Kernel
	虽然内核提供所有核心功能，但它本身并不是操作系统，而只是操作系统的一个非常核心的部分。
1、Linux架构
	从较高层面来看，可以将其分为三个不同的层：
	①	硬件【Hardware】
		从CPU和内存到磁盘驱动，网络接口和外围设备【如，键盘和显示器】
	②	内核【The Kernel】
		有许多组件位于内核和用户空间之间，如 init 系统和系统服务（网络等），但严格来说，它们不是内核的一部分。
	③	用户空间【User land】
		大多数应用车如果你徐运行的地方，包括操作系统组件（如shell）、实用程序（如ps或ssh）以及图形用户界面。
	不同层之间的接口已明确定义，并且是 Linux 操作系统包的一部分。 内核和用户态之间有一个称为系统调用（简称syscalls）的接口。
	与系统调用不同，硬件和内核之间的接口不是单一的。它由一组单独的接口组成，通常按硬件分组：
		①	CPU接口
		②	内存接口
		③	网络接口和驱动
		④	文件系统和块设备驱动接口
		⑤	字符设备，硬件中断和设备驱动，用于输入的设备【如键盘、终端和其他I/O】
	通常认为是 Linux 操作系统一部分的许多东西【如shell或grep、find和ping等实用程序】，实际并不是内核的一部分，而是非常像下载的应用程序，用户空间的一部分。
	在用户态中，经常会读到或听到有关用户模式和内核模式的内容。这实际上指的是对硬件的访问权限有多大以及可用的抽象有多大限制。
	一般，内核模式意味着快速执行和有限的抽象，用户模式意味着相对较慢但更安全和更方便的抽象。
	除非是内核开发人员，否则几乎总是可以忽略内核模式，因为所有应用程序都将在用户空间中运行。另一方面，了解如何与内核交互【系统调用】至关重要，也是考虑的一部分。
2、CPU架构
	除了通用代码和驱动程序之外，Linux内核还包含特定于体系结构的代码。这种分离使其能够移植Linux并使用其在新硬件上快速可用。有多种方法可以确定Linux正在运行什么CPU。
	》补充【BIOS 和 UEFI】
		传统上，UNIX和Linux实用基本I/O系统（BIOS）进行自身引导。当打开Linux电脑时，它完全由硬件控制。首先，硬件被连接以运行加电自检（POST），这是BIOS的一部分。POST确保硬件（RAM等）按指定功能运行。
		在现代环境中，BIOS功能已被统一可扩展固件接口（UEFI）有效取代，UEFI时一种定义操作系统和平台固件之间的软件接口的公共规范。
	一种方法是使用名为 dmidecode 的专用工具，它与BIOS交互。如果这没有产生结果，可以尝试以下操作之一：
	# lscpu
		架构：                   x86_64
		  CPU 运行模式：         32-bit, 64-bit
		  Address sizes:         45 bits physical, 48 bits virtual
		  字节序：               Little Endian
		CPU:                     2
		  在线 CPU 列表：        0,1
		厂商 ID：                GenuineIntel
		  BIOS Vendor ID:        GenuineIntel
		  型号名称：             Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
		    BIOS Model name:     Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
		    CPU 系列：           6
		    型号：               158
		    每个核的线程数：     1
		    每个座的核数：       2
		    座：                 1
		    步进：               10
		    BogoMIPS：           4416.00
		    标记：               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc cpui                         d tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single pti ssbd ibrs ibpb st                         ibp fsgsbase tsc_adjust bmi1 avx2 smep bmi2 invpcid rdseed adx smap clflushopt xsaveopt xsavec xgetbv1 xsaves arat md_clear flush_l1d arch_capabilities
		Virtualization features:
		  超管理器厂商：         VMware
		  虚拟化类型：           完全
		Caches (sum of all):
		  L1d:                   64 KiB (2 instances)
		  L1i:                   64 KiB (2 instances)
		  L2:                    512 KiB (2 instances)
		  L3:                    9 MiB (1 instance)
		[...]
	另一种收集类似架构信息的方法是 cat /proc/cpuinfo ，或如果仅对架构感兴趣，可调用 uname -m。
	①	x86 架构
		x86 是一个指令集系列，最初由Intel开发，后来授权给Advanced Micro Devices（ARM）。在内核中，x64指的是Intel 64位处理器，x86代表Intel 32位处理器。此外，amd64指的是AMD 64位处理器。
		如今，x86 CPU 系列主要出现在台式机和笔记本电脑中，但它也广泛用于服务器中。 具体来说，x86 构成了公共云的基础。 它是一种功能强大且广泛可用的架构，但能源效率不高。 
		部分由于其严重依赖乱序执行，它最近受到了诸如 Meltdown【https://meltdownattack.com/】等安全问题的广泛关注。
		有关更多详细信息，例如 Linux/x86 引导协议或 Intel 和 AMD 特定背景，请参阅特定于 x86 的内核文档。
	②	ARM 架构
		ARM 是一个精简指令集计算 (RISC) 架构系列，已有 30 多年的历史。 RISC 通常由许多通用 CPU 寄存器以及一小组可以更快执行的指令组成。
		由于 Acorn（ARM 背后的原始公司）的设计人员从一开始就注重最小功耗，因此可以在 iPhone 等许多便携式设备中找到基于 ARM 的芯片。 它们也存在于大多数基于 Android 的手机和 IoT 中的嵌入式系统中，例如 Raspberry Pi。
		鉴于它们比 x86 芯片更快、更便宜且产生的热量更少，因此在数据中心中越来越多地发现基于 ARM 的 CPU（例如 AWS Graviton）。虽然比 x86 简单，但 ARM 也不能免受 Spectre 等漏洞的影响。 见ARM的内核文档。
	③	RISC-V 架构
		RISC-V（读作“risk 5”）是一个后起之秀，是一种开放的 RISC 标准，最初由加州大学伯克利分校开发。 截至 2021 年，已有多种实施方案，从阿里巴巴集团和 Nvidia 到 SiFive 等初创公司。 
		虽然令人兴奋，但这是一个相对较新且尚未广泛使用的 CPU 系列，要了解它的外观和感觉，可能需要对其进行一些研究——Shae Erisson 的文章“Linux on RISC-V【https://shapr.github.io/posts/2019-06-08-riscv-linux.html】”是一个好的开始”。有关更多详细信息，请参阅 RISC-V 内核文档。
3、内核组件
	在内核代码库中找到的主要功能块如下：
		①	进程管理，如根据可执行文件启动进程
		②	内存管理，如位进程分配内存或将文件映射到内存中。
		③	网络，如管理网络接口或提供网络堆栈
		④	文件系统提供文件管理并支持文件的创建和删除
		⑤	字符设备和设备驱动的管理
	这些功能组件通常具有相互依赖性，确保内核开发人员的座右铭“内核永远不会破坏用户空间”是一项真正具有挑战性的任务。
	①	进程管理
		

		
		
	





Access Control
1、Basic
	①	资源和所有权
		用户	启动进程和拥有文件。进程是内核加载到主内存并运行的程序（可执行文件）。
		文件	有所有者；默认，创建该文件的用户拥有该文件
		进程	使用文件进行通信和持久化。用户也可间接使用文件，但他们需要通过进程来这样做。
	②	沙箱【sandboxing】
		在谈论资源访问时，经常会遇到的一个术语是沙箱。沙箱是一个定义模糊的术语，可以指一系列不同的方法，从监狱【jails】到容器再到虚拟机，可以在内核或用户空间中进行管理。
		通常有一些东西在沙箱中运行——通常是一些应用程序，并且监督机制在沙箱进程和托管环境之间强制执行一定程度的隔离。
	③	访问控制类型
		访问控制的一方面是访问本身的性质。用户或进程是否直接访问资源。或者也许有一套明确的规则，规定进程在什么情况下可以访问哪种资源（文件或系统调用）。或者甚至可能记录访问本身。
		在Linux环境中，两个最重要的是：
			自主访问控制【DAC】	根据用户的身份限制对资源的访问。它是任意的，因为具有某些权限的用户将它们传递给其他用户。
			强制访问控制		基于表示安全级别的分层模型。用户被分配许可级别，资源被分配安全标签。用户只能访问等于（或低于）自己权限级别对应的资源。
								在强制访问控制模型中，管理员严格且排他地控制访问，设置所有权限。即，用户无法自己设置权限，即使他们拥有资源。
		Linux传统上有一种要么全由要么全无的态度——要么是有权改变一切的超级用户，要么是访问权限有限的普通用户。为了稍微限定以下Linux中【全有或全无的态度】：大多数Linux系统中的默认设置允许【其他人】对几乎每个文件和可执行文件进行读取访问。
		SELinux 可能是最著名的 Linux 强制访问控制实现。 它是为了满足政府机构的高安全要求而开发的，并且通常在这些环境中使用，因为可用性受到严格的规则的影响。 强制访问控制的另一个选项是 AppArmor，自 2.6.36 版本起就包含在 Linux 内核中，并且在 Ubuntu 系列 Linux 发行版中相当流行。
2、用户
	在 Linux 中，经常从目的或预期用途的角度区分两种类型的用户帐户：
	①	系统用户	通常，程序（有时称为守护程序）使用这些类型的帐户来运行后台进程。这些程序提供的服务可以是系统的一部分，如网络【sshd】，也可以是应用程序层【如mysql】。
	②	常规用户	通过shell交互使用Linux的人类用户。
	Linux 通过 UID 来识别用户，属于一个或多个组的用户通过组ID（GID）来识别。不同的Linux发行版有自己的方式来决定如何管理UID范围。如支持systemd的发行版具有以下约定：
		UID 0	 					root
		UID 1 ~ 999					为系统用户保留
		UID 65534					nobody
		UID 1000 ~ 65533
			65536 ~ 4294967294		常规用户
	①	本地用户管理
		实现本地用户管理的四个文件是：
			/etc/passwd				用户数据库
			/etc/group				组数据库
			/etc/shadow				用户密码
			/etc/gshadow			组密码
		/etc/passwd 用于跟踪普通用户的用户名、UID、组成员身份和其他数据【如主目录、登录shell等】。
		》说明
			root:x:0:0:root:/root:/bin/bash
			①	root		用户名【不得超过32个字符】
			②	x			用户的密码，x 表示（加密的）密码存储在 /etc/shadow 中
			③	0			UID。注意，Linux 保留 1000 以下的 UID 供系统使用。
			④	0			用户主组（GID），见 /etc/group
			⑤	root		用户信息【全名或联系信息，如电话号码】。通常也称为GECOS字段【注意，不适用GECOS格式，而是字段本身通常有能够与与账号关联的信息】。
			⑥	/root		用户家目录
			⑦	/bin/bash	登录 shell。要防止交互式登录，请使用 /sbin/nologin
		由于历史原因，密码存储在 /etc/shadow 文件中。虽然每个用户都可以读取 /etc/passwd ，但通常需要root权限才能读取 /etc/shadow 。
		使用 useradd 命令新建用户。
		》useradd 使用说明
		用法：useradd [选项] 登录名
		      useradd -D
		      useradd -D [选项]
		
		选项：
		      --badname                 do not check for bad names
		  -b, --base-dir BASE_DIR       新账户的主目录的基目录
		      --btrfs-subvolume-home    use BTRFS subvolume for home directory
		  -c, --comment COMMENT         新账户的 GECOS 字段
		  -d, --home-dir HOME_DIR       新账户的主目录
		  -D, --defaults                显示或更改默认的 useradd 配置
		  -e, --expiredate EXPIRE_DATE  新账户的过期日期
		  -f, --inactive INACTIVE       新账户的密码不活动期
		  -g, --gid GROUP               新账户主组的名称或 ID
		  -G, --groups GROUPS           新账户的附加组列表
		  -h, --help                    显示此帮助信息并退出
		  -k, --skel SKEL_DIR           使用此目录作为骨架目录
		  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值
		  -l, --no-log-init             不要将此用户添加到最近登录和登录失败数据库
		  -m, --create-home             创建用户的主目录
		  -M, --no-create-home          不创建用户的主目录
		  -N, --no-user-group           不创建同名的组
		  -o, --non-unique              允许使用重复的 UID 创建用户
		  -p, --password PASSWORD       加密后的新账户密码
		  -r, --system                  创建一个系统账户
		  -R, --root CHROOT_DIR         chroot 到的目录
		  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files
		  -s, --shell SHELL             新账户的登录 shell
		  -u, --uid UID                 新账户的用户 ID
		  -U, --user-group              创建与用户同名的组
		  -Z, --selinux-user SEUSER     为 SELinux 用户映射使用指定 SEUSER
		除了用户之外，Linux还有组的概念，组在某种意义上只是一个或多个用户的集合。任何常规用户都属于一个默认组，但也可以是其他组的成员。可以通过 /etc/group 文件找到有关组和映射的信息。
	②	集中用户管理
		如果必须管理多台机器或服务器，本地用户管理很快就会过时。这是需要一种集中的方式来可以在本地应用于一台特定计算机的用户。有如下几种方式：
		Ⅰ	基于目录
			轻量级目录访问协议（LDAP）是一套已有数十年历史的协议，现已有IFTF正式化，它定义了如何通过互联网协议（IP）访问和维护分布式目录。
		Ⅱ	通过网络
			可以使用Kerberos通过网络方式对用户进行身份验证
		Ⅲ	使用配置管理系统
			这些系统（包括 Ansible、Chef、Puppet 或 SaltStack）可用于跨机器一致地创建用户。
3、权限
	①	文件权限
		文件权限是Linux资源访问概念的核心，Linux中的一切或多或少都是文件【一切皆文件】。权限分为三种类型或范围【从窄到宽】：
		Ⅰ	用户	文件所有者
		Ⅱ	组		有一个或多个成员
		Ⅲ	其他人	
		有三种类型的访问：
		Ⅰ	读（r）		对于普通文件，允许用户查看文件的内容。对于目录，允许用户查看目录中文件的名称。
		Ⅱ	写（w）		对于普通文件，允许用户修改或删除文件。对于目录，允许用户创建，重命名和删除目录中的文件。
		Ⅲ	执行（x）	对于普通文件，如果用户也具有该文件的读权限，则允许用户执行该文件。对于目录，允许用户访问目录中的文件信息，有效地允许他们进入该目录（cd）或列出其内容（ls）。
		其他文件访问位【access bits】
		s				应用于可执行文件的 setuid/setgid 权限。运行它的用户继承文件所有者或所属组的有效权限。
		t				粘滞位【sticky bit】。仅与目录有关。如果设置，它将阻止非root用户删除其中的文件（除非该用户拥有该目录/文件）
		Linux中还可以通过 chattr（更改属性）命令进行特殊设置。
		》文件权限说明【ls -al】
			-rw-r--r--. 1 miggi miggi   390 12月  5 18:34 Leanring_Modern_linux
			①	文件模式【file mode】
				Ⅰ	文件类型【-】
				Ⅱ	文件所有者权限【rw-】
				Ⅲ	文件所属组权限【r--】
				Ⅳ	其他人的权限【r--】
			②	硬链接数【1】
			③	文件所有者【miggi】
			④	文件所属组【miggi】
			⑤	文件大小（bytes）【390】
			⑥	上次修改时间戳【12月  5 18:34】
			⑦	文件名
		》文件类型
			-			常规文件
			b			块特殊文件
			c			字符特殊文件
			C			高性能（连续数据）文件
			d			目录
			l			符号连接
			p			命名管道（使用 mkfifo 创建）
			s			套接字文件
			？			其他（未知）文件类型
		》文件权限表示方式：
			r（4）、w（2）、x（1）
	②	进程权限
		在运行时权限上下文中存在不同的相关用户ID（credenti(7) manual page【https://man7.org/linux/man-pages/man7/credentials.7.html】）：
		Ⅰ	真实UID【Real UID】
			真实UID是启动该进程的用户的UID。它代表人类用户的进程所有权。进程本身可通过 getuid(2) 获取其真实的UID，并且可以使用 stat -c "%u %g" /proc/$pid/ 进行查询。
			如当普通用户【如，miggi】执行【passwd】命令时。通过【stat -c "%u %U %g" /proc/$pid/】会发现运行passwd的真实UID是0【root】。
		Ⅱ	有效UID【Effective UID】
			Linux内核使用有效UID来确定进程访问消息队列等共享资源时所拥有的权限。
			在传统的 UNIX 系统上，它们还用于文件访问。 然而，Linux 之前使用专用的文件系统 UID 来获取文件访问权限。出于兼容性原因，仍支持此功能。进程可以通过 geteuid(2) 获取其有效 UID。
		Ⅲ	已保存的设置用户ID【Saved set-user-ID】
			保存的设置用户ID用于 suid 情况，其中进程可以通过在真实UID和保存的设置用户ID之间切换其有效UID来获取特权。
			如，为了允许进程使用某些网络端口，它需要提升权限（如，以root身份运行）。进程可通过 getresuid(2) 获取其保存的设置用户ID。
		Ⅳ	文件系统 UID【Filesystem UID】
			这些特定于Linux的ID用于确定文件访问权限。最初引入此UID是为了支持文件服务器代表普通用户进行操作，同时将进程与所述用户的信号隔离的用例。
			程序通常不会直接操作这个UID。内核会跟踪有效UID何时更改，并自动更改文件系统UID。这意味着文件系统UID通常与有效UID相同，但可以通过 setfsuid(2)进行更改。
			注意，从技术上讲，自内核v2.0起不再需要此UID，但出于兼容性考虑，仍受支持。
		最初，当通过 fork(2) 创建子进程时，它会继承其父进程UID的副本，并且在execve(2) 系统调用期间，会保留进程的真实UID，而有效UID和保存的设置用户ID可能会改变。
		如，当运行passwd时，有效UID是您的UID【如1000】。现在，passwd启用了suid设置，这意味着当运行它时，有效UID时0【root】。还有其他方法可以影响有效UID，如使用chroot和其他沙箱技术。
		POSIX 线程【https://en.wikipedia.org/wiki/Pthreads】要求进程中的所有线程都共享凭据。然而，在内核级别，Linux为每个线程维护单独的用户组凭据。
		除了文件访问权限之外，内核还将进程UID用于其他用途，如：
			①	建立发送信号的权限【如，确定当对某个进程ID执行 kill -9 时会发生什么】
			②	调度和优先级的权限处理【如，nice】
			③	检查资源限制
		虽然在 suid 的背景下使用有效的 UID 进行推理可能很简单，但一旦功能发挥作用，它可能会更具挑战性。
4、高级权限管理
	①	功能【Capabilities】
		在Linux中，与UNIX系统中的传统情况一样，root用户在运行进程时没有任何限制。换句话说，内核只区分两种情况：
		Ⅰ	特权进程，绕过内核权限检查，有效UID为0（root）
		Ⅱ	非特权进程，具有非零有效UID，内核对其进行权限检查
		随着内核v2.2中功能系统调用的引入，这种二进制世界观发生了变化：传统上与root相关的特权现在被分解为可以在每个线程级别上独立分配的不同单元。
		实际上，这个想法是正常进程的能力为零。可以为可执行文件（二进制文件和shell脚本）以及进程分配功能，以逐步添加执行任务所需的权限。
		现在，注意：功能通常仅与系统级任务相关。即大多数时候，不一定依赖它们。一些更广泛使用的功能如下：
			功能【Capability】			语义学【Semantics】
			CAP_CHOWN					允许用户对文件的UID/GID进行任意更改
			CAP_KILL					允许向属于其他用户的进程发送信号
			CAP_SETUID					允许更改UID
			CAP_SETPCAP					允许设置正在运行的进程的功能
			CAP_NET_ADMIN				允许各种与网络相关的操作【如，接口配置】
			CAP_NET_RAW					允许使用RAW和PACKET套接字
			CAP_SYS_CHROOT				允许调用chroot
			CAP_SYS_ADMIN				允许系统管理操作，包括挂载文件系统
			CAP_SYS_PTRACE				允许使用 strace 调试进程
			CAP_SYS_MODULE				允许加载内核模块
		查看系统所有功能概览：
			# capsh --print
			Current: =ep
			Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore
			Ambient set =
			Current IAB: 
			Securebits: 00/0x0/1'b0 (no-new-privs=0)
			 secure-noroot: no (unlocked)
			 secure-no-suid-fixup: no (unlocked)
			 secure-keep-caps: no (unlocked)
			 secure-no-ambient-raise: no (unlocked)
			uid=0(root) euid=0(root)
			gid=0(root)
			groups=0(root)
			Guessed mode: UNCERTAIN (0)
		查看当前进程【shell】的所有功能概览：
			# grep Cap /proc/$$/status
			CapInh: 0000000000000000
			CapPrm: 000001ffffffffff
			CapEff: 000001ffffffffff
			CapBnd: 000001ffffffffff
			CapAmb: 0000000000000000
		可以使用 getcap 和 setcap 以细粒度的方式（即基于每个文件）管理功能。
		功能有助于从“全有或全无”的方法过渡到基于文件的更细粒度的权限。
	②	seccomp Profiles
		安全计算模式【secure computing mode（seccomp）】是自2005年起提供的Linux内核功能。这种沙箱技术背后的基本思想是，使用名为 seccomp(2) 的专用系统调用，可以限制进程可以使用的系统调用。
		可能会发现直接管理 seccomp 很不方便，但有一些方法可以轻松使用它。如，在容器环境中，Docker 和 Kubernetes 都支持 seccomp。
	③	访问控制列表
		借助于访问控制列表（ACLs），在Linux中拥有灵活的权限机制。ACL解决了传统权限的缺陷，因为它们允许向用户或不在用户组列表中的组授予权限。
		可以使用 grep -i acl /boot/config* 来检查发行版是否支持 ACL 【输出中包含 POSIX_ACL=Y】。为了对文件系统使用 ACL，必须在挂载时使用 acl 选项启用它【见 acl 的文档参考】。
5、良好的实践
	以下是更广泛的访问控制背景下的一些安全“良好实践”。 其中一些可能更适用于专业环境。
	①	最少权限
		最小权限原则是指一个人或进程应该只拥有完成给定任务所需的权限。如，如果应用程序不写入文件，则它只需要读取访问权限。 在访问控制的上下文中，可以通过两种方式实践最小权限：
		》通过数字模式使用显式权限比符号模式更好
		》尽可能避免以root身份运行【优先考虑 sudo 提权】
		注意，如果正在编写应用程序，则可以使用 SELinux 策略来限制仅访问选定的文件、目录和其他功能。 相比之下，默认的 Linux 模型可能会让应用程序访问系统上打开的任何文件。
	②	避免 setuid
		利用功能【capabilities】而不是依赖 setuid【为攻击者提供了一种接管系统的好方法】
	③	审计【auditing】
		审计是指以无法篡改结果日志的方式记录操作（以及执行这些操作的人员）。然后，可以使用此只读日志来验证谁在何时做了什么。
6、扩展
	①	通用【General】
		》“A Survey of Access Control Policies”【https://www.cs.umd.edu/sites/default/files/scholarly_papers/ACrowell_1.pdf】
		》Lynis【https://cisofy.com/lynis/】，审计和合规性测试工具
	②	功能【Capabilities】
		》“Linux Capabilities in Practice”【https://blog.container-solutions.com/linux-capabilities-in-practice】
		》“Linux Capabilities: Making Them Work”【https://www.kernel.org/doc/ols/2008/ols2008v1-pages-163-172.pdf】
	③	seccomp
		》“A seccomp Overview”【https://lwn.net/Articles/656307/】
		》“Sandboxing in Linux with Zero Lines of Code”【https://blog.cloudflare.com/sandboxing-in-linux-with-zero-lines-of-code/】
	④	访问控制列表【ACLs】
		》“POSIX Access Control Lists on Linux”【https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/gruenbacher/gruenbacher_html/main.html】
		》“Access Control Lists” via ArchLinux【https://wiki.archlinux.org/title/Access_Control_Lists】
		》“An Introduction to Linux Access Control Lists (ACLs)” via Red Hat【https://www.redhat.com/sysadmin/linux-access-control-lists】



				
			

			



		

